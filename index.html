<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" type="image/png" href="https://i.imgur.com/lMAoVCW.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Writing Center dot org</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700&family=Open+Sans:wght@300;400;500;600&family=Shadows+Into+Light&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        [title] {
            position: relative;
        }

        /* Override the default tooltip behavior */
        [title]::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        body {
            font-family: 'Playfair Display', serif;
            background-color: #f8f8fa; /* Off-white background for the body */
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #new-document-btn {
            display: none; /* Completely hides the element but keeps it in the DOM */
        }

        .fixed-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background-color: white; /* White header */
            border-bottom: 3px solid #57068c; /* Light purple bottom border (NYU violet) */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1010;
        }

        .logo img {
            height: 60px; /* Adjust this value as needed */
            width: auto; /* Ensure the image takes full width */
        }


        .header-right {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .action-btn {
            background-color: white;
            border: 2px solid #57068c;
            border-radius: 20px;
            padding: 8px 20px;
            font-family: 'Playfair Display', serif;
            color: #57068c;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            font-weight: 500;
            outline: none;
        }

        .action-btn:hover {
            background-color: #f4ebfa;
        }

        .action-btn.primary {
            background-color: #57068c;
            color: white;
        }

        .action-btn.primary:hover {
            background-color: #400667;
        }

       /* Main container adjustments */
        main {
            margin-top: 70px;
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0;
            max-width: 1200px;
            width: 100%;
            margin-left: auto;
            margin-right: auto;
            position: relative;
            overflow: visible; /* Ensure main doesn't restrict overflow */
        }

        h1, h2, h3 {
            font-family: 'Playfair Display', serif;
            color: #57068c; /* NYU violet for headings */
        }

        /* Add spacing between paragraphs in normal editing mode */
        #editor p, 
        #editor div, 
        #editor h1, 
        #editor h2, 
        #editor h3, 
        #editor h4, 
        #editor h5, 
        #editor h6 {
            margin-bottom: 1em; /* Creates space after each paragraph */
            margin-top: 0;      /* Prevents double spacing */
        }

        /* Ensure empty paragraphs maintain height */
        #editor p:empty {
            min-height: 1.6em;  /* Maintains consistent line height */
            display: block;     /* Ensures the empty paragraph is visible */
        }

        /* Remove these margins when special modes are active to avoid interference */
        .textris-mode #editor p,
        .fire-mode #editor p,
        .textris-mode #editor div,
        .fire-mode #editor div,
        .textris-mode #editor h1,
        .fire-mode #editor h1,
        .textris-mode #editor h2,
        .fire-mode #editor h2,
        .textris-mode #editor h3,
        .fire-mode #editor h3,
        .textris-mode #editor h4,
        .fire-mode #editor h4,
        .textris-mode #editor h5,
        .fire-mode #editor h5,
        .textris-mode #editor h6,
        .fire-mode #editor h6 {
            margin-bottom: 0;   /* Remove spacing in special modes */
        }

       /* Platform container - shifted right to make room for trigger */
        /* Platform container - ensure proper height and overflow */
        .platform-container {
            position: relative;
            margin-left: 20px;
            margin-right: 20px;
            height: calc(100vh - 170px);
            margin-top: 20px;
            border-radius: 8px;
            overflow: visible !important;/* Hidden for container, but not children */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        /* Fix any parent containers that might be cutting off the dropdown */
        .platform-container, .editor-container {
            overflow: visible !important;
        }

        .platform-container, 
        .editor-container,
        .toolbar-group {
            overflow: visible !important;
        }


     /* Sidebar trigger at the very left edge of the screen */
        .sidebar-trigger {
            position: fixed;
            left: 0;
            top: 70px;
            bottom: 0;
            width: 20px;
            background-color: #f8f8fa;
            z-index: 90;
            cursor: pointer;
            border-right: 1px solid #eee;
            pointer-events: auto; /* Ensure events work */
        }

        /* Visual indicator for the trigger area */
        .sidebar-trigger::after {
            content: "•••";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(87, 6, 140, 0.3);
            font-size: 14px;
            writing-mode: vertical-rl;
            letter-spacing: 5px;
        }

        .sidebar-trigger:hover::after {
            color: rgba(87, 6, 140, 0.6);
        }

        /* Move toggle button with sidebar */
        .sidebar-collapsed .sidebar-toggle {
            left: 10px; /* Small margin when collapsed */
        }

        .sidebar-toggle:hover {
            background-color: #f4ebfa;
        }

        /* When sidebar is open, ensure it pushes content */
        .sidebar.active ~ .editor-container {
            left: 250px;
            transition: left 0.3s ease;
        }

        /* Rotate icon when sidebar is collapsed */
        .sidebar-collapsed #sidebar-toggle-icon {
            transform: rotate(180deg);
        }

        /* Sidebar - positioned as overlay with hover transition */
        .sidebar {
            position: fixed;
            left: 0;
            top: 70px;
            bottom: 0;
            width: 250px;
            background-color: white;
            border-right: 1px solid #eee;
            padding: 20px;
            overflow-y: auto;
            z-index: 100;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
            pointer-events: auto; /* Ensure it doesn't block events when hidden */
        }

        /* Add hover-persist effect - to prevent flickering */
        .sidebar::after {
            content: "";
            position: absolute;
            top: 0;
            left: 100%;
            width: 20px; /* Match trigger width */
            height: 100%;
            opacity: 0;
        }


     /* Ensure hover always works by using CSS-only hover functionality */
        .sidebar-trigger:hover ~ .sidebar,
        .sidebar:hover {
            transform: translateX(0) !important; /* !important to override inline styles */
        }

        .sidebar:hover::after {
            opacity: 1;
        }

        /* Sidebar header styling */
        .sidebar-header {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #f4ebfa;
        }

       /* When collapsed, transform the sidebar off-screen */
        .sidebar-collapsed .sidebar {
            transform: translateX(-100%);
        }

        .document-list {
            list-style: none;
        }

        .document-item {
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .document-item:hover {
            background-color: #f4ebfa;
        }

        .document-item.active {
            background-color: #f4ebfa;
            border-left: 3px solid #57068c;
        }

        .document-item .doc-title {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .document-item .doc-date {
            font-size: 0.8rem;
            color: #666;
        }

      /* Editor container - takes full width of platform container */
      .editor-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: white;
            z-index: 50;
        }

        .editor-toolbar {
            padding: 10px 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            position: relative;
            z-index: 1010 !important; /* Higher than the modes row */
            overflow: visible !important;
            background-color: #f9f9f9;
        }

        /* Fix editor toolbar positioning */
        .editor-toolbar,
        .editor-toolbar-modes,
        .status-bar {
            flex-shrink: 0; /* Prevent these from shrinking */
            position: relative; /* Create stacking context */
            z-index: 60; /* Above editor content but below sidebar */
        }

        .toolbar-title {
            font-weight: 600;
            color: #57068c;
            margin-right: 20px;
        }

        .toolbar-group {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 3px;
            border-radius: 4px;
            overflow: visible !important;
        }

        .toolbar-btn {
            background: none;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            color: #333;
            transition: all 0.2s ease;
        }
        
        /* Remove default browser tooltips and replace with custom ones */
        .toolbar-btn[data-tooltip]:hover::after,
        .action-btn[data-tooltip]:hover::after,
        .modes-toggle-btn[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            font-family: 'Open Sans', sans-serif;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 3000 !important;
        }

        /* Clear tooltips */
        .toolbar-btn[title]:not(:hover)::after,
        .action-btn[title]:not(:hover)::after {
            display: none;
        }

        /* Add small arrow to tooltips */
        .toolbar-btn[data-tooltip]:hover::before,
        .action-btn[data-tooltip]:hover::before,
        .modes-toggle-btn[data-tooltip]:hover::before {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent rgba(0, 0, 0, 0.8) transparent;
            z-index: 1020;
        }

        .download-dropdown-content {
            position: absolute;
            z-index: 2000 !important; /* Much higher than anything else */
            top: 100%;
            right: 0;
            min-width: 200px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            overflow: visible !important;
        }

        /* Fix dropdown menus and tooltips to appear above both toolbar levels */
        .toolbar-btn:hover::after,
        .action-btn:hover::after,
        .download-dropdown-content {
            z-index: 1015; /* Higher than everything */
        }

        .download-dropdown {
            position: relative; 
            display: inline-block;
        }

        .toolbar-btn,
        .action-btn,
        .modes-toggle-btn {
            position: relative; /* Ensure positioning context for tooltips */
        }

        .toolbar-btn:hover {
            background-color: #f4ebfa;
            border-color: #e0d0eb;
        }

        .toolbar-btn.active {
            background-color: #f4ebfa;
            border-color: #57068c;
            color: #57068c;
        }

        .toolbar-separator {
            height: 20px;
            width: 1px;
            background-color: #ddd;
            margin: 0 5px;
        }

        .textris-section {
            background-color: #f4ebfa;
            padding: 3px 10px;
            border-radius: 4px;
            border: 1px solid #e0d0eb;
            display: flex;
            align-items: center;
        }
        
        .textris-btn {
            font-weight: 500;
            color: #57068c;
            background: none;
            border: 1px solid #57068c;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .textris-btn:hover {
            background-color: #e0d0eb;
        }
        
        .textris-btn.active {
            background-color: #57068c;
            color: white;
        }
        
        .textris-select {
            margin-left: 8px;
            padding: 5px 8px;
            border: 1px solid #57068c;
            border-radius: 4px;
            background-color: white;
            color: #333;
            font-family: 'Open Sans', sans-serif;
            font-size: 14px;
        }

        /* Container for history buttons */
        .textris-history-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 15px;
            padding-left: 15px;
            border-left: 1px solid rgba(87, 6, 140, 0.2);
        }

        /* Style for the history buttons */
        .textris-history-btn {
            background-color: white;
            border: 1px solid #57068c;
            color: #57068c;
            border-radius: 4px;
            padding: 3px 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .textris-history-btn:hover {
            background-color: #f4ebfa;
        }

        .textris-history-btn:active {
            transform: translateY(1px);
        }

        .textris-history-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #ccc;
            color: #999;
        }

        .textris-history-btn.disabled:hover {
            background-color: white;
        }

        .textris-history-btn i {
            margin-right: 4px;
            font-size: 0.8rem;
        }

        .editor-content {
            flex: 1; /* Take remaining space */
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto !important; /* Force scroll when needed */
            position: relative; /* Create stacking context */
        }

        /* Editor itself - ensure it can grow but also scroll */
        #editor {
            width: 100%;
            height: 100%;
            min-height: 100%; /* Ensure it takes full height */
            border: none;
            padding: 10px;
            font-family: 'Open Sans', sans-serif;
            font-size: 16px;
            line-height: 1.6;
            overflow-y: auto !important; /* Force scroll capability */
            outline: none;
        }

        #editor:focus {
            box-shadow: 0 0 0 2px rgba(87, 6, 140, 0.1);
        }
        
        #editor[placeholder]:empty:before {
            content: attr(placeholder);
            color: #888;
            cursor: text;
        }

        /* Textris Mode Styles */
        .textris-mode p, .textris-mode div, .textris-mode h1, .textris-mode h2, .textris-mode h3, 
        .textris-mode h4, .textris-mode h5, .textris-mode h6 {
            border: 1px dashed transparent;
            margin: 5px 0;
            padding: 5px;
            transition: all 0.2s ease;
            border-radius: 3px;
        }
        
        .textris-mode p:hover, .textris-mode div:hover, .textris-mode h1:hover, .textris-mode h2:hover, 
        .textris-mode h3:hover, .textris-mode h4:hover, .textris-mode h5:hover, .textris-mode h6:hover {
            border-color: #57068c;
            background-color: rgba(87, 6, 140, 0.03);
            cursor: move;
        }
        
        .textris-mode .dragging {
            opacity: 0.5;
            border: 1px dashed #57068c;
            background-color: rgba(87, 6, 140, 0.05);
        }
        
        .textris-mode .drag-target {
            border-top: 3px solid #57068c;
        }
        
        .textris-sentence {
            border: 1px dashed transparent;
            padding: 2px 3px;
            border-radius: 3px;
            transition: all 0.2s ease;
            display: inline-block;
        }
        
        .textris-sentence:hover {
            border-color: #57068c;
            background-color: rgba(87, 6, 140, 0.03);
            cursor: move;
        }
        
        .textris-sentence.dragging {
            opacity: 0.5;
            border: 1px dashed #57068c;
            background-color: rgba(87, 6, 140, 0.05);
        }
        
        .sentence-drag-target {
            border-right: 3px solid #57068c;
        }

        .status-bar {
            padding: 10px 20px;
            border-top: 1px solid #eee;
            font-size: 0.8rem;
            color: #666;
            display: flex;
            justify-content: space-between;
            background-color: #f9f9f9;
        }

        /* Modal Styling */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1001;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.5rem;
            color: #57068c;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Open Sans', sans-serif;
        }

        .form-input:focus {
            border-color: #57068c;
            outline: none;
            box-shadow: 0 0 0 2px rgba(87, 6, 140, 0.1);
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* Notification Style */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            background-color: #57068c;
            color: white;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1002;
        }

        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }

        .notification i {
            margin-right: 10px;
            font-size: 1.2rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .platform-container {
                flex-direction: column;
                height: auto;
            }
            
            .editor-container {
                width: 100%;
            }

            .reader-modal {
                width: 95%;
                height: 95vh;
            }
            
            .reader-sentence {
                font-size: 16px;
            }
            
            .reader-sentence-block {
                padding: 15px;
            }

            .sidebar {
                width: 80%;
                max-width: 250px;
            }
            
            .platform-container {
                margin-left: 10px;
                margin-right: 10px;
            }
            
            .sidebar-trigger {
                width: 10px;
            }
        
            .editor-toolbar {
                flex-wrap: wrap;
            }

            .toolbar-group {
                margin-bottom: 5px;
            }
        }

        /* Site Footer */
        .site-footer {
            background-color: #f2f2f2;
            padding: 20px 0;
            border-top: 1px solid #dedede;
            font-size: 0.9rem;
            color: #666;
            text-align: center;
        }

        /* Mode System Styles - Add these to your CSS */

        /* Modes Toggle Button */
        .modes-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modes-toggle-btn {
            background-color: #f4ebfa;
            border: 1px solid #57068c;
            border-radius: 4px;
            padding: 8px 12px;
            color: #57068c;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s ease;
        }

        .modes-toggle-btn:hover {
            background-color: #e0d0eb;
        }

        .active-mode-indicator {
            display: none;
            background-color: #f4ebfa;
            border: 1px solid #57068c;
            border-radius: 15px;
            padding: 5px 12px 5px 15px;
            font-size: 0.9rem;
            align-items: center;
            gap: 8px;
            margin-left: 10px;
        }

        .active-mode-indicator.visible {
            display: flex;
        }

        .active-mode-name {
            color: #57068c;
            font-weight: 500;
        }

        .active-mode-options {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 5px;
            padding-left: 10px;
            border-left: 1px solid rgba(87, 6, 140, 0.3);
        }

        .mode-option-select {
            background-color: white;
            border: 1px solid #57068c;
            border-radius: 4px;
            padding: 3px 6px;
            font-family: 'Open Sans', sans-serif;
            font-size: 0.8rem;
            color: #333;
        }

        .disable-mode-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 0.9rem;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            margin-left: 5px;
        }

        .disable-mode-btn:hover {
            color: #333;
            background-color: rgba(0, 0, 0, 0.05);
        }

        /* Modes Toggle Button */
.modes-toggle-section {
    margin-left: auto;
}

.modes-toggle-btn {
    background-color: #f4ebfa;
    border: 1px solid #57068c;
    border-radius: 4px;
    padding: 8px 12px;
    color: #57068c;
    font-weight: 500;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.2s ease;
}

.modes-toggle-btn:hover {
    background-color: #e0d0eb;
}

/* Second toolbar row for modes */
.editor-toolbar-modes {
    padding: 6px 20px;
    border-bottom: 1px solid #eee;
    display: flex;
    align-items: center;
    background-color: #f9f9f9;
    min-height: 36px;
    position: relative;
    z-index: 1005 !important; /* Lower than main toolbar */
    overflow: visible !important;
}

.active-mode-indicator {
    display: none;
    background-color: #f4ebfa;
    border: 1px solid #57068c;
    border-radius: 15px;
    padding: 5px 12px 5px 15px;
    font-size: 0.9rem;
    align-items: center;
    gap: 8px;
    margin-left: 10px;
}

.active-mode-indicator.visible {
    display: flex;
}

.active-mode-name {
    color: #57068c;
    font-weight: 500;
}

.disable-mode-btn {
    background: none;
    border: none;
    color: #666;
    cursor: pointer;
    font-size: 0.9rem;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    border-radius: 50%;
}

.disable-mode-btn:hover {
    color: #333;
    background-color: rgba(0, 0, 0, 0.05);
}

/* Modes Panel */
.modes-panel-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.3);
    z-index: 1003;
}

.modes-panel {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    max-width: 800px;
    max-height: 80vh;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    z-index: 1004;
    flex-direction: column;
    overflow: hidden;
}

.modes-panel.visible {
    display: flex;
}

.modes-panel-overlay.visible {
    display: block;
}

.modes-panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    border-bottom: 2px solid #f4ebfa;
}

.modes-panel-header h3 {
    color: #57068c;
    margin: 0;
    font-size: 1.3rem;
}

.close-panel-btn {
    background: none;
    border: none;
    font-size: 1.2rem;
    color: #666;
    cursor: pointer;
}

.close-panel-btn:hover {
    color: #333;
}

.modes-panel-body {
    padding: 15px 20px;
    overflow-y: auto;
    max-height: calc(80vh - 60px);
}

.modes-category {
    margin-bottom: 25px;
}

.modes-category h4 {
    color: #57068c;
    margin-bottom: 12px;
    padding-bottom: 5px;
    border-bottom: 1px solid #f4ebfa;
}

.modes-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 15px;
}

.mode-card {
    background-color: white;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 15px;
    transition: all 0.2s ease;
    position: relative;  /* Add relative positioning */
    min-height: 180px;   /* Set a minimum height for all cards */
    display: flex;       /* Use flexbox for internal layout */
    flex-direction: column;  /* Stack elements vertically */
}

.mode-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
    border-color: #ccc;
}

.mode-card.disabled {
    opacity: 0.7;
    pointer-events: none;
}

.mode-card.active {
    border-color: #57068c;
    background-color: #fcf9ff;
}

.mode-card-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
}

.mode-card-header i {
    color: #57068c;
    font-size: 1.2rem;
}

.mode-card-header h5 {
    margin: 0;
    color: #333;
    font-size: 1.1rem;
}

.mode-description {
    color: #666;
    font-size: 0.9rem;
    margin-bottom: 15px;
    line-height: 1.4;
    font-family: 'Open Sans', sans-serif;
    flex-grow: 1;  /* Allow description to take up available space */
}

.mode-options {
    display: flex;
    justify-content: flex-end;  /* Align content to the right */
    align-items: center;
    margin-top: auto;  /* Push to the bottom */
    width: 100%;       /* Take full width */
}

.mode-option-label {
    font-size: 0.8rem;
    color: #57068c;
}

.mode-select {
    padding: 6px 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-family: 'Open Sans', sans-serif;
    font-size: 0.9rem;
    max-width: 150px;  /* Limit width */
    margin-right: auto;  /* Push to the left */
}

.activate-mode-btn {
    background-color: #57068c;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 8px 12px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: all 0.2s ease;
    white-space: nowrap;  /* Prevent wrapping */
}

.activate-mode-btn:hover {
    background-color: #400667;
}

.activate-mode-btn:disabled {
    background-color: #ccc;
    cursor: not-allowed;
}


/* Reader Mode Styles for Accumulating Sentences */
/* Reader Mode Modal Styles */
.reader-modal-backdrop {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}

.reader-modal {
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    width: 90%;
    max-width: 900px;
    height: 90vh;
    max-height: 800px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.reader-modal-header {
    padding: 15px 20px;
    border-bottom: 2px solid #f4ebfa;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.reader-modal-header h3 {
    color: #57068c;
    margin: 0;
    font-size: 1.4rem;
}

.reader-modal-close {
    background: none;
    border: none;
    font-size: 1.8rem;
    color: #666;
    cursor: pointer;
}

.reader-modal-close:hover {
    color: #333;
}

.reader-modal-content {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
}

.reader-modal-footer {
    padding: 15px 20px;
    border-top: 1px solid #f4ebfa;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.reader-status-text {
    color: #57068c;
    font-weight: 500;
}

.reader-footer-buttons {
    display: flex;
    gap: 15px;
}

.reader-footer-button {
    padding: 8px 15px;
    border-radius: 4px;
    font-weight: 500;
    cursor: pointer;
}

.reader-footer-button.secondary {
    background-color: #f4ebfa;
    border: 1px solid #57068c;
    color: #57068c;
}

.reader-footer-button.secondary:hover {
    background-color: #e0d0eb;
}

/* Integrated Container Styles */
.reader-mode-integrated-container {
    display: flex;
    flex-direction: column;
    gap: 30px;
}

.reader-sentence-block {
    background-color: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(87, 6, 140, 0.1);
    padding: 20px;
    animation: fadeSlideIn 0.5s ease;
    border-left: 3px solid #57068c;
}

@keyframes fadeSlideIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.reader-sentence {
    font-size: 18px;
    line-height: 1.6;
    color: #333;
    margin-bottom: 15px;
    padding-bottom: 15px;
    border-bottom: 1px solid #f4ebfa;
}

.reader-reflection-wrapper {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.reader-prompt {
    font-style: italic;
    color: #444;
    padding: 8px 10px;
    background-color: #f9f4ff;
    border-radius: 4px;
}

.reader-prompt strong {
    color: #57068c;
}

.reader-reflection-input {
    width: 100%;
    padding: 12px;
    border: 1px solid #e0d0eb;
    border-radius: 4px;
    font-family: 'Open Sans', sans-serif;
    font-size: 14px;
    line-height: 1.6;
    resize: vertical;
    min-height: 80px;
}

.reader-reflection-input:focus {
    outline: none;
    border-color: #57068c;
    box-shadow: 0 0 0 2px rgba(87, 6, 140, 0.1);
}

.reader-reveal-button {
    align-self: flex-end;
    background-color: #57068c;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 8px 15px;
    font-weight: 500;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 10px;
}

.reader-reveal-button:hover {
    background-color: #400667;
}

.reader-reveal-button i {
    font-size: 12px;
}



    /* Remove padding when sidebar is collapsed */
    .sidebar-collapsed .editor-container {
        padding-left: 0;
    }

    .notification-error {
         background-color: #d9534f;
        }

    .notification-warning {
        background-color: #f0ad4e;
        }

        /* Highlight base styles */
    .key-term-highlight {
        transition: background-color 0.2s ease;
        border-radius: 2px;
        box-decoration-break: clone;
        -webkit-box-decoration-break: clone;
    }

    /* Key Terms Panel styles */
    #key-terms-panel .modal-content {
        max-width: 700px;
    }

    #key-terms-panel .modal-body {
        padding-bottom: 20px;
    }

    #key-terms-list {
        max-height: 300px;
        overflow-y: auto;
        margin: 15px 0;
        padding-right: 5px;
    }

    .key-terms-row {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
        gap: 10px;
    }

    .key-terms-row .form-input {
        flex-grow: 1;
    }

    /* Color input styling */
    input[type="color"] {
        -webkit-appearance: none;
        appearance: none;
        width: 40px;
        height: 40px;
        padding: 0;
        border: 1px solid #ddd;
        border-radius: 4px;
        cursor: pointer;
    }

    input[type="color"]::-webkit-color-swatch-wrapper {
        padding: 0;
    }

    input[type="color"]::-webkit-color-swatch {
        border: none;
        border-radius: 3px;
    }

    /* Term count badge */
    .term-count-badge {
        display: inline-block;
        background-color: #57068c;
        color: white;
        font-size: 0.8rem;
        padding: 2px 8px;
        border-radius: 10px;
        margin-left: 10px;
    }

    /* Instructions */
    .key-terms-instructions {
        background-color: #f9f4ff;
        border-left: 3px solid #57068c;
        padding: 10px 15px;
        margin-bottom: 15px;
        font-size: 0.9rem;
        color: #333;
    }

    .key-terms-instructions code {
        background-color: #eee;
        padding: 2px 4px;
        border-radius: 3px;
        font-family: monospace;
    }

    /* Add Term Button */
    #add-term-btn {
        background-color: #f4ebfa;
        border: 1px solid #57068c;
        color: #57068c;
    }

    #add-term-btn:hover {
        background-color: #e0d0eb;
    }

    /* Remove button */
    .remove-term-btn {
        background: none;
        border: none;
        color: #999;
        cursor: pointer;
        font-size: 1rem;
        transition: color 0.2s ease;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
    }

    .remove-term-btn:hover {
        color: #d9534f;
        background-color: rgba(217, 83, 79, 0.1);
    }


/* Columbia Specific Styling */
.columbia-theme .fixed-header {
  border-bottom: 3px solid #003373; /* Darker Columbia blue color */
}

.columbia-theme .header-title {
  color: #003373;
}

.columbia-theme .action-btn {
  border: 2px solid #003373;
  color: #003373;
}

.columbia-theme .action-btn:hover {
  background-color: rgba(0, 51, 115, 0.1);
}

.columbia-theme .action-btn.primary {
  background-color: #003373;
  color: white;
}

.columbia-theme .action-btn.primary:hover {
  background-color: #002255;
}

.columbia-theme h1, 
.columbia-theme h2, 
.columbia-theme h3 {
  color: #003373;
}

.columbia-theme .toolbar-title {
  color: #003373;
}

.columbia-theme .modes-toggle-btn {
  background-color: rgba(0, 51, 115, 0.1);
  border: 1px solid #003373;
  color: #003373;
}

.columbia-theme .active-mode-indicator {
  background-color: rgba(0, 51, 115, 0.1);
  border: 1px solid #003373;
}

.columbia-theme .active-mode-name {
  color: #003373;
}

.columbia-theme .notification {
  background-color: #003373;
}

/* Login Error Message */
#login-error {
  background-color: rgba(217, 83, 79, 0.1);
  padding: 10px;
  border-radius: 4px;
  margin-top: 15px;
  text-align: left;
  animation: fadeIn 0.5s ease;
}

#login-error i {
  margin-right: 6px;
}

@keyframes slideInError {
  from { transform: translateY(-10px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

/* Purdue Styling */
.purdue-theme .fixed-header {
  border-bottom: 3px solid #cfb991; /* Purdue Gold */
}

.purdue-theme .header-title {
  color: #000000; /* Purdue Black */
}

.purdue-theme .action-btn {
  border: 2px solid #cfb991;
  color: #000000;
}

.purdue-theme .action-btn:hover {
  background-color: rgba(207, 185, 145, 0.2);
}

.purdue-theme .action-btn.primary {
  background-color: #daaa00; /* Purdue Brighter Gold */
  color: #000000;
  border-color: #daaa00;
}

.purdue-theme .action-btn.primary:hover {
  background-color: #ddb945; /* Purdue Supporting Gold */
}

.purdue-theme h1, 
.purdue-theme h2, 
.purdue-theme h3 {
  color: #000000;
}

.purdue-theme .toolbar-title {
  color: #000000;
}

.purdue-theme .modes-toggle-btn {
  background-color: rgba(207, 185, 145, 0.2);
  border: 1px solid #cfb991;
  color: #000000;
}

.purdue-theme .active-mode-indicator {
  background-color: rgba(207, 185, 145, 0.2);
  border: 1px solid #cfb991;
}

.purdue-theme .active-mode-name {
  color: #000000;
}

.purdue-theme .notification {
  background-color: #000000;
  color: #cfb991;
}

#login-error.show {
  display: block !important;
  animation: slideInError 0.3s ease;
}/* Import Shadows Into Light font */
@import url('https://fonts.googleapis.com/css2?family=Shadows+Into+Light&display=swap');



/* Header title styling for all themes */
.header-title {
  font-family: 'Shadows Into Light', cursive;
  font-size: 1.8rem;
  font-weight: 400;
}
  
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes slideIn {
    from { transform: translateY(-20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
  }

  /* You can add this to your existing style section */
#report-bug-btn {
    /* Any special styling for the bug report button */
    /* For example, if you want to make it less prominent than the New Document button */
    background-color: white;
    color: #57068c;
}

#report-bug-btn:hover {
    background-color: #f4ebfa;
}

/* Institution-specific styling */
.columbia-theme #report-bug-btn {
    color: #003373;
}

.columbia-theme #report-bug-btn:hover {
    background-color: rgba(0, 51, 115, 0.1);
}

.purdue-theme #report-bug-btn {
    color: #000000;
    border-color: #cfb991;
}

.purdue-theme #report-bug-btn:hover {
    background-color: rgba(207, 185, 145, 0.2);
}

/* Fire background */
.fire-background {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 187, 153, 0.1) 0%, rgba(255, 136, 68, 0.1) 50%, rgba(232, 97, 45, 0.1) 100%);
            z-index: -1;
            pointer-events: none;
            animation: fire-pulse 3s infinite alternate;
            border-radius: 8px;
        }
        
        @keyframes fire-pulse {
            0% { opacity: 0.5; }
            100% { opacity: 0.8; }
        }
        
        /* Selectable sentences */
        .fire-sentence {
            cursor: pointer;
            padding: 0 2px;
            border-radius: 2px;
            transition: all 0.2s ease;
            display: inline;
        }
        
        .fire-sentence:hover {
            background-color: rgba(255, 136, 68, 0.1);
        }
        
        /* Selected key sentences */
        .fire-sentence.fire-selected {
            background-color: rgba(255, 136, 68, 0.2);
            box-shadow: 0 0 0 1px rgba(232, 97, 45, 0.3);
        }

        /* Override hover and cursor in restructuring mode */
        .fire-restructuring .fire-sentence {
            cursor: text;
        }

        .fire-restructuring .fire-sentence:hover {
            background-color: transparent;
        }

        /* Keep the highlighting for selected sentences in restructuring mode */
        .fire-restructuring .fire-sentence.fire-selected {
            background-color: rgba(255, 136, 68, 0.2);
            box-shadow: 0 0 0 1px rgba(232, 97, 45, 0.3);
        }
        
        /* Target positions */
        .fire-sentence.fire-target-position {
            border-bottom: 2px dashed rgba(0, 0, 0, 0.2);
        }
        
        /* Selected sentences in target positions */
        .fire-sentence.fire-selected.fire-target-position {
            background-color: rgba(255, 136, 68, 0.3);
            box-shadow: 0 0 0 1px rgba(232, 97, 45, 0.5);
            border-bottom: 2px solid rgba(232, 97, 45, 0.5);
        }
        
        /* Fire Mode UI elements */
        .fire-stage-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            color: #E8612D;
        }
        
        .fire-counter {
            background-color: rgba(255, 136, 68, 0.1);
            padding: 3px 10px;
            border-radius: 12px;
            margin-left: 15px;
            font-size: 0.9rem;
            color: #E8612D;
        }

        /* Meta Mode Styles */
        .meta-mode {
            display: flex;
            flex-direction: column;
            padding: 20px 0;
            max-width: 900px;
            margin: 0 auto;
        }

        .meta-paragraph-container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
            border: 1px solid #eee;
        }

        .meta-says-column {
            padding: 15px;
            background-color: rgba(87, 6, 140, 0.03);
            border-radius: 8px;
            border-left: 3px solid var(--primary-color, #57068c);
        }

        .meta-paragraph-column {
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
        }

        .meta-does-column {
            padding: 15px;
            background-color: rgba(87, 6, 140, 0.03);
            border-radius: 8px;
            border-right: 3px solid var(--primary-color, #57068c);
        }

        .meta-column-heading {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--primary-color, #57068c);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .meta-textarea {
            width: 100%;
            min-height: 120px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
            font-family: 'Open Sans', sans-serif;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.2s ease;
            background-color: white;
        }

        .meta-textarea:focus {
            outline: none;
            border-color: var(--primary-color, #57068c);
            box-shadow: 0 0 0 2px rgba(87, 6, 140, 0.1);
        }

        .meta-textarea::placeholder {
            color: #999;
            font-style: italic;
        }

        .meta-paragraph-counter {
            position: absolute;
            top: -12px;
            left: 20px;
            background-color: var(--primary-color, #57068c);
            color: white;
            border-radius: 12px;
            padding: 3px 12px;
            font-weight: 500;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .meta-instructions {
            background-color: #f8f8fa;
            border-left: 4px solid var(--primary-color, #57068c);
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 0 8px 8px 0;
        }

        .meta-instructions h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--primary-color, #57068c);
        }

        .meta-instructions p {
            margin: 0 0 10px 0;
            font-size: 14px;
            line-height: 1.5;
        }

        .meta-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }

        .meta-nav-buttons {
            display: flex;
            gap: 10px;
        }

        .meta-nav-button {
            background-color: #f4ebfa;
            color: var(--primary-color, #57068c);
            border: 1px solid var(--primary-color, #57068c);
            border-radius: 4px;
            padding: 8px 15px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .meta-nav-button:hover {
            background-color: var(--primary-color-light, #e0d0eb);
        }

        .meta-nav-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .meta-export-button {
            background-color: var(--primary-color, #57068c);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 15px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.2s ease;
        }

        .meta-export-button:hover {
            background-color: var(--primary-color-dark, #400667);
        }

        .meta-progress {
            height: 6px;
            background-color: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin: 20px 0;
        }

        .meta-progress-bar {
            height: 100%;
            background-color: var(--primary-color, #57068c);
            transition: width 0.3s ease;
        }

        .meta-progress-text {
            text-align: center;
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        /* Columbia and Purdue themed styles */
        .columbia-theme .meta-says-column,
        .columbia-theme .meta-does-column {
            background-color: rgba(0, 51, 115, 0.03);
        }

        .purdue-theme .meta-says-column,
        .purdue-theme .meta-does-column {
            background-color: rgba(207, 185, 145, 0.05);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .meta-paragraph-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
                gap: 10px;
            }
            
            .meta-says-column, 
            .meta-does-column {
                border-left: none;
                border-right: none;
                border-top: 3px solid var(--primary-color, #57068c);
            }
            
            .meta-navigation {
                flex-direction: column;
                gap: 10px;
            }
            
            .meta-nav-buttons {
                width: 100%;
                justify-content: space-between;
            }
        }

        /* Reset App Button Styles */
#reset-app-btn {
    background-color: white;
    color: #f44336;
    border: 2px solid #f44336;
}

#reset-app-btn:hover {
    background-color: rgba(244, 67, 54, 0.1);
}

/* Theme-specific styles */
.columbia-theme #reset-app-btn {
    color: #d32f2f;
    border-color: #d32f2f;
}

.columbia-theme #reset-app-btn:hover {
    background-color: rgba(211, 47, 47, 0.1);
}

.purdue-theme #reset-app-btn {
    color: #d32f2f;
    border-color: #d32f2f;
}

.purdue-theme #reset-app-btn:hover {
    background-color: rgba(211, 47, 47, 0.1);
}

/* Trapdoor Button Styles */
#trapdoor-btn {
    position: relative;
    transition: all 0.2s ease;
}

#trapdoor-btn:hover {
    background-color: #f4ebfa;
}

#trapdoor-btn i {
    transition: transform 0.3s ease;
}

#trapdoor-btn:hover i {
    transform: translateY(2px);
}

/* Add tooltip to explain functionality */
#trapdoor-btn::after {
    content: "Send selection to Scrap Heap";
    position: absolute;
    bottom: -30px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s ease, visibility 0.2s ease;
    pointer-events: none;
    z-index: 1000;
}

#trapdoor-btn:hover::after {
    opacity: 1;
    visibility: visible;
}

/* Disable button when no text is selected */
#trapdoor-btn.disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Active/pressed state */
#trapdoor-btn:active {
    transform: translateY(1px);
}

/* Theme-specific styles */
.columbia-theme #trapdoor-btn:hover {
    background-color: rgba(0, 51, 115, 0.1);
}

.purdue-theme #trapdoor-btn:hover {
    background-color: rgba(207, 185, 145, 0.1);
}

/* Audience Perspective Mode Styles */
.audience-mode {
    position: relative;
}

/* Highlight styles for different personas */
.audience-highlight {
    display: inline;
    position: relative;
    border-radius: 2px;
    transition: background-color 0.2s ease;
}

/* Expert reader - Purple */
.expert-highlight {
    background-color: rgba(155, 89, 182, 0.15);
    border-bottom: 2px solid #9b59b6;
}

.expert-highlight:hover {
    background-color: rgba(155, 89, 182, 0.25);
}

/* Novice reader - Blue */
.novice-highlight {
    background-color: rgba(52, 152, 219, 0.15);
    border-bottom: 2px solid #3498db;
}

.novice-highlight:hover {
    background-color: rgba(52, 152, 219, 0.25);
}

/* Skeptical reader - Orange */
.skeptical-highlight {
    background-color: rgba(230, 126, 34, 0.15);
    border-bottom: 2px solid #e67e22;
}

.skeptical-highlight:hover {
    background-color: rgba(230, 126, 34, 0.25);
}

/* Time-constrained reader - Green */
.timeconstrained-highlight {
    background-color: rgba(46, 204, 113, 0.15);
    border-bottom: 2px solid #2ecc71;
}

.timeconstrained-highlight:hover {
    background-color: rgba(46, 204, 113, 0.25);
}

/* Generous reader - Gold */
.generous-highlight {
    background-color: rgba(241, 196, 15, 0.15);
    border-bottom: 2px solid #f1c40f;
}

.generous-highlight:hover {
    background-color: rgba(241, 196, 15, 0.25);
}


/* Greening Mode Styles */

/* Editor in greening mode */
.greening-mode {
    position: relative;
    user-select: text;
    cursor: crosshair;
}

/* Selected text for deletion */
.greening-selected {
    background-color: rgba(76, 175, 80, 0.25) !important;
    border-bottom: 2px solid #4caf50 !important;
    border-radius: 2px;
    cursor: pointer !important;
    transition: all 0.2s ease;
    display: inline;
    position: relative;
}

.greening-selected:hover {
    background-color: rgba(76, 175, 80, 0.4) !important;
    box-shadow: 0 0 0 1px #4caf50;
}

/* Selected text with click hint */
.greening-selected::after {
    content: "✕";
    position: absolute;
    top: -8px;
    right: -8px;
    background-color: #f44336;
    color: white;
    border-radius: 50%;
    width: 16px;
    height: 16px;
    font-size: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.2s ease;
    pointer-events: none;
    z-index: 100;
}

.greening-selected:hover::after {
    opacity: 1;
}

/* Progress container styling */
.greening-progress-container {
    background-color: rgba(76, 175, 80, 0.05);
    border-radius: 8px;
    padding: 8px 12px;
    margin: 0 10px;
}

.greening-progress {
    transition: all 0.3s ease;
    white-space: nowrap;
}

/* Goal modal specific styling */
#greening-goal-modal .form-group label {
    cursor: pointer;
}

#greening-goal-modal input[type="radio"] {
    cursor: pointer;
}

#greening-goal-modal input[type="number"] {
    padding: 4px 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
}

/* Greening mode instructions */
.greening-instructions {
    background-color: #e8f5e8;
    border-left: 4px solid #4caf50;
    padding: 12px 16px;
    margin-bottom: 15px;
    border-radius: 0 4px 4px 0;
}

.greening-instructions h4 {
    color: #2e7d32;
    margin-bottom: 8px;
}

.greening-instructions p {
    color: #1b5e20;
    margin: 0;
    font-size: 0.9rem;
    line-height: 1.4;
}

/* Theme-specific adjustments */
.columbia-theme .greening-selected {
    border-bottom-color: #006699 !important;
}

.columbia-theme .greening-selected:hover {
    box-shadow: 0 0 0 1px #006699;
}

.columbia-theme .greening-progress-container {
    background-color: rgba(0, 102, 153, 0.05);
}

.purdue-theme .greening-selected {
    border-bottom-color: #daaa00 !important;
}

.purdue-theme .greening-selected:hover {
    box-shadow: 0 0 0 1px #daaa00;
}

.purdue-theme .greening-progress-container {
    background-color: rgba(218, 170, 0, 0.05);
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .greening-progress-container {
        flex-direction: column;
        gap: 8px;
        text-align: center;
    }
    
    .greening-selected::after {
        display: none; /* Hide close buttons on mobile for touch friendliness */
    }
    
    #greening-goal-modal .modal-content {
        width: 95%;
        margin: 20px;
    }
}

/* Animation for goal completion */
@keyframes greeningGoalComplete {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

.greening-progress.goal-complete {
    animation: greeningGoalComplete 0.5s ease;
}

/* Annotation interface */
.audience-annotation-container {
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
    width: 400px;
    max-width: 90vw;
    z-index: 1010;
    overflow: hidden;
}

.audience-annotation-header {
    padding: 10px 15px;
    background-color: #f4f4f4;
    border-bottom: 1px solid #ddd;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

#audience-annotation-title {
    font-weight: 600;
    color: #333;
}

.audience-close-btn {
    background: none;
    border: none;
    color: #666;
    cursor: pointer;
    font-size: 16px;
}

.audience-close-btn:hover {
    color: #333;
}

.audience-annotation-personas {
    display: flex;
    flex-wrap: wrap;
    padding: 10px;
    border-bottom: 1px solid #ddd;
    gap: 5px;
}

.audience-persona-selector {
    padding: 5px 10px;
    border-radius: 15px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 5px;
}

.audience-persona-selector i {
    font-size: 12px;
}

.audience-persona-selector.active {
    font-weight: 600;
}

/* Persona-specific styles */
.expert-persona {
    color: #9b59b6;
    background-color: rgba(155, 89, 182, 0.1);
}

.expert-persona.active {
    background-color: rgba(155, 89, 182, 0.2);
    box-shadow: 0 0 0 1px #9b59b6;
}

.novice-persona {
    color: #3498db;
    background-color: rgba(52, 152, 219, 0.1);
}

.novice-persona.active {
    background-color: rgba(52, 152, 219, 0.2);
    box-shadow: 0 0 0 1px #3498db;
}

.skeptical-persona {
    color: #e67e22;
    background-color: rgba(230, 126, 34, 0.1);
}

.skeptical-persona.active {
    background-color: rgba(230, 126, 34, 0.2);
    box-shadow: 0 0 0 1px #e67e22;
}

.timeconstrained-persona {
    color: #2ecc71;
    background-color: rgba(46, 204, 113, 0.1);
}

.timeconstrained-persona.active {
    background-color: rgba(46, 204, 113, 0.2);
    box-shadow: 0 0 0 1px #2ecc71;
}

.generous-persona {
    color: #f1c40f;
    background-color: rgba(241, 196, 15, 0.1);
}

.generous-persona.active {
    background-color: rgba(241, 196, 15, 0.2);
    box-shadow: 0 0 0 1px #f1c40f;
}

#audience-annotation-content {
    width: 100%;
    min-height: 100px;
    padding: 10px;
    border: none;
    border-bottom: 1px solid #ddd;
    resize: vertical;
    font-family: 'Open Sans', sans-serif;
    font-size: 14px;
}

#audience-annotation-content:focus {
    outline: none;
    border-color: #aaa;
}

.audience-annotation-footer {
    padding: 10px;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

.audience-annotation-footer button {
    padding: 8px 15px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
}

#audience-annotation-cancel {
    background-color: #f4f4f4;
    border: 1px solid #ddd;
    color: #333;
}

#audience-annotation-cancel:hover {
    background-color: #e4e4e4;
}

#audience-annotation-save {
    background-color: var(--primary-color, #57068c);
    border: none;
    color: white;
}

#audience-annotation-save:hover {
    background-color: var(--primary-color-dark, #400667);
}

/* Annotation comments */
.audience-annotation-popup {
    position: absolute;
    margin: 8px 0;
    border-radius: 8px;
    box-shadow: 0 3px 15px rgba(0, 0, 0, 0.2);
    width: 300px;
    max-width: 90vw;
    font-size: 14px;
    overflow: hidden;
    z-index: 1500;
    background-color: white;
    animation: fadeIn 0.2s ease;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-5px); }
    to { opacity: 1; transform: translateY(0); }
}

.audience-annotation-header {
    padding: 8px 10px;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 13px;
}

.audience-popup-actions {
    margin-left: auto;
    display: flex;
    gap: 5px;
}

.audience-popup-close,
.audience-annotation-edit,
.audience-annotation-delete {
    background: none;
    border: none;
    color: #999;
    cursor: pointer;
    padding: 0;
    font-size: 12px;
    width: 22px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
}

.audience-popup-close:hover,
.audience-annotation-edit:hover {
    background-color: rgba(0, 0, 0, 0.05);
    color: #666;
}

.audience-annotation-delete:hover {
    background-color: rgba(244, 67, 54, 0.1);
    color: #f44336;
}

.expert-annotation .audience-annotation-header {
    background-color: rgba(155, 89, 182, 0.1);
    color: #9b59b6;
}

.novice-annotation .audience-annotation-header {
    background-color: rgba(52, 152, 219, 0.1);
    color: #3498db;
}

.skeptical-annotation .audience-annotation-header {
    background-color: rgba(230, 126, 34, 0.1);
    color: #e67e22;
}

.timeconstrained-annotation .audience-annotation-header {
    background-color: rgba(46, 204, 113, 0.1);
    color: #2ecc71;
}

.generous-annotation .audience-annotation-header {
    background-color: rgba(241, 196, 15, 0.1);
    color: #f1c40f;
}

.audience-annotation-content {
    padding: 10px;
    background-color: white;
}

/* Persona guidance panel */
.audience-guidance-header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 15px;
    font-weight: 500;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.audience-guidance-prompts {
    padding: 10px 15px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
}

.audience-prompt {
    background-color: #f9f9f9;
    border-radius: 6px;
    padding: 8px 12px;
    font-size: 13px;
    color: #333;
    flex-basis: calc(50% - 5px);
}

.toolbar-guidance {
    background-color: #f9f9f9;
    border-radius: 6px;
    margin: 0 20px;
    margin-bottom: 10px;
    overflow: visible !important;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* Toolbar selector */
.toolbar-selector {
    padding: 6px 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-family: 'Open Sans', sans-serif;
    font-size: 14px;
    background-color: white;
    color: #333;
}

.toolbar-selector:focus {
    outline: none;
    border-color: var(--primary-color, #57068c);
    box-shadow: 0 0 0 2px rgba(87, 6, 140, 0.1);
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .audience-annotation-personas {
        flex-direction: column;
    }
    
    .audience-prompt {
        flex-basis: 100%;
    }
    
    .audience-annotation {
        max-width: 100%;
    }
}

/* Source Synthesis Mode Styles */
#source-synthesis-panel .modal-content {
    max-width: 700px;
}

#source-synthesis-panel .modal-body {
    padding-bottom: 20px;
}

#source-list {
    max-height: 300px;
    overflow-y: auto;
    margin: 15px 0;
    padding-right: 5px;
}

.source-row {
    display: flex;
    align-items: flex-start;
    margin-bottom: 15px;
    gap: 10px;
    padding: 10px;
    border: 1px solid #eee;
    border-radius: 6px;
    background-color: #fafafa;
}

.source-row .source-name-input {
    width: 200px;
    font-weight: 600;
}

.source-row .source-terms-input {
    flex-grow: 1;
}

.source-row input[type="color"] {
    width: 40px;
    height: 40px;
}

.source-synthesis-instructions {
    background-color: #f9f4ff;
    border-left: 3px solid #57068c;
    padding: 10px 15px;
    margin-bottom: 15px;
    font-size: 0.9rem;
    color: #333;
}

.source-synthesis-instructions code {
    background-color: #eee;
    padding: 2px 4px;
    border-radius: 3px;
    font-family: monospace;
}

.source-highlight {
    display: inline;
    position: relative;
    border-radius: 2px;
    transition: background-color 0.2s ease;
    box-decoration-break: clone;
    -webkit-box-decoration-break: clone;
}

/* Multi-source highlighting - when text contains multiple sources */
.multi-source-highlight {
    background: linear-gradient(45deg, var(--source-color-1) 25%, var(--source-color-2) 25%, var(--source-color-2) 50%, var(--source-color-1) 50%, var(--source-color-1) 75%, var(--source-color-2) 75%);
    background-size: 8px 8px;
    border: 1px solid rgba(0,0,0,0.2);
}

/* Columbia theme adjustments */
.columbia-theme .expert-persona,
.columbia-theme .expert-highlight,
.columbia-theme .expert-annotation .audience-annotation-header {
    color: #006699;
    border-color: #006699;
    background-color: rgba(0, 102, 153, 0.1);
}

.columbia-theme .expert-persona.active {
    background-color: rgba(0, 102, 153, 0.2);
    box-shadow: 0 0 0 1px #006699;
}

.columbia-theme #audience-annotation-save {
    background-color: #003373;
}

.columbia-theme #audience-annotation-save:hover {
    background-color: #002255;
}

/* Purdue theme adjustments */
.purdue-theme .expert-persona,
.purdue-theme .expert-highlight,
.purdue-theme .expert-annotation .audience-annotation-header {
    color: #daaa00;
    border-color: #daaa00;
    background-color: rgba(218, 170, 0, 0.1);
}

.purdue-theme .expert-persona.active {
    background-color: rgba(218, 170, 0, 0.2);
    box-shadow: 0 0 0 1px #daaa00;
}

.purdue-theme #audience-annotation-save {
    background-color: #cfb991;
    color: #000;
}

.purdue-theme #audience-annotation-save:hover {
    background-color: #ddb945;
}

/* Pomodoro Mode Styles */

/* Subtasks list styling */
.pomodoro-subtasks {
    margin-left: 24px;
    list-style: none;
    padding: 0;
    border-left: 1px solid #e5e5e5;
    margin-top: 5px;
    margin-bottom: 5px;
}

/* Subtask items */
.pomodoro-subtasks .pomodoro-task-item {
    margin-bottom: 4px;
    padding-left: 15px;
}

.pomodoro-subtasks .pomodoro-task-content {
    border-radius: 4px;
    background-color: #f9f9f9;
}

/* Subtask icons and controls */
.pomodoro-task-add-subtask {
    color: #57068c;
}

.pomodoro-task-add-subtask:hover {
    background-color: rgba(87, 6, 140, 0.1);
    color: #57068c;
}

.pomodoro-subtasks .pomodoro-task-controls {
    /* Make subtask controls smaller */
    gap: 3px;
}

.pomodoro-subtasks .pomodoro-task-btn {
    font-size: 11px;
    width: 22px;
    height: 22px;
}

/* Add a visual indicator to indicate it's a subtask */
.pomodoro-subtasks .pomodoro-task-content:before {
    content: '⤷';
    color: #aaa;
    position: absolute;
    left: 5px;
    font-size: 12px;
}

/* Theme-specific colors */
.columbia-theme .pomodoro-task-add-subtask {
    color: #003373;
}

.columbia-theme .pomodoro-task-add-subtask:hover {
    background-color: rgba(0, 51, 115, 0.1);
    color: #003373;
}

.purdue-theme .pomodoro-task-add-subtask {
    color: #cfb991;
}

.purdue-theme .pomodoro-task-add-subtask:hover {
    background-color: rgba(207, 185, 145, 0.1);
    color: #cfb991;
}

/* Timer in toolbar */
.pomodoro-timer-container {
    display: flex;
    align-items: center;
    background-color: #f4f4f4;
    border-radius: 20px;
    padding: 4px 10px;
    margin-right: 15px;
    border: 1px solid #e0e0e0;
}

.pomodoro-timer {
    font-family: 'Open Sans', monospace;
    font-size: 16px;
    font-weight: 600;
    color: #333;
    margin: 0 10px;
    min-width: 70px;
    text-align: center;
}

.pomodoro-controls {
    display: flex;
    align-items: center;
    gap: 5px;
}

.pomodoro-btn {
    background: none;
    border: none;
    cursor: pointer;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.pomodoro-btn:hover {
    background-color: rgba(0, 0, 0, 0.05);
}

.pomodoro-session-indicator {
    font-size: 12px;
    color: #666;
    margin-left: 8px;
    min-width: 40px;
}

.pomodoro-progress {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 3px;
    background-color: var(--primary-color, #57068c);
    transition: width 1s linear;
}

/* Session type indicators */
.pomodoro-work .pomodoro-timer-container {
    border-color: #3498db;
}

.pomodoro-short-break .pomodoro-timer-container {
    border-color: #2ecc71;
}

.pomodoro-long-break .pomodoro-timer-container {
    border-color: #9b59b6;
}

.pomodoro-work .pomodoro-progress {
    background-color: #3498db;
}

.pomodoro-short-break .pomodoro-progress {
    background-color: #2ecc71;
}

.pomodoro-long-break .pomodoro-progress {
    background-color: #9b59b6;
}

/* For the popup container */
#pomodoro-task-popup {
    background-color: #fff;
    border-radius: 12px;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
    display: flex;
    flex-direction: column; /* Ensure vertical stacking */
    min-width: 350px;
    max-width: 90vw;
    min-height: 300px;
    max-height: 80vh;
    overflow: hidden;
    resize: both;
}

/* For the header */
.pomodoro-popup-header {
    display: flex;
    flex-direction: row; /* Ensure horizontal alignment */
    justify-content: space-between;
    align-items: center;
    width: 100%; /* Take full width */
    padding: 15px 20px;
    border-bottom: 1px solid #e6e6e6;
    background-color: #f8f8fa;
}

.pomodoro-popup-title {
    font-family: 'Playfair Display', serif;
    color: var(--primary-color, #57068c);
    font-size: 18px;
    margin: 0;
    font-weight: 600;
}

.pomodoro-popup-controls {
    display: flex;
    gap: 8px;
}

.pomodoro-popup-btn {
    background: none;
    border: none;
    font-size: 16px;
    color: #666;
    cursor: pointer;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s ease;
}

.pomodoro-popup-btn:hover {
    background-color: rgba(0, 0, 0, 0.05);
    color: #333;
}

/* For the content area */
.pomodoro-popup-content {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    width: 100%; /* Take full width */
}

/* For the footer */
.pomodoro-popup-footer {
    display: flex;
    flex-direction: row; /* Ensure horizontal alignment */
    justify-content: space-between;
    align-items: center;
    width: 100%; /* Take full width */
    padding: 10px 15px;
    border-top: 1px solid #e0e0e0;
    background-color: #f9f9f9;
}

/* Task list styles */
.pomodoro-task-list {
    margin: 0;
    padding: 0;
    list-style: none;
}

.pomodoro-task-item {
    margin-bottom: 8px;
    position: relative;
}

.pomodoro-task-content {
    display: flex;
    align-items: center;
    padding: 5px 5px 5px 0;
    border-radius: 4px;
    transition: background-color 0.2s ease;
}

.pomodoro-task-content:hover {
    background-color: #f9f9f9;
}

.pomodoro-task-checkbox {
    margin-right: 8px;
}

.pomodoro-task-text {
    flex: 1;
    white-space: normal;
    word-break: break-word;
}

.pomodoro-task-completed .pomodoro-task-text {
    text-decoration: line-through;
    color: #999;
}

.pomodoro-task-controls {
    display: flex;
    gap: 5px;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.pomodoro-task-content:hover .pomodoro-task-controls {
    opacity: 1;
}

.pomodoro-task-btn {
    background: none;
    border: none;
    cursor: pointer;
    width: 24px;
    height: 24px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    font-size: 12px;
    color: #666;
}

.pomodoro-task-btn:hover {
    background-color: rgba(0, 0, 0, 0.05);
    color: #333;
}

.pomodoro-task-delete:hover {
    background-color: rgba(244, 67, 54, 0.1);
    color: #f44336;
}

/* Nesting Styles - supports unlimited nesting */
.pomodoro-subtasks {
    margin-left: 20px;
    list-style: none;
    padding: 0;
    padding-left: 15px;
    border-left: 1px dashed #dfdfdf;
    margin-top: 5px;
    margin-bottom: 5px;
    position: relative;
}

/* Create connection lines for every level of nesting */
.pomodoro-subtasks:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    height: 16px;
    width: 10px;
    border-bottom: 1px dashed #dfdfdf;
}

.pomodoro-task-add {
    background-color: var(--primary-color, #57068c);
    color: white;
    border: none;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    margin-left: 10px;
}

.pomodoro-task-add:hover {
    background-color: var(--primary-color-dark, #400667);
    transform: scale(1.05);
}

.pomodoro-task-add-area {
    margin-top: 15px;
    background-color: #f8f8fa;
    border-radius: 8px;
    padding: 12px 15px;
    display: flex;
    align-items: center;
    border: 1px dashed #dfdfdf;
    transition: all 0.2s ease;
}

.pomodoro-task-add-area:focus-within {
    border-color: var(--primary-color, #57068c);
    box-shadow: 0 0 0 3px rgba(87, 6, 140, 0.1);
}

.pomodoro-task-add-input {
    flex: 1;
    border: none;
    background-color: transparent;
    padding: 8px 10px;
    font-size: 14px;
    font-family: 'Open Sans', sans-serif;
    color: #333;
}

.pomodoro-task-add-input:focus {
    outline: none;
}

.pomodoro-task-stats {
    font-size: 14px;
    color: #666;
}

/* Nested Task Styling with Unlimited Depth */
.pomodoro-task-item {
    padding: 6px 0;
    margin-bottom: 8px;
    position: relative;
    transition: all 0.2s ease;
}

.pomodoro-task-content {
    padding: 10px 12px;
    background-color: #f8f8fa;
    border-radius: 8px;
    display: flex;
    align-items: center;
    transition: all 0.2s ease;
    position: relative;
}


.pomodoro-toggle-expand {
    margin-right: 5px;
    font-size: 10px;
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 2px;
    color: #666;
    transform: rotate(0deg);
    transition: transform 0.2s ease;
}

.pomodoro-collapsed .pomodoro-toggle-expand {
    transform: rotate(-90deg);
}

.pomodoro-collapsed .pomodoro-subtasks {
    display: none;
}

/* Nested level indicators */
.pomodoro-subtasks .pomodoro-task-content {
    background-color: #f8f8fa;
}

.pomodoro-subtasks .pomodoro-subtasks .pomodoro-task-content {
    background-color: #f6f6f8;
}

.pomodoro-subtasks .pomodoro-subtasks .pomodoro-subtasks .pomodoro-task-content {
    background-color: #f4f4f6;
}

.pomodoro-subtasks .pomodoro-subtasks .pomodoro-subtasks .pomodoro-subtasks .pomodoro-task-content {
    background-color: #f2f2f4;
}

/* Add subtask button at each level */
.pomodoro-subtask-add-area {
    margin-left: 35px;
    margin-top: 5px;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    opacity: 0;
    transition: all 0.2s ease;
    height: 0;
    overflow: hidden;
}

.pomodoro-task-item:hover > .pomodoro-subtask-add-area,
.pomodoro-subtasks:hover > .pomodoro-subtask-add-area {
    opacity: 1;
    height: auto;
}

.pomodoro-subtask-add-btn {
    background: none;
    border: none;
    font-size: 12px;
    color: var(--primary-color, #57068c);
    cursor: pointer;
    padding: 3px 8px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    gap: 4px;
    transition: all 0.2s ease;
}

.pomodoro-subtask-add-btn:hover {
    background-color: rgba(87, 6, 140, 0.1);
}

.pomodoro-task-item:hover > .pomodoro-task-content {
    background-color: #f4f4f6;
}

.pomodoro-task-checkbox {
    margin-right: 12px;
    width: 18px;
    height: 18px;
    cursor: pointer;
    accent-color: var(--primary-color, #57068c);
}

.pomodoro-task-text {
    flex: 1;
    font-size: 14px;
    color: #333;
    word-break: break-word;
    padding-right: 10px;
}

.pomodoro-task-completed .pomodoro-task-text {
    text-decoration: line-through;
    color: #999;
}

.pomodoro-task-controls {
    opacity: 0.4;
    display: flex;
    gap: 8px;
    transition: opacity 0.2s ease;
}

.pomodoro-task-content:hover .pomodoro-task-controls {
    opacity: 1;
}

.pomodoro-task-btn {
    background: none;
    border: none;
    color: #666;
    cursor: pointer;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: all 0.2s ease;
    padding: 0;
}

.pomodoro-task-btn:hover {
    background-color: rgba(0, 0, 0, 0.05);
    color: #333;
}

.pomodoro-task-delete:hover {
    background-color: rgba(244, 67, 54, 0.1);
    color: #f44336;
}

.pomodoro-task-edit:hover {
    background-color: rgba(33, 150, 243, 0.1);
    color: #2196f3;
}

.pomodoro-task-add-subtask:hover {
    background-color: rgba(87, 6, 140, 0.1);
    color: var(--primary-color, #57068c);
}

/* Settings Popup */
#pomodoro-settings-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 400px;
    max-width: 90vw;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
    z-index: 1600;
}

.pomodoro-setting-group {
    margin-bottom: 15px;
}

.pomodoro-setting-label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.pomodoro-setting-value {
    font-size: 14px;
    color: #666;
    min-width: 40px;
    text-align: right;
}

.pomodoro-range {
    width: 100%;
}

.pomodoro-setting-radio {
    margin-bottom: 8px;
}

.pomodoro-setting-radio label {
    margin-left: 5px;
}

.pomodoro-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 1400;
}

.pomodoro-dragging {
    opacity: 0.8;
    user-select: none;
}

/* No tasks placeholder */
.pomodoro-no-tasks {
    text-align: center;
    padding: 30px 20px;
    color: #999;
    font-style: italic;
}

/* Notification banner */
.pomodoro-notification {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 15px 20px;
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    z-index: 2000;
    display: flex;
    align-items: center;
    animation: slideIn 0.3s ease forwards;
    max-width: 300px;
}

.pomodoro-notification-icon {
    font-size: 20px;
    margin-right: 15px;
}

.pomodoro-notification-work .pomodoro-notification-icon {
    color: #3498db;
}

.pomodoro-notification-short-break .pomodoro-notification-icon {
    color: #2ecc71;
}

.pomodoro-notification-long-break .pomodoro-notification-icon {
    color: #9b59b6;
}

.pomodoro-notification-content {
    flex: 1;
}

.pomodoro-notification-title {
    font-weight: 600;
    margin-bottom: 5px;
}

.pomodoro-notification-message {
    font-size: 14px;
    color: #666;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

/* Word Cloud Mode Styles */
.word-cloud-modal-backdrop {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
}

.word-cloud-modal {
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    width: 90%;
    max-width: 1000px;
    height: 90vh;
    max-height: 800px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.word-cloud-modal-header {
    padding: 15px 20px;
    border-bottom: 2px solid #f4ebfa;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.word-cloud-modal-header h3 {
    color: #57068c;
    margin: 0;
    font-size: 1.4rem;
}

.word-cloud-modal-close {
    background: none;
    border: none;
    font-size: 1.8rem;
    color: #666;
    cursor: pointer;
}

.word-cloud-modal-close:hover {
    color: #333;
}

.word-cloud-content {
    flex: 1;
    display: flex;
    overflow: hidden;
}

.word-cloud-sidebar {
    width: 250px;
    padding: 20px;
    border-right: 1px solid #eee;
    background-color: #f9f9f9;
    overflow-y: auto;
}

.word-cloud-main {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    background-color: white;
}

.word-cloud-canvas {
    border: 1px solid #ddd;
    border-radius: 8px;
    max-width: 100%;
    max-height: 100%;
}

.word-cloud-settings {
    margin-bottom: 20px;
}

.word-cloud-settings h4 {
    color: #57068c;
    margin-bottom: 10px;
    font-size: 1rem;
}

.word-cloud-setting {
    margin-bottom: 15px;
}

.word-cloud-setting label {
    display: block;
    margin-bottom: 5px;
    font-weight: 500;
    font-size: 0.9rem;
}

.word-cloud-setting input,
.word-cloud-setting select {
    width: 100%;
    padding: 6px 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 0.9rem;
}

.word-cloud-setting input[type="range"] {
    width: 100%;
}

.word-cloud-setting input[type="color"] {
    width: 50px;
    height: 30px;
    padding: 0;
    border: 1px solid #ddd;
    border-radius: 4px;
}

.range-display {
    font-size: 0.8rem;
    color: #666;
    margin-top: 2px;
}

.word-cloud-buttons {
    margin-top: 20px;
}

.word-cloud-btn {
    width: 100%;
    padding: 8px 12px;
    margin-bottom: 8px;
    background-color: #57068c;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s ease;
}

.word-cloud-btn:hover {
    background-color: #400667;
}

.word-cloud-btn.secondary {
    background-color: #f4ebfa;
    color: #57068c;
    border: 1px solid #57068c;
}

.word-cloud-btn.secondary:hover {
    background-color: #e0d0eb;
}

.word-cloud-stats {
    margin-top: 20px;
    padding: 10px;
    background-color: white;
    border-radius: 4px;
    border: 1px solid #ddd;
}

.word-cloud-stats h4 {
    margin-top: 0;
    margin-bottom: 8px;
    color: #57068c;
}

.word-cloud-stats p {
    margin: 4px 0;
    font-size: 0.85rem;
    color: #666;
}

/* Theme support */
.columbia-theme .word-cloud-modal-header h3,
.columbia-theme .word-cloud-settings h4,
.columbia-theme .word-cloud-stats h4 {
    color: #003373;
}

.columbia-theme .word-cloud-btn {
    background-color: #003373;
}

.columbia-theme .word-cloud-btn:hover {
    background-color: #002255;
}

.columbia-theme .word-cloud-btn.secondary {
    color: #003373;
    border-color: #003373;
}

.purdue-theme .word-cloud-modal-header h3,
.purdue-theme .word-cloud-settings h4,
.purdue-theme .word-cloud-stats h4 {
    color: #cfb991;
}

.purdue-theme .word-cloud-btn {
    background-color: #cfb991;
    color: #000;
}

.purdue-theme .word-cloud-btn:hover {
    background-color: #ddb945;
}

.purdue-theme .word-cloud-btn.secondary {
    color: #cfb991;
    border-color: #cfb991;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .word-cloud-content {
        flex-direction: column;
    }
    
    .word-cloud-sidebar {
        width: 100%;
        max-height: 200px;
    }
}

/* Theme compatibility */
.columbia-theme .pomodoro-work .pomodoro-progress,
.columbia-theme .pomodoro-work .pomodoro-timer-container {
    border-color: #006699;
}

.columbia-theme .pomodoro-work .pomodoro-progress {
    background-color: #006699;
}

/* Theme-specific colors */
.columbia-theme .pomodoro-popup-title,
.columbia-theme .pomodoro-task-add-subtask,
.columbia-theme .pomodoro-subtask-add-btn {
    color: #003373;
}

.purdue-theme .pomodoro-work .pomodoro-progress,
.purdue-theme .pomodoro-work .pomodoro-timer-container {
    border-color: #daaa00;
}

.purdue-theme .pomodoro-work .pomodoro-progress {
    background-color: #daaa00;
}

.columbia-theme .pomodoro-task-add {
    background-color: #003373;
}

.columbia-theme .pomodoro-task-add:hover {
    background-color: #002255;
}

.columbia-theme .pomodoro-task-checkbox {
    accent-color: #003373;
}

.purdue-theme .pomodoro-popup-title,
.purdue-theme .pomodoro-task-add-subtask,
.purdue-theme .pomodoro-subtask-add-btn {
    color: #cfb991;
}

.purdue-theme .pomodoro-task-add {
    background-color: #cfb991;
}

.purdue-theme .pomodoro-task-add:hover {
    background-color: #ddb945;
}

.purdue-theme .pomodoro-task-checkbox {
    accent-color: #cfb991;
}

/* Task item animations */
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.pomodoro-task-item {
    animation: fadeIn 0.3s ease forwards;
}

/* Adjust size based on content */
#pomodoro-task-popup {
    transition: height 0.3s ease, width 0.3s ease;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .pomodoro-timer-container {
        padding: 3px 8px;
    }
    
    .pomodoro-timer {
        font-size: 14px;
        min-width: 60px;
    }
    
    #pomodoro-task-popup {
        top: 70px;
        right: 10px;
        max-width: calc(100vw - 20px);
        max-height: calc(100vh - 80px);
    }
}

.pomodoro-popup-footer {
    padding: 15px 20px;
    background-color: #f8f8fa;
    border-top: 1px solid #e6e6e6;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

/* Add this CSS to your existing styles */

/* Infrared Mode Styles */
.infrared-highlight {
    display: inline;
    position: relative;
    border-radius: 3px;
    font-weight: 500;
    cursor: help;
    transition: all 0.2s ease;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    text-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
}

.infrared-highlight:hover {
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    z-index: 10;
    position: relative;
}

/* Stats container styling */
.infrared-stats-container {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
}

.infrared-description {
    font-style: italic;
    line-height: 1.3;
}

/* Pattern selector styling */
#infrared-pattern-select {
    max-width: 200px;
    margin-right: 10px;
}

/* Responsive adjustments for infrared mode */
@media (max-width: 768px) {
    .infrared-stats-container {
        margin-left: 0;
        margin-top: 10px;
        width: 100%;
    }
    
    .infrared-description {
        font-size: 0.8rem;
    }
}

/* Theme-specific infrared colors */
.columbia-theme .infrared-highlight {
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

.purdue-theme .infrared-highlight {
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}

/* Animation for newly highlighted elements */
@keyframes infraredGlow {
    0% { 
        box-shadow: 0 0 0 rgba(139, 0, 0, 0.6); 
    }
    50% { 
        box-shadow: 0 0 10px rgba(139, 0, 0, 0.8); 
    }
    100% { 
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); 
    }
}

.infrared-highlight.newly-highlighted {
    animation: infraredGlow 1s ease-out;
}

/* Print styles - remove highlighting for printing */
@media print {
    .infrared-highlight {
        background-color: transparent !important;
        color: inherit !important;
        box-shadow: none !important;
    }
}

    </style>

<body>
    <header class="fixed-header" role="banner">
        <div class="logo">
            <a href="#" title="Home" aria-label="NYU Writing Center Home">
                <img src="https://i.imgur.com/iIODsNl.png" alt="NYU Logo" />        
            </a>
        </div>
        <div class="header-title" id="app-title">writing-center.org</div>
        <div class="header-right">
           
            <button id="new-document-btn" class="action-btn primary" aria-label="Create new document">
                <i class="fas fa-plus" aria-hidden="true"></i> New Document
            </button>
        
            <button id="report-bug-btn" class="action-btn" aria-label="Report a bug">
                <i class="fas fa-bug" aria-hidden="true"></i> Report Bug
            </button>

            <button id="reset-app-btn" class="action-btn" aria-label="Reset application data">
                <i class="fas fa-trash-alt"></i> Reset App
            </button>


            <button id="user-profile-btn" class="action-btn" aria-label="Open user account settings">
                <i class="fas fa-user" aria-hidden="true"></i> My Account
            </button>
        </div>
    </header>

    <main>
        <!-- Trigger area at the very left edge -->
        <div class="sidebar-trigger" role="button" aria-label="Toggle document list sidebar" tabindex="0"></div>

        <!-- Sidebar with fixed position to overlay -->
        <div class="sidebar" id="documents-sidebar" role="navigation" aria-label="Document list">
            <div class="sidebar-header">
                <h3>My Documents</h3>
            </div>
            <ul class="document-list" id="document-list" aria-labelledby="sidebar-heading">
                <!-- Document list will be populated dynamically -->
            </ul>
        </div>

        <!-- Platform container shifted right -->
        <div class="platform-container" role="main" aria-labelledby="document-title">
            <!-- The editor container now takes full width of platform -->
            <div class="editor-container">
                <!-- Toolbar -->
                <div class="editor-toolbar" role="toolbar" aria-label="Formatting tools">
                    <div class="toolbar-title" id="document-title">Untitled Document</div>
                    
                    <div class="toolbar-group" role="group" aria-label="Text formatting">
                        <button class="toolbar-btn" title="Bold" onclick="formatText('bold')" aria-label="Bold">
                            <i class="fas fa-bold" aria-hidden="true"></i>
                        </button>
                        <button class="toolbar-btn" title="Italic" onclick="formatText('italic')" aria-label="Italic">
                            <i class="fas fa-italic" aria-hidden="true"></i>
                        </button>
                        <button class="toolbar-btn" title="Underline" onclick="formatText('underline')" aria-label="Underline">
                            <i class="fas fa-underline" aria-hidden="true"></i>
                        </button>
                    </div>
                    
                    <div class="toolbar-separator" aria-hidden="true"></div>
                    
                    <div class="toolbar-group" role="group" aria-label="Headings">
                        <button class="toolbar-btn" title="Heading 1" onclick="formatText('h1')" aria-label="Heading 1">H1</button>
                        <button class="toolbar-btn" title="Heading 2" onclick="formatText('h2')" aria-label="Heading 2">H2</button>
                        <button class="toolbar-btn" title="Heading 3" onclick="formatText('h3')" aria-label="Heading 3">H3</button>
                    </div>
                    
                    <div class="toolbar-separator" aria-hidden="true"></div>
                    
                    <div class="toolbar-group" role="group" aria-label="Document actions">
                        <button class="toolbar-btn" title="Save" onclick="DocumentManager.saveDocument()" aria-label="Save document">
                            <i class="fas fa-save" aria-hidden="true"></i> Save
                        </button>
                        <button class="toolbar-btn" title="Download" onclick="downloadDocument()" aria-label="Download document">
                            <i class="fas fa-download" aria-hidden="true"></i>
                        </button>

                       
                    </div>
                    
                    <div class="toolbar-separator" aria-hidden="true"></div>

                    <button class="toolbar-btn" id="trapdoor-btn" title="Move selected text to Scrapheap" aria-label="Move selected text to Scrapheap">
                        <i class="fas fa-trash-restore-alt"></i>
                    </button>

                    <!-- Modes toggle button with ARIA support -->
                    <div class="modes-toggle-section">
                        <button id="modes-toggle-btn" class="modes-toggle-btn" title="Open Writing Modes Panel" aria-label="Open writing modes panel" aria-expanded="false" aria-controls="modes-panel">
                            <i class="fas fa-layer-group" aria-hidden="true"></i> Modes
                        </button>
                    </div>
                </div>
                
                 <!-- Second toolbar row with ARIA support -->
                <div class="editor-toolbar-modes" role="region" aria-label="Active mode controls">
                    <div id="active-mode-indicator" class="active-mode-indicator" aria-live="polite">
                        <span id="active-mode-name">No mode active</span>
                        
                        <!-- Options container for mode-specific controls -->
                        <div id="active-mode-options" class="active-mode-options" role="group" aria-label="Mode options">
                            <!-- Will be populated dynamically based on active mode -->
                        </div>
                        
                        <button id="disable-mode-btn" class="disable-mode-btn" aria-label="Disable current mode">
                            <i class="fas fa-times" aria-hidden="true"></i>
                        </button>
                    </div>
                </div>
                
                <div class="editor-content">
                    <div id="editor" contenteditable="true" role="textbox" aria-multiline="true" aria-label="Document content editor" placeholder="Start writing here..."></div>
                </div>
                
                <div class="status-bar" role="status" aria-live="polite">
                    <div id="word-count">Words: 0</div>
                    <div id="last-saved">Last saved: Never</div>
                </div>
            </div>
        </div>
    </main>

    <footer class="site-footer" role="contentinfo">
        <p>&copy; 2025 Alexander Landfair | NYU Online Writing Platform | All Rights Reserved</p>
    </footer>

    <!-- New Document Modal with ARIA support -->
    <div class="modal" id="new-document-modal" role="dialog" aria-labelledby="new-doc-title-label" aria-hidden="true">
        <div class="modal-content" role="document">
            <div class="modal-header">
                <div id="new-doc-title-label" class="modal-title">Create New Document</div>
                <button class="modal-close" aria-label="Close modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="new-doc-title" class="form-label">Document Title</label>
                    <input type="text" id="new-doc-title" class="form-input" placeholder="Enter document title">
                </div>
                <div class="form-group">
                    <label for="new-doc-description" class="form-label">Description (optional)</label>
                    <textarea id="new-doc-description" class="form-input" rows="3" placeholder="Enter optional description"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="action-btn" id="cancel-new-doc">Cancel</button>
                <button class="action-btn primary" id="create-new-doc">Create</button>
            </div>
        </div>
    </div>

    <!-- User Profile Modal with ARIA support -->
        <div class="modal" id="user-profile-modal" role="dialog" aria-labelledby="user-profile-title" aria-hidden="true">
            <div class="modal-content" role="document">
                <div class="modal-header">
                    <div id="user-profile-title" class="modal-title">My Account</div>
                    <button class="modal-close" aria-label="Close modal">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="user-name" class="form-label">Name</label>
                        <input type="text" id="user-name" class="form-input" value="Jane Doe">
                    </div>
                    <div class="form-group">
                        <label for="user-email" class="form-label">Email</label>
                        <input type="email" id="user-email" class="form-input" value="jane.doe@nyu.edu">
                    </div>
                    <div class="form-group">
                        <label for="user-preferences" class="form-label">Preferences</label>
                        <select id="user-preferences" class="form-input">
                            <option value="default">Default Theme</option>
                            <option value="light">Light Theme</option>
                            <option value="dark">Dark Theme</option>
                        </select>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="action-btn" id="cancel-profile">Cancel</button>
                    <button class="action-btn primary" id="save-profile">Save Changes</button>
                </div>
            </div>
        </div>

    <!-- Notification with ARIA support -->
    <div class="notification" id="notification" role="alert" aria-live="assertive">
        <i class="fas fa-check-circle" aria-hidden="true"></i>
        <span id="notification-message">Document saved successfully!</span>
    </div>

    <!-- Modes panel with reorganized categories -->
<div id="modes-panel" class="modes-panel" role="dialog" aria-labelledby="modes-panel-title" aria-hidden="true">
    <div class="modes-panel-header">
        <h3 id="modes-panel-title">Writing Modes</h3>
        <button id="close-modes-panel" class="close-panel-btn" aria-label="Close modes panel">
            <i class="fas fa-times" aria-hidden="true"></i>
        </button>
    </div>
    <div class="modes-panel-body">
        <!-- Organization category -->
        <div class="modes-category">
            <h4 id="organization-modes-heading">Organization & Structure</h4>
            <div class="modes-list" role="list" aria-labelledby="organization-modes-heading">
                <!-- Textris Mode -->
                <div class="mode-card" data-mode="textris" role="listitem">
                    <div class="mode-card-header">
                        <i class="fas fa-grip-lines" aria-hidden="true"></i>
                        <h5>Textris Mode</h5>
                    </div>
                    <p class="mode-description">Rearrange paragraphs and sentences by dragging them.</p>
                    <div class="mode-options">
                        <select id="textris-panel-select" class="mode-select" aria-label="Textris mode level">
                            <option value="paragraph">Paragraphs</option>
                            <option value="sentence">Sentences</option>
                        </select>
                        <button class="activate-mode-btn" aria-label="Activate Textris mode">Activate</button>
                    </div>
                </div>

                <div class="mode-card" data-mode="sourceSynthesis" role="listitem">
                    <div class="mode-card-header">
                        <i class="fas fa-layer-group" aria-hidden="true"></i>
                        <h5>Source Synthesis Mode</h5>
                    </div>
                    <p class="mode-description">Track how your sources interact throughout your document. Identify whether you're reporting sources individually or creating rich conversations between them.</p>
                    <div class="mode-options">
                        <button class="activate-mode-btn" aria-label="Activate Source Synthesis mode">Activate</button>
                    </div>
                </div>

                <!-- Fire Mode -->
                <div class="mode-card" data-mode="fire" role="listitem">
                    <div class="mode-card-header">
                        <i class="fas fa-fire" aria-hidden="true"></i>
                        <h5>Fire Mode</h5>
                    </div>
                    <p class="mode-description">Identify and position your most important sentences for maximum impact.</p>
                    <div class="mode-options">
                        <button class="activate-mode-btn" aria-label="Activate Fire mode">Activate</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Analysis category -->
        <div class="modes-category">
            <h4 id="analysis-modes-heading">Analysis & Reflection</h4>
            <div class="modes-list" role="list" aria-labelledby="analysis-modes-heading">
                <!-- Reader Mode -->
                <div class="mode-card" data-mode="reader" role="listitem">
                    <div class="mode-card-header">
                        <i class="fas fa-lightbulb" aria-hidden="true"></i>
                        <h5>Reader Mode</h5>
                    </div>
                    <p class="mode-description">Glimpse your writing through your readers' eyes.</p>
                    <div class="mode-options">
                        <button class="activate-mode-btn" aria-label="Activate Reader mode">Activate</button>
                    </div>
                </div>

                <!-- Meta Mode -->
                <div class="mode-card" data-mode="meta" role="listitem">
                    <div class="mode-card-header">
                        <i class="fas fa-sitemap" aria-hidden="true"></i>
                        <h5>Meta Mode</h5>
                    </div>
                    <p class="mode-description">Analyze what each paragraph says (content) and does (function) in your document.</p>
                    <div class="mode-options">
                        <button class="activate-mode-btn" aria-label="Activate Meta mode">Activate</button>
                    </div>
                </div>

                <div class="mode-card" data-mode="audience" role="listitem">
                    <div class="mode-card-header">
                        <i class="fas fa-users" aria-hidden="true"></i>
                        <h5>Audience Perspective Mode</h5>
                    </div>
                    <p class="mode-description">View your writing through different reader personas and add targeted feedback.</p>
                    <div class="mode-options">
                        <button class="activate-mode-btn" aria-label="Activate Audience Perspective mode">Activate</button>
                    </div>
                </div>

                
            </div>
        </div>

        <!-- Clarity and Concision category -->
        <div class="modes-category">
            <h4 id="enhancement-modes-heading">Clarity and Concision</h4>
            <div class="modes-list" role="list" aria-labelledby="enhancement-modes-heading">
                
                 <div class="mode-card" data-mode="greening" role="listitem">
                    <div class="mode-card-header">
                        <i class="fas fa-cut" aria-hidden="true"></i>
                        <h5>Greening Mode</h5>
                    </div>
                    <p class="mode-description">Systematically reduce your text to meet length constraints while preserving voice and meaning. Based on John McPhee's editing practice of "greening" lines to fit publishing requirements.</p>
                    <div class="mode-options">
                        <button class="activate-mode-btn" aria-label="Activate Greening mode">Activate</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Focus and Depth category -->
        <div class="modes-category">
            <h4 id="enhancement-modes-heading">Focus & Depth</h4>
            <div class="modes-list" role="list" aria-labelledby="enhancement-modes-heading">
                <!-- Key Terms Mode -->
                <div class="mode-card" data-mode="keyTerms" role="listitem">
                    <div class="mode-card-header">
                        <i class="fas fa-highlighter" aria-hidden="true"></i>
                        <h5>Key Terms Mode</h5>
                    </div>
                    <p class="mode-description">Highlight important terms and phrases in your document.</p>
                    <div class="mode-options">
                        <button class="activate-mode-btn" aria-label="Activate Key Terms mode">Activate</button>
                    </div>
                </div>

                <!-- Add this card to your "Focus & Depth" category in the modes panel -->
                <div class="mode-card" data-mode="infrared" role="listitem">
                    <div class="mode-card-header">
                        <i class="fas fa-eye" aria-hidden="true"></i>
                        <h5>Infrared Mode</h5>
                    </div>
                    <p class="mode-description">Reveal hidden language patterns by highlighting jargon words, nuance markers, and other stylistic elements that may need attention.</p>
                    <div class="mode-options">
                        <select id="infrared-pattern-select" class="mode-select" aria-label="Infrared pattern type">
                            <option value="jargon">Jargon Words (Latinate)</option>
                            <option value="nuance">Nuance Words</option>
                        </select>
                        <button class="activate-mode-btn" aria-label="Activate Infrared mode">Activate</button>
                    </div>
                </div>


                <div class="mode-card" data-mode="pomodoro" role="listitem">
                    <div class="mode-card-header">
                        <i class="fas fa-clock" aria-hidden="true"></i>
                        <h5>Pomodoro Mode</h5>
                    </div>
                    <p class="mode-description">Manage tasks and work in focused intervals with customizable breaks.</p>
                    <div class="mode-options">
                        <button class="activate-mode-btn" aria-label="Activate Pomodoro mode">Activate</button>
                    </div>
                </div>

               

                <div class="mode-card" data-mode="wordCloud" role="listitem">
                    <div class="mode-card-header">
                        <i class="fas fa-cloud" aria-hidden="true"></i>
                        <h5>Word Cloud Mode</h5>
                    </div>
                    <p class="mode-description">Generate a visual word cloud of your document to analyze word frequency patterns and identify overused or underused terms.</p>
                    <div class="mode-options">
                        <button class="activate-mode-btn" aria-label="Activate Word Cloud mode">Activate</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Coming Soon category -->
        <div class="modes-category">
            <h4 id="coming-soon-heading">Coming Soon</h4>
            <div class="modes-list" role="list" aria-labelledby="coming-soon-heading">
                <div class="mode-card disabled" role="listitem" aria-disabled="true">
                    <div class="mode-card-header">
                        <i class="fas fa-search" aria-hidden="true"></i>
                        <h5>Style Analyzer</h5>
                    </div>
                    <p class="mode-description">Identify patterns in your writing style.</p>
                    <div class="mode-options">
                        <button class="activate-mode-btn" disabled aria-label="Style Analyzer (coming soon)">Coming Soon</button>
                    </div>
                </div>

                <div class="mode-card disabled" role="listitem" aria-disabled="true">
                    <div class="mode-card-header">
                        <i class="fas fa-comments" aria-hidden="true"></i>
                        <h5>Feedback Mode</h5>
                    </div>
                    <p class="mode-description">Add and manage comments on your document.</p>
                    <div class="mode-options">
                        <button class="activate-mode-btn" disabled aria-label="Feedback Mode (coming soon)">Coming Soon</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Overlay for the panel with ARIA improvements -->
<div id="modes-panel-overlay" class="modes-panel-overlay" aria-hidden="true"></div>
    
    <!-- Hidden elements to maintain compatibility with existing code -->
    <div style="display: none;">
        <button id="textris-mode-btn"></button>
        <select id="textris-level-select">
            <option value="paragraph">Paragraph Mode</option>
            <option value="sentence">Sentence Mode</option>
        </select>
    </div>

    <script>
        // Document Manager - encapsulates document state and operations
        const DocumentManager = {
        documents: [],
        currentDocument: null,
        activeDocumentId: null,
        hasUnsavedChanges: false,
        
        // Load documents from localStorage or use demo documents
        load() {
            const storedDocuments = localStorage.getItem('nyu_writing_documents');
            if (storedDocuments) {
            this.documents = JSON.parse(storedDocuments);
            } else {
            // Use demo documents for first-time users
            this.documents = demoDocuments;
            // Save to localStorage
            localStorage.setItem('nyu_writing_documents', JSON.stringify(this.documents));
            }
        },
        
        // Load user-specific documents
        loadUserDocuments(userId) {
            const userDocumentsKey = `documents_${userId}`;
            const userDocuments = localStorage.getItem(userDocumentsKey);
            
            if (userDocuments) {
            // Replace the documents array with user-specific documents
            this.documents = JSON.parse(userDocuments);
            
            // Render the document list
            this.renderDocumentList();
            
            // Open the first document if available
            if (this.documents.length > 0) {
                this.openDocument(this.documents[0].id);
            }
            }
        },
        
        // Load documents with key terms data
        loadDocumentsWithKeyTerms() {
            // First, load documents normally
            this.load();
            
            // Ensure keyTerms mode is initialized before trying to access it
            if (!modes.keyTerms) {
            modes.keyTerms = {
                name: 'Key Terms Mode',
                terms: [],
                termsData: {}
            };
            }
            
            // Make sure termsData exists
            if (!modes.keyTerms.termsData) {
            modes.keyTerms.termsData = {};
            }
            
            // Then, process each document to load key terms data
            this.documents.forEach(doc => {
            // If the document has key terms, store them in the keyTerms mode
            if (doc.keyTerms && doc.keyTerms.length > 0) {
                // Store the terms for this document
                modes.keyTerms.termsData[doc.id] = doc.keyTerms;
                
                // Log for debugging
                console.log(`Loaded ${doc.keyTerms.length} key term groups for document: ${doc.title}`);
            }
            });
        },
        
        // Save the current document
        saveDocument() {
            if (!this.currentDocument) return;
            
            // Update the document content
            this.currentDocument.content = editor.innerHTML;
            this.currentDocument.plainText = editor.innerText || '';
            this.currentDocument.lastModified = new Date().toISOString();
            this.currentDocument.wordCount = countWords(editor.innerText || '');
            
            // Save key terms data if available
            if (modes.keyTerms) {
            // Make sure we're saving the terms from the current document
            if (currentMode === 'keyTerms') {
                // The terms array directly contains the current document's terms
                this.currentDocument.keyTerms = modes.keyTerms.terms;
            } else if (modes.keyTerms.termsData && modes.keyTerms.termsData[this.currentDocument.id]) {
                // If not in key terms mode, use the stored terms for this document
                this.currentDocument.keyTerms = modes.keyTerms.termsData[this.currentDocument.id];
            }
            
            // Ensure we update the termsData object as well
            if (this.currentDocument.keyTerms && this.currentDocument.keyTerms.length > 0) {
                if (!modes.keyTerms.termsData) {
                modes.keyTerms.termsData = {};
                }
                modes.keyTerms.termsData[this.currentDocument.id] = this.currentDocument.keyTerms;
            }
            }

            // Save reader mode data if we're in Reader Mode
            if (currentMode === 'reader' && modes.reader) {
                modes.reader.saveReflections();
            }


            
            // Find the document in our list and update it
            const index = this.documents.findIndex(doc => doc.id === this.currentDocument.id);
            if (index !== -1) {
            this.documents[index] = this.currentDocument;
            }
            
            // Save to localStorage
            try {
                localStorage.setItem('nyu_writing_documents', JSON.stringify(this.documents));
             
                
                // Clear unsaved changes flag after successful save
                this.hasUnsavedChanges = false;
                
                // Update UI
                this.updateLastSaved();
                this.renderDocumentList();
                
                // Show notification
                showNotification('Document saved successfully!');
            } catch (error) {
                // Handle localStorage errors
                console.error('Failed to save document:', error);
                showNotification('Error saving document! Storage may be full.', 'error');
            }
        },
        
        // Open a document by ID
        openDocument(docId) {
            // Find the document in our list
            const document = this.documents.find(doc => doc.id === docId);
            if (!document) return;
            
            // Update active document
            this.activeDocumentId = docId;
            this.currentDocument = document;
            
            // Update UI
            documentTitle.textContent = document.title;
            editor.innerHTML = document.content || '';
            this.updateWordCount();
            this.updateLastSaved();
            
            // Reset unsaved changes flag
            this.hasUnsavedChanges = false;
            
            // If Key Terms mode is active, apply highlighting for this document
            if (currentMode === 'keyTerms' && modes.keyTerms) {
            // Load terms for this document
            modes.keyTerms.terms = modes.keyTerms.termsData[docId] || [];
            // Update options display
            modes.keyTerms.setupOptions();
            // Apply highlighting if there are terms
            if (modes.keyTerms.terms.length > 0) {
                modes.keyTerms.applyHighlighting();
            }
        }
            
            // If Textris mode is active, apply it to the new document
            if (textrisMode) {
            applyTextrisMode();
            }
            
            // Update active state in document list
            this.renderDocumentList();
        },
        
        // Create a new document
        createNewDocument(title, description) {
            const title_cleaned = title.trim() || 'Untitled Document';
            const description_cleaned = description.trim();
            
            // Create HTML content if description is provided
            let content = '';
            if (description_cleaned) {
            content = `<p>${description_cleaned}</p>`;
            }
            
            const newDocument = {
            id: 'doc' + Date.now(),
            title: title_cleaned,
            content: content,
            plainText: description_cleaned || '',
            lastModified: new Date().toISOString(),
            wordCount: countWords(description_cleaned || '')
            };
            
            // Add to documents list
            this.documents.unshift(newDocument);
            
            // Save to localStorage
            localStorage.setItem('nyu_writing_documents', JSON.stringify(this.documents));
            
            // Open the new document
            this.openDocument(newDocument.id);
            
            // Show notification
            showNotification('New document created!');
            
            return newDocument.id;
        },
        
        // Render the document list with proper ARIA attributes
        renderDocumentList() {
            documentList.innerHTML = '';
            this.documents.forEach(doc => {
            const listItem = document.createElement('li');
            listItem.className = 'document-item';
            listItem.setAttribute('role', 'button');
            listItem.setAttribute('tabindex', '0');
            listItem.setAttribute('aria-label', `Open document: ${doc.title}`);
            listItem.dataset.id = doc.id;
            
            if (this.activeDocumentId === doc.id) {
                listItem.classList.add('active');
                listItem.setAttribute('aria-current', 'true');
            }
            
            const date = new Date(doc.lastModified);
            const formattedDate = date.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric'
            });
            
            listItem.innerHTML = `
                <div class="doc-title">${doc.title}</div>
                <div class="doc-date">Last edited: ${formattedDate}</div>
            `;
            
            // Use delegation-friendly approach - add data attributes instead of direct listeners
            listItem.dataset.action = 'open-document';
            
            documentList.appendChild(listItem);
            });
        },
        
        // Update the word count display
        updateWordCount() {
            if (!editor) return;
            const count = countWords(editor.innerText || '');
            wordCount.textContent = `Words: ${count}`;
            
            // Update count in current document if it exists
            if (this.currentDocument) {
            this.currentDocument.wordCount = count;
            }
        },
        
        // Update the last saved information
        updateLastSaved() {
            if (!this.currentDocument) {
            lastSaved.textContent = 'Last saved: Never';
            return;
            }
            
            const date = new Date(this.currentDocument.lastModified);
            const formattedDate = date.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: 'numeric'
            });
            
            lastSaved.textContent = `Last saved: ${formattedDate}`;
        }
        };

// Demo documents
// Demo documents
const demoDocuments = [
    {
        id: 'doc1',
        title: 'Main Document',
        content: '<h1>Welcome to Writing-Center!</h1><h2>How writers write.</h2><p>Imagine this is your current essay draft, and you need a little critical distance from it. You\'ve been staring at the screen for hours, and don\'t know whether any of it makes sense anymore. This is a common experience for writers at all levels. It\'s not easy—for anyone!—to anticipate how writing will look through the readers eyes. The most experienced writers, however, develop strategies for finding room for improvement, and revising effectively.</p><p>The traditional word processor offers little help with this problem. Programs like Microsoft Word and Google Docs are designed primarily for text entry and basic formatting, not for the complex cognitive work of revision. They present writing as a linear process, encouraging writers to simply keep adding words, or make superficial revisions (finding stray commas, for example, or replacing one word for a close synonym) rather than stepping back to reconsider structure, coherence, and purpose. When we hit a wall in our writing process, typical word processors often leave us without strategies to move forward.</p><p>This is where Writing Center aims to make a difference. Rather than treating writing as the simple act of "getting ideas down," this platform acknowledges writing as a thinking process that requires different modes of engagement at different stages. The various "modes" available here are designed to help you gain new perspectives on your writing and make deliberate choices about revision. Each mode represents a specific strategy that experienced writers use to improve their work.</p><p>Consider, for instance, the challenge of evaluating your essay\'s structure. Our "Textris mode" feature, transforms paragraphs into easily movable blocks, allowing you to experiment with different arrangements without committing to permanent changes. By visually manipulating these blocks, you can test whether a different arrangement might boost your readers\' comprehension or engagement. This approach often reveals logical gaps or opportunities for stronger transitions that weren\'t apparent in the traditional linear view. Many writers find that physically rearranging their ideas unlocks new insights about how their argument might progress.</p><p>For writers struggling with sentence-level flow and coherence, "Reader mode" offers a way to experience your text as a reader might. This mode presents your writing one sentence at a time, prompting you to reflect on what readers need and expect as they move along from idea to idea. This slowed-down, sequential reading experience helps identify places where your writing makes unexpected leaps or fails to fulfill the expectations you\'ve established (purposefully or not!). This mode specifically targets the connections between sentences, highlighting where transitions might be missing or where the logical links between ideas need strengthening.</p><p>"Fire mode" addresses a different revision challenge: identifying and emphasizing your most important points. As writers, it\'s not always easy to distinguish between our key ideas and supporting details. If this is hard for us, as writers, imagine how much more difficult this is for our readers. To bridge this gap, this mode asks you to identify the "sentences you\'d save in a fire" – those that carry your core message or represent the twists and turns of your argument. Once identified, you can strategically position these key sentences for maximum impact, typically at the beginnings and ends of paragraphs where readers pay most attention. This process not only clarifies your main points but often reveals when crucial arguments are buried or underdeveloped.</p><p>Beyond these specific revision modes, the platform\'s document system encourages a more comprehensive approach to the writing process. Rather than cramming everything into a single file, you can create separate documents for different aspects of your project. Just hover your cursor over the lefthand side of the screen to toggle the My Documents menu. The "Evidence Repository" collects research and quotes, the "Goals & Requirements" document keeps assignment guidelines accessible, "Brainstorming" and "Outlining" documents support early-stage planning, and the "Scrap Heap" preserves deleted content that might prove useful later. This distributed approach helps manage complex projects without getting overwhelmed.</p><p>As you navigate this platform, experiment with different modes to discover which ones address your specific writing challenges. Not every mode will be equally useful for every project or writing stage. You might find that "Textris mode" transforms your approach to organization, while another writer might gain more from the sentence-by-sentence reflection of "Reader mode." The key is to engage actively with these tools rather than passively continuing to add text. Take a step back, gain some critical distance, and approach revision as a deliberate, strategic process. Your writing – and your readers – will benefit from this more thoughtful approach to revision.</p>',
        lastModified: '2025-03-06T14:30:00',
        wordCount: 486
    },
    {
        id: 'doc2',
        title: 'Evidence Repository',
        content: '<h1>Research Evidence Collection</h1><h2>How to Use This Document</h2><p>This document is designed to help you collect and organize evidence as you develop your argument. Rather than cluttering your main draft with all your source material, you can store it here for easy reference.</p><h3>Suggested Organization</h3><ul><li>Group related evidence by themes or subtopics</li><li>Include complete citation information with each quote or piece of evidence</li><li>Add brief notes about how each piece of evidence relates to your argument</li><li>Take note of evidence that seems contradictory, to help add nuance and depth to your argument</li></ul><h3>Benefits of Separate Evidence Collection</h3><p>Keeping evidence separate from your main draft allows you to:</p><ul><li>Focus on your structure and argument in your main document without distraction</li><li>Easily locate and compare observations and claims from different sources</li><li>Avoid over-reliance on any single source</li><li>Maintain a comprehensive research collection even as your central claim evolves</li></ul><p>As you work on your project, you can copy relevant evidence from this document into your main draft as needed, ensuring you always have your evidence ready at hand.</p>',
        lastModified: '2025-03-05T10:15:00',
        wordCount: 184
    },
    {
        id: 'doc3',
        title: 'Goals & Requirements',
        content: '<h1>Project Planning & Outlining</h1><h2>How to Use This Document</h2><p>This document provides a dedicated space for storing assignment guidelines, rubrics, and project goals. By keeping these materials separate from your main draft, you can easily refer to requirements while writing.</p><h3>Suggested Content to Store Here</h3><ul><li>Assignment prompts and grading criteria</li><li>Course learning objectives relevant to your project</li><li>Project timelines and submission deadlines</li><li>Feedback from instructors on project proposals</li><li>Research questions guiding your inquiry</li><li>Required formatting guidelines</li></ul><h3>Benefits of Storing Requirements</h3><p>Maintaining a separate document for project goals helps you:</p><ul><li>Stay aligned with assignment expectations throughout the writing process</li><li>Prevent scope creep by referring back to original guidelines</li><li>Check your work against grading criteria before submission</li><li>Manage complex projects with multiple components or requirements</li></ul><p>Revisit this document regularly to ensure your writing remains focused on meeting the objectives established for the assignment.</p>',
        lastModified: '2025-03-04T16:45:00',
        wordCount: 177
    },
    {
        id: 'doc4',
        title: 'Brainstorming',
        content: '<h1>Getting Initial Ideas Down</h1><h2>How to Use This Document</h2><p>This workspace is ideal for capturing all your initial ideas, associations, and questions before you begin formal drafting. It provides freedom to explore concepts without worrying about organization or coherence.</p><h3>Suggested Brainstorming Approaches</h3><ul><li>Free writing - set a timer and write continuously without editing</li><li>Mind mapping - create visual connections between related concepts</li><li>Questioning - pose and answer what/why/how questions about your topic</li><li>Listing - enumerate all possible angles, examples, or implications</li><li>Opposing viewpoints - consider multiple perspectives on your subject</li><li>Analogies - explore how your topic relates to other domains</li></ul><h3>Benefits of Separate Brainstorming</h3><p>Using a dedicated space for initial idea generation helps you:</p><ul><li>Overcome writer\'s block by removing the pressure of formal writing</li><li>Discover unexpected connections between concepts</li><li>Generate a wider range of approaches before committing to one</li><li>Document your thought process for later reflection</li></ul><p>Return to this document whenever you need fresh inspiration or feel stuck in your main draft. The freedom to explore ideas here often leads to breakthroughs in your more structured writing.</p>',
        lastModified: '2025-03-04T16:45:00',
        wordCount: 209
    },
    {
        id: 'doc5',
        title: 'Outlining',
        content: '<h1>Structure and Organization</h1><h2>How to Use This Document</h2><p>This document helps you plan and revise the structure of your writing before committing to full sentences and paragraphs. Working with outlines allows you to focus on the logical flow of your argument without getting distracted by sentence-level concerns.</p><h3>Effective Outlining Techniques</h3><ul><li>Create hierarchical structures with main points and supporting details</li><li>Experiment with different organizational patterns (chronological, comparative, problem-solution, etc.)</li><li>Include brief notes about evidence that will support each point</li><li>Mark transitions between major sections to ensure coherence</li><li>Draft potential topic sentences for key paragraphs</li><li>Test alternative sequences to find the most compelling arrangement</li></ul><h3>Benefits of Outlining</h3><p>Developing outlines separate from your main draft helps you:</p><ul><li>Identify logical gaps in your argument before investing in detailed writing</li><li>Maintain a consistent focus throughout longer documents</li><li>Restructure major sections without rewriting entire paragraphs</li><li>Balance the development of different points and sections</li></ul><p>Revisit and revise your outline throughout the writing process as your thinking evolves. The structure you develop here will serve as the backbone for a coherent, well-organized final draft.</p>',
        lastModified: '2025-03-04T16:45:00',
        wordCount: 197
    },
    {
        id: 'doc6',
        title: 'Scrap Heap',
        content: '<h1>Scrap Heap</h1><h2>How to Use This Document</h2><p>This document serves as a repository for your "darlings" – those well-crafted sentences, paragraphs, or sections that don\'t fit in your current draft but might be valuable later. Instead of permanently deleting content, store it here for potential future use.</p><h3>Best Practices for Storing Deleted Content</h3><ul><li>Date each entry so you know when it was removed</li><li>Include brief context notes about where it was originally placed</li><li>Note why it was removed (e.g., word count constraints, shifted focus, etc.)</li><li>Organize content by sections or themes for easy retrieval</li></ul><h3>Benefits of Preserving Deleted Content</h3><p>Maintaining a separate document for removed material allows you to:</p><ul><li>Make bold revisions without fear of losing valuable writing</li><li>Repurpose strong content for other projects</li><li>Track how your focus and arguments evolve during revision</li><li>Recover material if your direction changes again</li></ul><p>Remember that effective revision often requires removing good content that doesn\'t serve your current purpose. This document helps you preserve that work while maintaining a focused main draft.</p>',
        lastModified: '2025-03-03T09:20:00',
        wordCount: 190
    },
    {
        id: 'doc7',
        title: 'Feedback Repository',
        content: '<h1>Feedback Collection</h1><h2>How to Use This Document</h2><p>This document is designed to help you collect, organize, and respond to feedback from instructors, peers, and writing center consultants. Centralizing feedback helps you track your revision process and ensure you address all suggestions.</p><h3>Suggested Organization</h3><ul><li>Record the name of each reviewer and the date received</li><li>Group feedback by draft version or document section</li><li>Note whether each suggestion has been addressed in revision</li><li>Include your responses to feedback (accepting, modifying, or rejecting with rationale)</li></ul><h3>Benefits of Tracking Feedback</h3><p>Maintaining a separate feedback document helps you:</p><ul><li>See patterns in responses across multiple reviewers</li><li>Prioritize revisions based on feedback importance</li><li>Document your revision process for reflection or conferences</li><li>Demonstrate how you\'ve responded to previous feedback</li><li>Track your growth as a writer over multiple drafts</li></ul><p>By systematically collecting and responding to feedback, you develop your critical thinking skills and take ownership of your revision process.</p>',
        lastModified: '2025-03-02T14:15:00',
        wordCount: 177
    }
];

        // History tracking for Textris mode
        const textrisHistory = {
            undoStack: [], // Stores previous states for undo
            redoStack: [], // Stores undone states for redo
            maxStackSize: 20, // Limit stack size to prevent memory issues
            
            // Save current state to the undo stack
            saveState: function() {
                // Only save if in Textris mode
                if (!textrisMode) return;
                
                // Clear redo stack when a new action is performed
                this.redoStack = [];
                
                // Push current state to undo stack
                const currentState = editor.innerHTML;
                this.undoStack.push(currentState);
                
                // Limit stack size
                if (this.undoStack.length > this.maxStackSize) {
                    this.undoStack.shift(); // Remove oldest state
                }
                
                // Update button states
                this.updateButtonStates();
            },
            
            // Undo the last change
            undo: function() {
                if (this.undoStack.length === 0) return;
                
                // Save current state to redo stack
                const currentState = editor.innerHTML;
                this.redoStack.push(currentState);
                
                // Restore previous state
                const previousState = this.undoStack.pop();
                editor.innerHTML = previousState;
                
                // Re-apply Textris mode to ensure event listeners are attached
                applyTextrisMode();
                
                // Update button states
                this.updateButtonStates();
            },
            
            // Redo the last undone change
            redo: function() {
                if (this.redoStack.length === 0) return;
                
                // Save current state to undo stack
                const currentState = editor.innerHTML;
                this.undoStack.push(currentState);
                
                // Restore next state
                const nextState = this.redoStack.pop();
                editor.innerHTML = nextState;
                
                // Re-apply Textris mode to ensure event listeners are attached
                applyTextrisMode();
                
                // Update button states
                this.updateButtonStates();
            },
            
            // Update undo/redo button states
            updateButtonStates: function() {
                const undoBtn = document.getElementById('textris-undo-btn');
                const redoBtn = document.getElementById('textris-redo-btn');
                
                if (undoBtn) {
                    if (this.undoStack.length === 0) {
                        undoBtn.classList.add('disabled');
                    } else {
                        undoBtn.classList.remove('disabled');
                    }
                }
                
                if (redoBtn) {
                    if (this.redoStack.length === 0) {
                        redoBtn.classList.add('disabled');
                    } else {
                        redoBtn.classList.remove('disabled');
                    }
                }
            },
            
            // Reset history when entering or exiting Textris mode
            reset: function() {
                this.undoStack = [];
                this.redoStack = [];
                this.updateButtonStates();
            }
        };

        // Current state
        let currentDocument = null;
        let documents = [];
        let activeDocumentId = null;
        let textrisMode = false;
        let textrisModeLevel = 'paragraph';
        let draggedElement = null;
        let dragTarget = null;
        let hasUnsavedChanges = false;

        // DOM Elements
        const editor = document.getElementById('editor');
        const documentList = document.getElementById('document-list');
        const documentTitle = document.getElementById('document-title');
        const wordCount = document.getElementById('word-count');
        const lastSaved = document.getElementById('last-saved');
        const newDocumentBtn = document.getElementById('new-document-btn');
        const userProfileBtn = document.getElementById('user-profile-btn');
        const notification = document.getElementById('notification');
        const notificationMessage = document.getElementById('notification-message');
        const activeModeOptions = document.getElementById('active-mode-options');


        // Mode-related DOM elements
        const modesToggleBtn = document.getElementById('modes-toggle-btn');
        const modesPanel = document.getElementById('modes-panel');
        const modesPanelOverlay = document.getElementById('modes-panel-overlay');
        const closePanelBtn = document.getElementById('close-modes-panel');
        const activeModeIndicator = document.getElementById('active-mode-indicator');
        const activeModeName = document.getElementById('active-mode-name');
        const disableModeBtn = document.getElementById('disable-mode-btn');
        const modeCards = document.querySelectorAll('.mode-card:not(.disabled)');
        const activateModeButtons = document.querySelectorAll('.activate-mode-btn:not([disabled])');
        const textrisPanelSelect = document.getElementById('textris-panel-select');

        // Original Textris elements (now hidden in the DOM but referenced in JS)
        const textrisModeBtn = document.getElementById('textris-mode-btn');
        const textrisLevelSelect = document.getElementById('textris-level-select');

        // Modals
        const newDocModal = document.getElementById('new-document-modal');
        const userProfileModal = document.getElementById('user-profile-modal');
        const modalCloseButtons = document.querySelectorAll('.modal-close');
        const cancelNewDocBtn = document.getElementById('cancel-new-doc');
        const createNewDocBtn = document.getElementById('create-new-doc');
        const newDocTitle = document.getElementById('new-doc-title');
        const newDocDescription = document.getElementById('new-doc-description');
        const cancelProfileBtn = document.getElementById('cancel-profile');
        const saveProfileBtn = document.getElementById('save-profile');

        // Mode system state
        let currentMode = null;

        // Mode definitions with enhanced options handling
        const modes = {
            textris: {
                name: 'Textris Mode',
                activate: function(options) {
                    // Store the selected level from the panel
                    if (options && options.level) {
                        textrisModeLevel = options.level;
                        
                        // Make sure the UI element is updated too
                        if (textrisLevelSelect) {
                            textrisLevelSelect.value = options.level;
                        }
                    }
                    
                    // Utilize the existing Textris mode activation code
                    textrisMode = true;
                    textrisModeBtn.classList.add('active');
                    editor.classList.add('textris-mode');
                    editor.contentEditable = 'false';
                    
                    // Apply current mode
                    applyTextrisMode();
                    
                    // Set up mode-specific options in the active indicator
                    this.setupOptions();
                    setTimeout(() => textrisHistory.saveState(), 100);
                    showNotification('Textris Mode enabled - Drag to rearrange!');
                },
                deactivate: function() {
                    // Call the original deactivation logic
                    textrisMode = false;
                    textrisModeBtn.classList.remove('active');
                    editor.classList.remove('textris-mode');
                    editor.contentEditable = 'true';
                    
                    // Enhanced cleanup
                    removeTextrisElements();
                    
                    // Reset Textris history
                    textrisHistory.reset();
                    
                    // Clear mode options
                    clearModeOptions();
                    
                    showNotification('Textris Mode disabled');
                },
                getOptions: function() {
                    // Return current options for this mode
                    return { level: textrisModeLevel };
                },
                setupOptions: function() {
                    // Clear existing options
                    clearModeOptions();
                    
                    // Create level select component
                    const optionContainer = document.createElement('div');
                    optionContainer.className = 'mode-option';
                    
                    const optionLabel = document.createElement('span');
                    optionLabel.className = 'mode-option-label';
                    optionLabel.textContent = 'Level:  ';
                    
                    const levelSelect = document.createElement('select');
                    levelSelect.className = 'mode-option-select';
                    
                    // Add options
                    const paragraphOption = document.createElement('option');
                    paragraphOption.value = 'paragraph';
                    paragraphOption.textContent = 'Paragraph';
                    
                    const sentenceOption = document.createElement('option');
                    sentenceOption.value = 'sentence';
                    sentenceOption.textContent = 'Sentence';
                    
                    // Set current value
                    levelSelect.value = textrisModeLevel;
                    
                    // Add event listener to handle level changes
                    levelSelect.addEventListener('change', (e) => {
                        // Update textris mode level
                        textrisModeLevel = e.target.value;
                        textrisLevelSelect.value = e.target.value;
                        
                        // Update panel select as well
                        if (textrisPanelSelect) {
                            textrisPanelSelect.value = e.target.value;
                        }
                        
                        // Apply the changes
                        applyTextrisMode();
                    });
                    
                    // Assemble the option component
                    levelSelect.appendChild(paragraphOption);
                    levelSelect.appendChild(sentenceOption);
                    optionContainer.appendChild(optionLabel);
                    optionContainer.appendChild(levelSelect);
                    
                    // Add to the active mode options container
                    activeModeOptions.appendChild(optionContainer);
                    // Create container for history buttons
                    const historyContainer = document.createElement('div');
                    historyContainer.className = 'textris-history-buttons';

                    // Create undo button
                    const undoBtn = document.createElement('button');
                    undoBtn.id = 'textris-undo-btn';
                    undoBtn.className = 'textris-history-btn disabled';
                    undoBtn.innerHTML = '<i class="fas fa-undo"></i> Undo';
                    undoBtn.addEventListener('click', () => {
                        if (!undoBtn.classList.contains('disabled')) {
                            textrisHistory.undo();
                        }
                    });

                    // Create redo button
                    const redoBtn = document.createElement('button');
                    redoBtn.id = 'textris-redo-btn';
                    redoBtn.className = 'textris-history-btn disabled';
                    redoBtn.innerHTML = '<i class="fas fa-redo"></i> Redo';
                    redoBtn.addEventListener('click', () => {
                        if (!redoBtn.classList.contains('disabled')) {
                            textrisHistory.redo();
                        }
                    });

                    // Add buttons to container
                    historyContainer.appendChild(undoBtn);
                    historyContainer.appendChild(redoBtn);

                    // Add to active mode options
                    activeModeOptions.appendChild(historyContainer);

                    // Reset history
                    textrisHistory.reset();
                    setTimeout(() => textrisHistory.saveState(), 100);
                                    }
                                },
               
                //Integrate Pomodoro Mode implementation
                pomodoro: {

                    name: 'Pomodoro Mode',
                    popupWindow: null,
                    timerSettings: {
                        workDuration: 25 * 60, // 25 minutes in seconds
                        shortBreakDuration: 5 * 60, // 5 minutes in seconds
                        longBreakDuration: 15 * 60, // 15 minutes in seconds
                        sessionsBeforeLongBreak: 4,
                        completedTasksDisplay: 'strikethrough' // 'strikethrough' or 'hide'
                    },
                    timerState: {
                        currentSession: 'work', // 'work', 'shortBreak', or 'longBreak'
                        timeRemaining: 25 * 60,
                        isRunning: false,
                        sessionCount: 0,
                        timerInterval: null,
                        startTime: null,
                        pauseTime: null
                    },
                    taskData: {
                        tasks: [],
                        nextId: 1
                    },
                    
                    // Method to activate Pomodoro Mode
                    activate: function(options) {
                        // Don't disable other modes when activating
                        if (currentMode) {
                            // Instead of disabling, just note that we're activating Pomodoro alongside another mode
                            console.log(`Activating Pomodoro Mode alongside ${currentMode} mode`);
                        } else {
                            console.log("Activating Pomodoro Mode");
                        }
                        
                        // Load saved data if it exists for the current document
                        this.loadSavedData();
                        
                        // Create the popup window
                        this.createPomodoroWindow();
                        
                        // Set up toolbar indicator
                        this.setupOptions();
                        
                        // Note that we're not setting currentMode = 'pomodoro'
                        // Instead, we'll track Pomodoro state separately
                        
                        showNotification('Pomodoro Mode enabled in a separate window', 'info');
                    },
                    
                    // Method to deactivate Pomodoro Mode
                    deactivate: function() {
                        // Save current data before deactivating
                        this.saveData();
                        
                        // Close the popup window if it exists
                        if (this.popupWindow && !this.popupWindow.closed) {
                            this.popupWindow.close();
                            this.popupWindow = null;
                        }
                        
                        // Clear toolbar indicator
                        clearModeOptions();
                        
                        showNotification('Pomodoro Mode disabled', 'info');
                    },
                    
                    // Get current options for toolbar display
                    getOptions: function() {
                        return {
                            isRunning: this.timerState.isRunning,
                            currentSession: this.timerState.currentSession,
                            timeRemaining: this.timerState.timeRemaining,
                            taskCount: this.taskData.tasks ? this.taskData.tasks.length : 0
                        };
                    },
                    
                    // Set up toolbar indicator for Pomodoro mode
                    setupOptions: function() {
                        // Clear existing options
                        clearModeOptions();
                        
                        // Create a simple indicator showing Pomodoro is active
                        const pomodoroIndicator = document.createElement('div');
                        pomodoroIndicator.className = 'pomodoro-toolbar-indicator';
                        pomodoroIndicator.innerHTML = '<i class="fas fa-clock"></i> Pomodoro Active';
                        pomodoroIndicator.style.display = 'flex';
                        pomodoroIndicator.style.alignItems = 'center';
                        pomodoroIndicator.style.gap = '8px';
                        pomodoroIndicator.style.color = '#57068c';
                        
                        // Add toggle button to show/hide the Pomodoro window
                        const toggleBtn = document.createElement('button');
                        toggleBtn.className = 'toolbar-btn';
                        toggleBtn.innerHTML = '<i class="fas fa-external-link-alt"></i> Show Timer';
                        toggleBtn.setAttribute('aria-label', 'Show Pomodoro timer');
                        toggleBtn.addEventListener('click', () => {
                            if (this.popupWindow && !this.popupWindow.closed) {
                                this.popupWindow.focus();
                            } else {
                                this.createPomodoroWindow();
                            }
                        });
                        
                        // Create container for the indicator
                        const container = document.createElement('div');
                        container.className = 'toolbar-group';
                        container.appendChild(pomodoroIndicator);
                        container.appendChild(toggleBtn);
                        
                        // Add to active mode options
                        activeModeOptions.appendChild(container);
                    },
                    
                    // Create the Pomodoro popup window
                    createPomodoroWindow: function() {
                        // Calculate centered position
                        const width = 450;
                        const height = 600;
                        const left = (window.screen.width - width) / 2;
                        const top = (window.screen.height - height) / 2;
                        
                        // Check if window already exists and is not closed
                        if (this.popupWindow && !this.popupWindow.closed) {
                            this.popupWindow.focus();
                            return;
                        }
                        
                        // Create a new popup window
                        this.popupWindow = window.open('', 'PomodoroTimer', 
                            `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes`);
                        
                        if (!this.popupWindow) {
                            showNotification('Popup blocked! Please allow popups for this site.', 'error');
                            return;
                        }
                        
                        // Get the document in the popup window
                        const popupDoc = this.popupWindow.document;
                        
                        // Generate HTML for the popup
                        this.generatePomodoroHTML(popupDoc);
                        
                        // Initialize the Pomodoro timer and tasks in the popup
                        this.initializePomodoroPopup();
                        
                        // Handle window close events
                        this.popupWindow.addEventListener('beforeunload', () => {
                            // Save data when window is closed
                            this.saveData();
                            
                            // Update toolbar to reflect that the window is closed but Pomodoro mode is still active
                            this.updateToolbarAfterWindowClose();
                        });
                    },
                    
                   // Replace the generatePomodoroHTML function with this improved layout version
                    generatePomodoroHTML: function(popupDoc) {
                        // Get the current theme colors
                        const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#57068c';
                        const primaryDark = getComputedStyle(document.documentElement).getPropertyValue('--primary-color-dark').trim() || '#400667';
                        
                        // Create HTML structure for the popup with improved layout
                        popupDoc.open();
                        popupDoc.write(`
                            <!DOCTYPE html>
                            <html lang="en">
                            <head>
                                <meta charset="UTF-8">
                                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                                <title>Pomodoro Timer</title>
                                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
                                <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700&family=Open+Sans:wght@300;400;500;600&display=swap" rel="stylesheet">
                                <style>
                                    :root {
                                        --primary-color: ${primaryColor};
                                        --primary-dark: ${primaryDark};
                                        --background-color: #f8f8fa;
                                        --card-bg: white;
                                        --border-color: #e6e6e6;
                                        --text-color: #333;
                                        --text-secondary: #666;
                                    }
                                    
                                    * {
                                        margin: 0;
                                        padding: 0;
                                        box-sizing: border-box;
                                    }
                                    
                                    body {
                                        font-family: 'Open Sans', sans-serif;
                                        background-color: var(--background-color);
                                        color: var(--text-color);
                                        line-height: 1.6;
                                        height: 100vh;
                                        display: flex;
                                        flex-direction: column;
                                        overflow: hidden;
                                    }
                                    
                                    /* New header layout with integrated timer */
                                    .pomodoro-header {
                                        background-color: var(--card-bg);
                                        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
                                        padding: 12px 16px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: space-between;
                                        gap: 16px;
                                        z-index: 10;
                                        flex-shrink: 0;
                                        border-bottom: 1px solid var(--border-color);
                                    }
                                    
                                    .pomodoro-title-area {
                                        display: flex;
                                        align-items: center;
                                        gap: 8px;
                                    }
                                    
                                    .pomodoro-title {
                                        font-family: 'Playfair Display', serif;
                                        font-size: 1.3rem;
                                        color: var(--primary-color);
                                        font-weight: 600;
                                        white-space: nowrap;
                                    }
                                    
                                    /* Compact Timer Display */
                                    .pomodoro-timer-display {
                                        display: flex;
                                        align-items: center;
                                        background-color: #f5f5f7;
                                        border-radius: 24px;
                                        padding: 6px 15px;
                                        border: 1px solid var(--border-color);
                                        gap: 8px;
                                        margin-left: auto;
                                        position: relative;
                                    }
                                    
                                    .session-type-indicator {
                                        width: 10px;
                                        height: 10px;
                                        border-radius: 50%;
                                        background-color: #3498db; /* Work session color */
                                        margin-right: 3px;
                                    }
                                    
                                    .work-session .session-type-indicator {
                                        background-color: #3498db;
                                    }
                                    
                                    .short-break-session .session-type-indicator {
                                        background-color: #2ecc71;
                                    }
                                    
                                    .long-break-session .session-type-indicator {
                                        background-color: #9b59b6;
                                    }
                                    
                                    .pomodoro-time {
                                        font-size: 1.2rem;
                                        font-weight: 600;
                                        font-variant-numeric: tabular-nums;
                                        min-width: 60px;
                                        text-align: center;
                                    }
                                    
                                    .pomodoro-session-info {
                                        font-size: 0.8rem;
                                        color: var(--text-secondary);
                                        white-space: nowrap;
                                    }
                                    
                                    .timer-controls {
                                        display: flex;
                                        gap: 4px;
                                    }
                                    
                                    .timer-btn {
                                        background: none;
                                        border: none;
                                        width: 28px;
                                        height: 28px;
                                        border-radius: 50%;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        cursor: pointer;
                                        color: var(--text-secondary);
                                        font-size: 0.9rem;
                                        transition: all 0.2s ease;
                                    }
                                    
                                    .timer-btn:hover {
                                        background-color: rgba(0,0,0,0.05);
                                        color: var(--text-color);
                                    }
                                    
                                    .timer-btn.active {
                                        color: var(--primary-color);
                                    }
                                    
                                    .pomodoro-settings-btn {
                                        background: none;
                                        border: none;
                                        font-size: 1.1rem;
                                        color: var(--text-secondary);
                                        cursor: pointer;
                                        width: 32px;
                                        height: 32px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        border-radius: 50%;
                                        transition: all 0.2s ease;
                                    }
                                    
                                    .pomodoro-settings-btn:hover {
                                        background-color: rgba(0,0,0,0.05);
                                        color: var(--primary-color);
                                    }
                                    
                                    /* Tasks Section - Maximized Space */
                                    .pomodoro-content {
                                        flex: 1;
                                        display: flex;
                                        flex-direction: column;
                                        overflow: hidden;
                                        padding: 16px;
                                    }
                                    
                                    .pomodoro-tasks-header {
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        margin-bottom: 12px;
                                    }
                                    
                                    .pomodoro-tasks-title {
                                        font-size: 1.1rem;
                                        font-weight: 600;
                                        display: flex;
                                        align-items: center;
                                        gap: 6px;
                                    }
                                    
                                    #tasks-counter {
                                        font-size: 0.85rem;
                                        color: var(--text-secondary);
                                        background-color: #f5f5f7;
                                        padding: 3px 10px;
                                        border-radius: 12px;
                                    }
                                    
                                    .pomodoro-tasks-container {
                                        flex: 1;
                                        display: flex;
                                        flex-direction: column;
                                        overflow: hidden;
                                        background-color: var(--card-bg);
                                        border-radius: 8px;
                                        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
                                    }
                                    
                                    .pomodoro-task-list-wrapper {
                                        flex: 1;
                                        overflow-y: auto;
                                        padding: 8px 16px;
                                    }
                                    
                                    .pomodoro-task-list {
                                        list-style: none;
                                    }
                                    
                                    /* Tasks styles */
                                    .pomodoro-task-item {
                                        margin-bottom: 8px;
                                        position: relative;
                                    }
                                    
                                    .pomodoro-task-content {
                                        padding: 8px 10px;
                                        background-color: #f8f9fa;
                                        border-radius: 6px;
                                        display: flex;
                                        align-items: center;
                                        transition: all 0.2s ease;
                                        position: relative;
                                        border: 1px solid transparent;
                                    }
                                    
                                    .pomodoro-task-content:hover {
                                        background-color: #f1f3f5;
                                        border-color: #e9ecef;
                                    }
                                    
                                    .pomodoro-toggle-expand {
                                        margin-right: 5px;
                                        font-size: 10px;
                                        width: 16px;
                                        height: 16px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        border-radius: 2px;
                                        color: #666;
                                        transform: rotate(0deg);
                                        transition: transform 0.2s ease;
                                        cursor: pointer;
                                    }
                                    
                                    .pomodoro-collapsed .pomodoro-toggle-expand {
                                        transform: rotate(-90deg);
                                    }
                                    
                                    .pomodoro-collapsed .pomodoro-subtasks {
                                        display: none;
                                    }
                                    
                                    .pomodoro-task-checkbox {
                                        width: 16px;
                                        height: 16px;
                                        cursor: pointer;
                                        accent-color: var(--primary-color);
                                        margin-right: 10px;
                                    }
                                    
                                    .pomodoro-task-text {
                                        flex: 1;
                                        font-size: 14px;
                                        color: var(--text-color);
                                        word-break: break-word;
                                        padding-right: 10px;
                                    }
                                    
                                    .pomodoro-task-completed .pomodoro-task-text {
                                        text-decoration: line-through;
                                        color: #999;
                                    }
                                    
                                    .pomodoro-task-controls {
                                        opacity: 0.3;
                                        display: flex;
                                        gap: 4px;
                                        transition: opacity 0.2s ease;
                                    }
                                    
                                    .pomodoro-task-content:hover .pomodoro-task-controls {
                                        opacity: 1;
                                    }
                                    
                                    .pomodoro-task-btn {
                                        background: none;
                                        border: none;
                                        font-size: 0.85rem;
                                        color: #666;
                                        cursor: pointer;
                                        width: 24px;
                                        height: 24px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        border-radius: 4px;
                                        transition: all 0.15s ease;
                                    }
                                    
                                    .pomodoro-task-btn:hover {
                                        background-color: rgba(0,0,0,0.05);
                                        color: #333;
                                    }
                                    
                                    .pomodoro-task-delete:hover {
                                        color: #f44336;
                                        background-color: rgba(244,67,54,0.1);
                                    }
                                    
                                    .pomodoro-task-edit:hover {
                                        color: #2196f3;
                                        background-color: rgba(33,150,243,0.1);
                                    }
                                    
                                    .pomodoro-task-add-subtask:hover {
                                        color: var(--primary-color);
                                        background-color: rgba(87,6,140,0.1);
                                    }
                                    
                                    .pomodoro-subtasks {
                                        margin-left: 25px;
                                        border-left: 1px dashed #ddd;
                                        padding-left: 12px;
                                        margin-top: 4px;
                                        margin-bottom: 8px;
                                        position: relative;
                                    }
                                    
                                    /* Create connection lines for nesting */
                                    .pomodoro-subtasks:before {
                                        content: '';
                                        position: absolute;
                                        top: 0;
                                        left: 0;
                                        height: 16px;
                                        width: 6px;
                                        border-bottom: 1px dashed #ddd;
                                    }
                                    
                                    /* Add Task Area - Fixed to bottom */
                                    .pomodoro-add-task-area {
                                        padding: 12px 16px;
                                        border-top: 1px solid var(--border-color);
                                        background-color: #f8f9fa;
                                    }
                                    
                                    .pomodoro-add-task {
                                        display: flex;
                                        gap: 8px;
                                    }
                                    
                                    .pomodoro-add-task-input {
                                        flex: 1;
                                        padding: 8px 12px;
                                        border: 1px solid #ddd;
                                        border-radius: 4px;
                                        font-family: 'Open Sans', sans-serif;
                                        font-size: 14px;
                                        background-color: white;
                                        transition: border-color 0.2s ease;
                                    }
                                    
                                    .pomodoro-add-task-input:focus {
                                        outline: none;
                                        border-color: var(--primary-color);
                                    }
                                    
                                    .pomodoro-add-task-btn {
                                        background-color: var(--primary-color);
                                        color: white;
                                        border: none;
                                        border-radius: 4px;
                                        padding: 8px 12px;
                                        cursor: pointer;
                                        display: flex;
                                        align-items: center;
                                        gap: 6px;
                                        font-weight: 500;
                                        transition: background-color 0.2s ease;
                                    }
                                    
                                    .pomodoro-add-task-btn:hover {
                                        background-color: var(--primary-dark);
                                    }
                                    
                                    /* Empty State */
                                    .pomodoro-no-tasks {
                                        padding: 40px 20px;
                                        text-align: center;
                                        color: #999;
                                        font-style: italic;
                                    }
                                    
                                    /* Progress Indicator */
                                    .timer-progress {
                                        position: absolute;
                                        bottom: 0;
                                        left: 0;
                                        height: 3px;
                                        background-color: var(--primary-color);
                                        transition: width 1s linear;
                                    }
                                    
                                    /* Settings Overlay */
                                    .settings-overlay {
                                        position: fixed;
                                        top: 0;
                                        left: 0;
                                        right: 0;
                                        bottom: 0;
                                        background-color: rgba(0,0,0,0.5);
                                        display: none;
                                        justify-content: center;
                                        align-items: center;
                                        z-index: 100;
                                    }
                                    
                                    .settings-panel {
                                        background-color: white;
                                        border-radius: 8px;
                                        width: 90%;
                                        max-width: 400px;
                                        max-height: 90vh;
                                        overflow-y: auto;
                                        box-shadow: 0 4px 20px rgba(0,0,0,0.15);
                                        display: flex;
                                        flex-direction: column;
                                    }
                                    
                                    .settings-header {
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        padding: 16px;
                                        border-bottom: 1px solid var(--border-color);
                                    }
                                    
                                    .settings-title {
                                        font-size: 1.2rem;
                                        font-weight: 600;
                                        color: var(--primary-color);
                                    }
                                    
                                    .settings-close {
                                        background: none;
                                        border: none;
                                        font-size: 1.2rem;
                                        color: #666;
                                        cursor: pointer;
                                        width: 32px;
                                        height: 32px;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        border-radius: 50%;
                                    }
                                    
                                    .settings-close:hover {
                                        background-color: rgba(0,0,0,0.05);
                                        color: #333;
                                    }
                                    
                                    .settings-content {
                                        padding: 16px;
                                        overflow-y: auto;
                                    }
                                    
                                    .settings-section {
                                        margin-bottom: 20px;
                                    }
                                    
                                    .settings-section-title {
                                        font-weight: 600;
                                        margin-bottom: 12px;
                                        color: var(--primary-color);
                                    }
                                    
                                    .settings-group {
                                        margin-bottom: 16px;
                                    }
                                    
                                    .settings-label {
                                        display: flex;
                                        justify-content: space-between;
                                        align-items: center;
                                        margin-bottom: 8px;
                                    }
                                    
                                    .settings-value {
                                        font-weight: 600;
                                        color: var(--primary-color);
                                    }
                                    
                                    .settings-slider {
                                        width: 100%;
                                        height: 6px;
                                        -webkit-appearance: none;
                                        appearance: none;
                                        background: #ddd;
                                        outline: none;
                                        border-radius: 3px;
                                    }
                                    
                                    .settings-slider::-webkit-slider-thumb {
                                        -webkit-appearance: none;
                                        appearance: none;
                                        width: 16px;
                                        height: 16px;
                                        border-radius: 50%;
                                        background: var(--primary-color);
                                        cursor: pointer;
                                    }
                                    
                                    .settings-radio {
                                        margin-bottom: 8px;
                                        display: flex;
                                        align-items: center;
                                    }
                                    
                                    .settings-radio input[type="radio"] {
                                        margin-right: 8px;
                                        accent-color: var(--primary-color);
                                    }
                                    
                                    .settings-footer {
                                        display: flex;
                                        justify-content: flex-end;
                                        padding: 16px;
                                        border-top: 1px solid var(--border-color);
                                    }
                                    
                                    .settings-save-btn {
                                        background-color: var(--primary-color);
                                        color: white;
                                        border: none;
                                        border-radius: 4px;
                                        padding: 8px 16px;
                                        font-weight: 500;
                                        cursor: pointer;
                                    }
                                    
                                    .settings-save-btn:hover {
                                        background-color: var(--primary-dark);
                                    }
                                    
                                    /* Task edit input */
                                    .pomodoro-task-edit-input {
                                        width: 100%;
                                        padding: 4px 8px;
                                        font-family: 'Open Sans', sans-serif;
                                        font-size: 14px;
                                        border: 1px solid var(--primary-color);
                                        border-radius: 4px;
                                    }
                                    
                                    /* Responsive adjustments */
                                    @media (max-width: 500px) {
                                        .pomodoro-header {
                                            flex-wrap: wrap;
                                        }
                                        
                                        .pomodoro-timer-display {
                                            order: 2;
                                            margin-left: 0;
                                            margin-top: 8px;
                                        }
                                        
                                        .pomodoro-title-area {
                                            flex: 1;
                                        }
                                        
                                        .pomodoro-time {
                                            min-width: 50px;
                                            font-size: 1rem;
                                        }
                                        
                                        .timer-controls {
                                            gap: 2px;
                                        }
                                        
                                        .timer-btn {
                                            width: 24px;
                                            height: 24px;
                                        }
                                    }
                                </style>
                            </head>
                            <body>
                                <!-- Header with integrated timer -->
                                <header class="pomodoro-header">
                                    <div class="pomodoro-title-area">
                                        <h1 class="pomodoro-title">Pomodoro</h1>
                                    </div>
                                    
                                    <div class="pomodoro-timer-display work-session">
                                        <div class="session-type-indicator"></div>
                                        <div id="pomodoro-time" class="pomodoro-time">25:00</div>
                                        <div id="pomodoro-session" class="pomodoro-session-info">Work 1/4</div>
                                        <div class="timer-controls">
                                            <button id="pomodoro-start" class="timer-btn" aria-label="Start timer">
                                                <i class="fas fa-play"></i>
                                            </button>
                                            <button id="pomodoro-reset" class="timer-btn" aria-label="Reset timer">
                                                <i class="fas fa-redo-alt"></i>
                                            </button>
                                            <button id="pomodoro-skip" class="timer-btn" aria-label="Skip to next session">
                                                <i class="fas fa-forward"></i>
                                            </button>
                                        </div>
                                        <div class="timer-progress" style="width: 0%;"></div>
                                    </div>
                                    
                                    <button id="settings-button" class="pomodoro-settings-btn" aria-label="Settings">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                </header>
                                
                                <!-- Main content - Tasks area -->
                                <main class="pomodoro-content">
                                    <div class="pomodoro-tasks-header">
                                        <h2 class="pomodoro-tasks-title">
                                            <i class="fas fa-tasks"></i> Tasks
                                        </h2>
                                        <span id="tasks-counter">0/0 completed</span>
                                    </div>
                                    
                                    <div class="pomodoro-tasks-container">
                                        <div class="pomodoro-task-list-wrapper">
                                            <ul id="pomodoro-tasks" class="pomodoro-task-list">
                                                <!-- Tasks will be added here -->
                                            </ul>
                                        </div>
                                        
                                        <div class="pomodoro-add-task-area">
                                            <div class="pomodoro-add-task">
                                                <input type="text" id="new-task-input" class="pomodoro-add-task-input" placeholder="Add a new task...">
                                                <button id="add-task-btn" class="pomodoro-add-task-btn">
                                                    <i class="fas fa-plus"></i> Add Task
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </main>
                                
                                <!-- Settings overlay -->
                                <div id="settings-overlay" class="settings-overlay">
                                    <div class="settings-panel">
                                        <div class="settings-header">
                                            <h2 class="settings-title">Pomodoro Settings</h2>
                                            <button id="settings-close" class="settings-close">&times;</button>
                                        </div>
                                        <div class="settings-content">
                                            <div class="settings-section">
                                                <h3 class="settings-section-title">Timer Settings</h3>
                                                
                                                <div class="settings-group">
                                                    <label class="settings-label">
                                                        Work Duration
                                                        <span id="work-duration-value" class="settings-value">25</span> min
                                                    </label>
                                                    <input type="range" id="work-duration" class="settings-slider" min="5" max="60" step="1" value="25">
                                                </div>
                                                
                                                <div class="settings-group">
                                                    <label class="settings-label">
                                                        Short Break
                                                        <span id="short-break-value" class="settings-value">5</span> min
                                                    </label>
                                                    <input type="range" id="short-break" class="settings-slider" min="1" max="15" step="1" value="5">
                                                </div>
                                                
                                                <div class="settings-group">
                                                    <label class="settings-label">
                                                        Long Break
                                                        <span id="long-break-value" class="settings-value">15</span> min
                                                    </label>
                                                    <input type="range" id="long-break" class="settings-slider" min="10" max="30" step="1" value="15">
                                                </div>
                                                
                                                <div class="settings-group">
                                                    <label class="settings-label">
                                                        Sessions Before Long Break
                                                        <span id="sessions-value" class="settings-value">4</span>
                                                    </label>
                                                    <input type="range" id="sessions-count" class="settings-slider" min="2" max="6" step="1" value="4">
                                                </div>
                                            </div>
                                            
                                            <div class="settings-section">
                                                <h3 class="settings-section-title">Task Display</h3>
                                                
                                                <div class="settings-group">
                                                    <div class="settings-radio">
                                                        <input type="radio" id="strikethrough" name="completed-display" value="strikethrough" checked>
                                                        <label for="strikethrough">Show completed tasks with strikethrough</label>
                                                    </div>
                                                    <div class="settings-radio">
                                                        <input type="radio" id="hide" name="completed-display" value="hide">
                                                        <label for="hide">Hide completed tasks</label>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="settings-footer">
                                            <button id="save-settings" class="settings-save-btn">Save Changes</button>
                                        </div>
                                    </div>
                                </div>
                            </body>
                            </html>
                        `);
                        popupDoc.close();
                    },

                    
                    // Now, let's replace the onclick handler for the task list with a more reliable version
                    // This should be included in the initializePomodoroPopup function
                    initializePomodoroPopup: function() {
                        if (!this.popupWindow || this.popupWindow.closed) return;
                        
                        const self = this; // Store reference to this for event handlers
                        const popupDoc = this.popupWindow.document;
                        
                        // Setup timer display
                        this.updateTimerDisplay();
                        
                        // Render tasks
                        this.renderTasks();
                        
                        // Direct event handlers for main buttons
                        const addTaskBtn = popupDoc.getElementById('add-task-btn');
                        if (addTaskBtn) {
                            addTaskBtn.onclick = function() { self.addTask(); };
                        }
                        
                        const newTaskInput = popupDoc.getElementById('new-task-input');
                        if (newTaskInput) {
                            newTaskInput.onkeydown = function(e) {
                                if (e.key === 'Enter') { self.addTask(); }
                            };
                        }
                        
                        const startBtn = popupDoc.getElementById('pomodoro-start');
                        if (startBtn) {
                            startBtn.onclick = function() { self.toggleTimer(); };
                        }
                        
                        const resetBtn = popupDoc.getElementById('pomodoro-reset');
                        if (resetBtn) {
                            resetBtn.onclick = function() { self.resetTimer(); };
                        }
                        
                        const skipBtn = popupDoc.getElementById('pomodoro-skip');
                        if (skipBtn) {
                            skipBtn.onclick = function() { self.skipCurrentSession(); };
                        }
                        
                        const settingsBtn = popupDoc.getElementById('settings-button');
                        if (settingsBtn) {
                            settingsBtn.onclick = function() { self.showSettings(); };
                        }
                        
                        const closeSettingsBtn = popupDoc.getElementById('settings-close');
                        if (closeSettingsBtn) {
                            closeSettingsBtn.onclick = function() { self.hideSettings(); };
                        }
                        
                        const saveSettingsBtn = popupDoc.getElementById('save-settings');
                        if (saveSettingsBtn) {
                            saveSettingsBtn.onclick = function() { 
                                self.saveSettings(); 
                                self.hideSettings();
                            };
                        }
                        
                        // Settings sliders
                        const setupSlider = function(id, valueId) {
                            const slider = popupDoc.getElementById(id);
                            const valueEl = popupDoc.getElementById(valueId);
                            if (slider && valueEl) {
                                slider.oninput = function() {
                                    valueEl.textContent = this.value;
                                };
                            }
                        };
                        
                        setupSlider('work-duration', 'work-duration-value');
                        setupSlider('short-break', 'short-break-value');
                        setupSlider('long-break', 'long-break-value');
                        setupSlider('sessions-count', 'sessions-value');
                        
                        // FIX: Improved task list click handler with better delete functionality
                        const tasksList = popupDoc.getElementById('pomodoro-tasks');
                        if (tasksList) {
                            tasksList.onclick = function(e) {
                                // Prevent default to avoid any issues
                                e.preventDefault();
                                
                                const target = e.target;
                                console.log("Clicked element:", target.tagName, target.className);
                                
                                // Handle delete button click - check both the icon and the button
                                const deleteBtn = target.closest('.pomodoro-task-delete');
                                if (deleteBtn) {
                                    console.log("Delete button clicked");
                                    const taskItem = deleteBtn.closest('.pomodoro-task-item');
                                    if (taskItem) {
                                        const taskId = taskItem.dataset.id;
                                        console.log("Task ID for deletion:", taskId);
                                        
                                        if (taskId) {
                                            if (confirm('Are you sure you want to delete this task?')) {
                                                self.deleteTask(taskId);
                                            }
                                        }
                                        return;
                                    }
                                }
                                
                                // Handle expand/collapse
                                const expandToggle = target.closest('.pomodoro-toggle-expand');
                                if (expandToggle) {
                                    const taskItem = expandToggle.closest('.pomodoro-task-item');
                                    if (taskItem) {
                                        taskItem.classList.toggle('pomodoro-collapsed');
                                    }
                                    return;
                                }
                                
                                // Handle checkbox
                                if (target.classList.contains('pomodoro-task-checkbox')) {
                                    const taskItem = target.closest('.pomodoro-task-item');
                                    if (taskItem) {
                                        const taskId = taskItem.dataset.id;
                                        self.toggleTaskCompletion(taskId, target.checked);
                                    }
                                    return;
                                }
                                
                                // Handle add subtask button
                                const addSubtaskBtn = target.closest('.pomodoro-task-add-subtask');
                                if (addSubtaskBtn) {
                                    const taskItem = addSubtaskBtn.closest('.pomodoro-task-item');
                                    if (taskItem) {
                                        const taskId = taskItem.dataset.id;
                                        if (taskId) {
                                            self.addSubtask(taskId);
                                        }
                                    }
                                    return;
                                }
                                
                                // Handle edit button
                                const editBtn = target.closest('.pomodoro-task-edit');
                                if (editBtn) {
                                    const taskItem = editBtn.closest('.pomodoro-task-item');
                                    if (taskItem) {
                                        const taskId = taskItem.dataset.id;
                                        const taskTextEl = taskItem.querySelector('.pomodoro-task-text');
                                        if (taskId && taskTextEl) {
                                            self.editTask(taskId, taskTextEl);
                                        }
                                    }
                                    return;
                                }
                            };
                        }
                        
                        // Start the timer if it was running
                        if (this.timerState.isRunning) {
                            this.startTimer();
                        }
                        
                        // Save data when window is closed
                        this.popupWindow.onbeforeunload = function() {
                            self.saveData();
                        };
                    },
                    
                    // Update the updateTimerDisplay function to work with the new layout
                    updateTimerDisplay: function() {
                        if (!this.popupWindow || this.popupWindow.closed) return;
                        
                        const popupDoc = this.popupWindow.document;
                        const timeDisplay = popupDoc.getElementById('pomodoro-time');
                        const sessionDisplay = popupDoc.getElementById('pomodoro-session');
                        const startButton = popupDoc.getElementById('pomodoro-start');
                        const timerDisplay = popupDoc.querySelector('.pomodoro-timer-display');
                        const timerProgress = popupDoc.querySelector('.timer-progress');
                        
                        if (!timeDisplay || !sessionDisplay || !startButton || !timerDisplay) return;
                        
                        // Remove all session classes
                        timerDisplay.classList.remove('work-session', 'short-break-session', 'long-break-session');
                        
                        // Set appropriate session class
                        if (this.timerState.currentSession === 'work') {
                            timerDisplay.classList.add('work-session');
                        } else if (this.timerState.currentSession === 'shortBreak') {
                            timerDisplay.classList.add('short-break-session');
                        } else if (this.timerState.currentSession === 'longBreak') {
                            timerDisplay.classList.add('long-break-session');
                        }
                        
                        // Format time as MM:SS
                        const minutes = Math.floor(this.timerState.timeRemaining / 60);
                        const seconds = this.timerState.timeRemaining % 60;
                        timeDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                        
                        // Update progress bar
                        if (timerProgress) {
                            const totalDuration = this.getCurrentSessionDuration();
                            const percentComplete = ((totalDuration - this.timerState.timeRemaining) / totalDuration) * 100;
                            timerProgress.style.width = `${percentComplete}%`;
                        }
                        
                        // Update session text
                        let sessionText = "";
                        
                        if (this.timerState.currentSession === 'work') {
                            const currentWorkSession = (this.timerState.sessionCount % this.timerSettings.sessionsBeforeLongBreak) + 1;
                            sessionText = `Work ${currentWorkSession}/${this.timerSettings.sessionsBeforeLongBreak}`;
                        } 
                        else if (this.timerState.currentSession === 'shortBreak') {
                            sessionText = `Short Break`;
                        } 
                        else { // longBreak
                            sessionText = `Long Break`;
                        }
                        
                        sessionDisplay.textContent = sessionText;
                        
                        // Update start/pause button
                        if (this.timerState.isRunning) {
                            startButton.innerHTML = '<i class="fas fa-pause"></i>';
                            startButton.setAttribute('aria-label', 'Pause timer');
                            startButton.classList.add('active');
                        } else {
                            startButton.innerHTML = '<i class="fas fa-play"></i>';
                            startButton.setAttribute('aria-label', 'Start timer');
                            startButton.classList.remove('active');
                        }
                    },
                    
                    // Toggle timer (start/pause)
                    toggleTimer: function() {
                        if (this.timerState.isRunning) {
                            this.pauseTimer();
                        } else {
                            this.startTimer();
                        }
                    },
                    
                    // Start the timer
                    startTimer: function() {
                        if (this.timerState.isRunning) return;
                        
                        // Calculate the start time
                        if (!this.timerState.pauseTime) {
                            this.timerState.startTime = Date.now();
                        } else {
                            // If resuming from pause, adjust the start time
                            const pauseDuration = Date.now() - this.timerState.pauseTime;
                            this.timerState.startTime += pauseDuration;
                            this.timerState.pauseTime = null;
                        }
                        
                        // Mark timer as running
                        this.timerState.isRunning = true;
                        
                        // Update the UI
                        this.updateTimerDisplay();
                        
                        // Create a reference to 'this' for use in the interval
                        const self = this;
                        
                        // Set up the timer interval
                        this.timerState.timerInterval = setInterval(function() {
                            // Calculate elapsed time
                            const elapsed = Math.floor((Date.now() - self.timerState.startTime) / 1000);
                            self.timerState.timeRemaining = Math.max(0, self.getCurrentSessionDuration() - elapsed);
                            
                            // Update display
                            self.updateTimerDisplay();
                            
                            // Check if timer has completed
                            if (self.timerState.timeRemaining <= 0) {
                                self.handleTimerComplete();
                            }
                        }, 1000);
                    },
                    
                    // Pause the timer
                    pauseTimer: function() {
                        if (!this.timerState.isRunning) return;
                        
                        // Clear interval
                        clearInterval(this.timerState.timerInterval);
                        this.timerState.timerInterval = null;
                        
                        // Store the time of pause
                        this.timerState.pauseTime = Date.now();
                        
                        // Mark as paused
                        this.timerState.isRunning = false;
                        
                        // Update UI
                        this.updateTimerDisplay();
                    },
                    
                    // Reset the timer
                    resetTimer: function() {
                        // If running, pause first
                        if (this.timerState.isRunning) {
                            this.pauseTimer();
                        }
                        
                        // Reset time remaining to the full duration of current session
                        this.timerState.timeRemaining = this.getCurrentSessionDuration();
                        this.timerState.startTime = null;
                        this.timerState.pauseTime = null;
                        
                        // Update UI
                        this.updateTimerDisplay();
                    },
                    
                    // Handle timer completion
                    handleTimerComplete: function() {
                        // Stop the timer
                        clearInterval(this.timerState.timerInterval);
                        this.timerState.timerInterval = null;
                        this.timerState.isRunning = false;
                        
                        // Play sound notification
                        this.playTimerCompleteSound();
                        
                        // Show desktop notification if permission is granted
                        this.showTimerNotification();
                        
                        // Determine what type of session just ended
                        const completedSession = this.timerState.currentSession;
                        
                        // Increment session count if work session completed
                        if (completedSession === 'work') {
                            this.timerState.sessionCount++;
                        }
                        
                        // Determine next session type
                        let nextSession;
                        if (completedSession === 'work') {
                            if (this.timerState.sessionCount % this.timerSettings.sessionsBeforeLongBreak === 0) {
                                nextSession = 'longBreak';
                            } else {
                                nextSession = 'shortBreak';
                            }
                        } else {
                            // After any break, go back to work
                            nextSession = 'work';
                        }
                        
                        // Switch to next session
                        this.switchSession(nextSession);
                        
                        // Auto-start the next session
                        this.startTimer();
                    },
                    
                    // Skip current session and move to the next one
                    skipCurrentSession: function() {
                        // Handle similar to timer completion but without sound
                        this.pauseTimer();
                        
                        const completedSession = this.timerState.currentSession;
                        
                        // Increment session count if work session was skipped
                        if (completedSession === 'work') {
                            this.timerState.sessionCount++;
                        }
                        
                        // Determine next session type
                        let nextSession;
                        if (completedSession === 'work') {
                            if (this.timerState.sessionCount % this.timerSettings.sessionsBeforeLongBreak === 0) {
                                nextSession = 'longBreak';
                            } else {
                                nextSession = 'shortBreak';
                            }
                        } else {
                            // After any break, go back to work
                            nextSession = 'work';
                        }
                        
                        // Switch to next session
                        this.switchSession(nextSession);
                        
                        // Update display
                        this.updateTimerDisplay();
                    },
                    
                    // Play a sound when timer completes
                    playTimerCompleteSound: function() {
                        if (!this.popupWindow || this.popupWindow.closed) return;
                        
                        try {
                            // Create a simple beep sound using Web Audio API
                            const context = new this.popupWindow.AudioContext();
                            const oscillator = context.createOscillator();
                            const gainNode = context.createGain();
                            
                            // Set oscillator properties
                            oscillator.type = 'sine';
                            oscillator.frequency.setValueAtTime(
                                this.timerState.currentSession === 'work' ? 800 : 600, 
                                context.currentTime
                            );
                            
                            // Set volume
                            gainNode.gain.setValueAtTime(0.1, context.currentTime);
                            
                            // Connect nodes
                            oscillator.connect(gainNode);
                            gainNode.connect(context.destination);
                            
                            // Play sound
                            oscillator.start();
                            oscillator.stop(context.currentTime + 0.5); // 0.5 seconds duration
                        } catch (error) {
                            console.error('Error playing sound:', error);
                        }
                    },
                    
                    // Show desktop notification
                    showTimerNotification: function() {
                        if (!this.popupWindow || this.popupWindow.closed) return;
                        
                        try {
                            // Check if notification permission is granted
                            if (Notification.permission === 'granted') {
                                const session = this.timerState.currentSession;
                                let title, message;
                                
                                if (session === 'work') {
                                    title = 'Work Session Complete';
                                    message = 'Time for a break!';
                                } else if (session === 'shortBreak') {
                                    title = 'Break Complete';
                                    message = 'Back to work!';
                                } else {
                                    title = 'Long Break Complete';
                                    message = 'Ready for another work session?';
                                }
                                
                                // Create and show notification
                                const notification = new this.popupWindow.Notification(title, {
                                    body: message,
                                    icon: 'https://i.imgur.com/lMAoVCW.png'
                                });
                                
                                // Auto-close after 5 seconds
                                setTimeout(() => notification.close(), 5000);
                            } 
                            // If permission not granted yet, request it
                            else if (Notification.permission !== 'denied') {
                                Notification.requestPermission();
                            }
                        } catch (error) {
                            console.error('Error showing notification:', error);
                        }
                    },
                    
                    // Switch to a different session type
                    switchSession: function(sessionType) {
                        // Validate session type
                        if (!['work', 'shortBreak', 'longBreak'].includes(sessionType)) {
                            sessionType = 'work'; // Default to work session if invalid
                        }
                        
                        this.timerState.currentSession = sessionType;
                        
                        // Set time for the new session
                        this.timerState.timeRemaining = this.getCurrentSessionDuration();
                        this.timerState.startTime = null;
                        this.timerState.pauseTime = null;
                        
                        // Update display
                        this.updateTimerDisplay();
                    },
                    
                    // Get current session duration in seconds
                    getCurrentSessionDuration: function() {
                        switch (this.timerState.currentSession) {
                            case 'work':
                                return this.timerSettings.workDuration;
                            case 'shortBreak':
                                return this.timerSettings.shortBreakDuration;
                            case 'longBreak':
                                return this.timerSettings.longBreakDuration;
                            default:
                                return this.timerSettings.workDuration;
                        }
                    },
                    
                    // Show settings dialog
                    showSettings: function() {
                        if (!this.popupWindow || this.popupWindow.closed) return;
                        
                        const popupDoc = this.popupWindow.document;
                        const settingsOverlay = popupDoc.getElementById('settings-overlay');
                        
                        if (settingsOverlay) {
                            // Update settings values to current values
                            const workDurationSlider = popupDoc.getElementById('work-duration');
                            const shortBreakSlider = popupDoc.getElementById('short-break');
                            const longBreakSlider = popupDoc.getElementById('long-break');
                            const sessionsSlider = popupDoc.getElementById('sessions-count');
                            
                            // Convert seconds to minutes for display
                            workDurationSlider.value = Math.floor(this.timerSettings.workDuration / 60);
                            shortBreakSlider.value = Math.floor(this.timerSettings.shortBreakDuration / 60);
                            longBreakSlider.value = Math.floor(this.timerSettings.longBreakDuration / 60);
                            sessionsSlider.value = this.timerSettings.sessionsBeforeLongBreak;
                            
                            // Update displayed values
                            popupDoc.getElementById('work-duration-value').textContent = workDurationSlider.value;
                            popupDoc.getElementById('short-break-value').textContent = shortBreakSlider.value;
                            popupDoc.getElementById('long-break-value').textContent = longBreakSlider.value;
                            popupDoc.getElementById('sessions-value').textContent = sessionsSlider.value;
                            
                            // Set radio button for completed task display
                            const displayOption = this.timerSettings.completedTasksDisplay;
                            const radioOption = popupDoc.getElementById(displayOption);
                            if (radioOption) {
                                radioOption.checked = true;
                            }
                            
                            // Show overlay
                            settingsOverlay.style.display = 'flex';
                        }
                    },
                    
                    // Hide settings dialog
                    hideSettings: function() {
                        if (!this.popupWindow || this.popupWindow.closed) return;
                        
                        const popupDoc = this.popupWindow.document;
                        const settingsOverlay = popupDoc.getElementById('settings-overlay');
                        
                        if (settingsOverlay) {
                            settingsOverlay.style.display = 'none';
                        }
                    },
                    
                    // Save settings
                    saveSettings: function() {
                        if (!this.popupWindow || this.popupWindow.closed) return;
                        
                        const popupDoc = this.popupWindow.document;
                        
                        // Get values from settings form
                        const workDuration = popupDoc.getElementById('work-duration').value;
                        const shortBreak = popupDoc.getElementById('short-break').value;
                        const longBreak = popupDoc.getElementById('long-break').value;
                        const sessions = popupDoc.getElementById('sessions-count').value;
                        
                        // Get completed tasks display preference
                        const displayRadios = popupDoc.getElementsByName('completed-display');
                        let completedTasksDisplay = 'strikethrough';
                        
                        for (let radio of displayRadios) {
                            if (radio.checked) {
                                completedTasksDisplay = radio.value;
                                break;
                            }
                        }
                        
                        // Update settings (convert minutes to seconds)
                        this.timerSettings.workDuration = parseInt(workDuration) * 60;
                        this.timerSettings.shortBreakDuration = parseInt(shortBreak) * 60;
                        this.timerSettings.longBreakDuration = parseInt(longBreak) * 60;
                        this.timerSettings.sessionsBeforeLongBreak = parseInt(sessions);
                        this.timerSettings.completedTasksDisplay = completedTasksDisplay;
                        
                        // Update timer remaining if not running
                        if (!this.timerState.isRunning) {
                            this.timerState.timeRemaining = this.getCurrentSessionDuration();
                            this.updateTimerDisplay();
                        }
                        
                        // Update task display based on preference
                        this.updateTaskDisplay();
                        
                        // Save data
                        this.saveData();
                    },
                    
                    // Load saved data
                    loadSavedData: function() {
                        try {
                            // Check if current document has Pomodoro data
                            if (DocumentManager.currentDocument && DocumentManager.currentDocument.pomodoroData) {
                                const savedData = DocumentManager.currentDocument.pomodoroData;
                                
                                // Load settings if available
                                if (savedData.settings) {
                                    this.timerSettings = {
                                        ...this.timerSettings, // Keep defaults for any missing properties
                                        ...savedData.settings
                                    };
                                }
                                
                                // Load task data if available
                                if (savedData.tasks) {
                                    this.taskData = savedData.tasks;
                                }
                                
                                // Load timer state - but only certain properties
                                if (savedData.timerState) {
                                    // Start with default isRunning = false for safety
                                    this.timerState = {
                                        ...this.timerState,
                                        currentSession: savedData.timerState.currentSession || 'work',
                                        sessionCount: savedData.timerState.sessionCount || 0,
                                        timeRemaining: savedData.timerState.timeRemaining || this.timerSettings.workDuration,
                                        isRunning: false, // Always start paused for safety
                                        startTime: null,
                                        pauseTime: null,
                                        timerInterval: null
                                    };
                                }
                                
                                console.log('Loaded Pomodoro data from document');
                            }
                        } catch (error) {
                            console.error('Error loading Pomodoro data:', error);
                            
                            // Reset to defaults on error
                            this.resetToDefaults();
                        }
                    },
                    
                    // Reset to default settings and state
                    resetToDefaults: function() {
                        this.timerSettings = {
                            workDuration: 25 * 60, // 25 minutes in seconds
                            shortBreakDuration: 5 * 60, // 5 minutes in seconds
                            longBreakDuration: 15 * 60, // 15 minutes in seconds
                            sessionsBeforeLongBreak: 4,
                            completedTasksDisplay: 'strikethrough'
                        };
                        
                        this.timerState = {
                            currentSession: 'work',
                            timeRemaining: 25 * 60,
                            isRunning: false,
                            sessionCount: 0,
                            timerInterval: null,
                            startTime: null,
                            pauseTime: null
                        };
                        
                        this.taskData = {
                            tasks: [],
                            nextId: 1
                        };
                    },
                    
                    // Save data to the document
                    saveData: function() {
                        try {
                            if (!DocumentManager.currentDocument) return;
                            
                            // Prepare data to save
                            const dataToSave = {
                                settings: this.timerSettings,
                                tasks: this.taskData,
                                timerState: {
                                    currentSession: this.timerState.currentSession,
                                    sessionCount: this.timerState.sessionCount,
                                    timeRemaining: this.timerState.timeRemaining
                                    // Don't save isRunning, timerInterval, startTime, pauseTime
                                }
                            };
                            
                            // Save to document
                            DocumentManager.currentDocument.pomodoroData = dataToSave;
                            
                            // Save the document to persist changes
                            DocumentManager.saveDocument();
                            
                            console.log('Saved Pomodoro data to document');
                        } catch (error) {
                            console.error('Error saving Pomodoro data:', error);
                            showNotification('Error saving Pomodoro data', 'error');
                        }
                    },
                    
                    // Improved renderTasks function to ensure task IDs are properly set
                    renderTasks: function() {
                        if (!this.popupWindow || this.popupWindow.closed) return;
                        
                        const popupDoc = this.popupWindow.document;
                        const tasksList = popupDoc.getElementById('pomodoro-tasks');
                        const tasksCounter = popupDoc.getElementById('tasks-counter');
                        
                        if (!tasksList) return;
                        
                        // Clear the list
                        tasksList.innerHTML = '';
                        
                        // Check if we have tasks
                        if (!this.taskData.tasks || !Array.isArray(this.taskData.tasks) || this.taskData.tasks.length === 0) {
                            tasksList.innerHTML = '<li class="pomodoro-no-tasks">No tasks added yet. Add a task to get started.</li>';
                            if (tasksCounter) {
                                tasksCounter.textContent = '0/0 completed';
                            }
                            return;
                        }
                        
                        // Count completed tasks
                        let completedCount = 0;
                        let totalCount = 0;
                        
                        // Function to count tasks including subtasks
                        const countTasks = (tasks) => {
                            if (!tasks || !Array.isArray(tasks)) return;
                            
                            tasks.forEach(task => {
                                totalCount++;
                                if (task.completed) completedCount++;
                                
                                if (task.subtasks && Array.isArray(task.subtasks) && task.subtasks.length > 0) {
                                    countTasks(task.subtasks);
                                }
                            });
                        };
                        
                        // Count all tasks
                        countTasks(this.taskData.tasks);
                        
                        // Update counter
                        if (tasksCounter) {
                            tasksCounter.textContent = `${completedCount}/${totalCount} completed`;
                        }
                        
                        // Recursive function to render task list
                        const renderTaskList = (tasks, parentElement) => {
                            if (!tasks || !Array.isArray(tasks)) return;
                            
                            tasks.forEach(task => {
                                // Skip if we're hiding completed tasks
                                if (task.completed && this.timerSettings.completedTasksDisplay === 'hide') {
                                    return;
                                }
                                
                                // Make sure task has an ID
                                if (!task.id) {
                                    task.id = this.generateTaskId();
                                }
                                
                                // Create task item
                                const taskItem = popupDoc.createElement('li');
                                taskItem.className = `pomodoro-task-item${task.completed ? ' pomodoro-task-completed' : ''}`;
                                taskItem.dataset.id = task.id;
                                
                                // Check if task has subtasks
                                const hasSubtasks = task.subtasks && Array.isArray(task.subtasks) && task.subtasks.length > 0;
                                
                                // Create task content
                                const taskContent = popupDoc.createElement('div');
                                taskContent.className = 'pomodoro-task-content';
                                
                                // Create expand toggle if has subtasks
                                const expandToggle = popupDoc.createElement('span');
                                expandToggle.className = 'pomodoro-toggle-expand';
                                expandToggle.innerHTML = '<i class="fas fa-caret-down"></i>';
                                if (!hasSubtasks) {
                                    expandToggle.style.visibility = 'hidden';
                                }
                                
                                // Create checkbox
                                const checkbox = popupDoc.createElement('input');
                                checkbox.type = 'checkbox';
                                checkbox.className = 'pomodoro-task-checkbox';
                                checkbox.checked = task.completed || false;
                                
                                // Create text element
                                const textEl = popupDoc.createElement('div');
                                textEl.className = 'pomodoro-task-text';
                                textEl.textContent = task.text || 'Untitled Task';
                                
                                // Create controls
                                const controls = popupDoc.createElement('div');
                                controls.className = 'pomodoro-task-controls';
                                
                                // Add subtask button
                                const addSubtaskBtn = popupDoc.createElement('button');
                                addSubtaskBtn.className = 'pomodoro-task-btn pomodoro-task-add-subtask';
                                addSubtaskBtn.setAttribute('aria-label', 'Add subtask');
                                addSubtaskBtn.innerHTML = '<i class="fas fa-list"></i>';
                                addSubtaskBtn.dataset.taskId = task.id;
                                
                                // Edit button
                                const editBtn = popupDoc.createElement('button');
                                editBtn.className = 'pomodoro-task-btn pomodoro-task-edit';
                                editBtn.setAttribute('aria-label', 'Edit task');
                                editBtn.innerHTML = '<i class="fas fa-edit"></i>';
                                
                                // Delete button
                                const deleteBtn = popupDoc.createElement('button');
                                deleteBtn.className = 'pomodoro-task-btn pomodoro-task-delete';
                                deleteBtn.setAttribute('aria-label', 'Delete task');
                                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>';
                                deleteBtn.dataset.taskId = task.id;
                                
                                // Assemble controls
                                controls.appendChild(addSubtaskBtn);
                                controls.appendChild(editBtn);
                                controls.appendChild(deleteBtn);
                                
                                // Assemble task content
                                taskContent.appendChild(expandToggle);
                                taskContent.appendChild(checkbox);
                                taskContent.appendChild(textEl);
                                taskContent.appendChild(controls);
                                
                                // Add task content to task item
                                taskItem.appendChild(taskContent);
                                
                                // Add to parent element
                                parentElement.appendChild(taskItem);
                                
                                // Create subtasks container
                                if (task.subtasks || hasSubtasks) {
                                    const subtasksList = popupDoc.createElement('ul');
                                    subtasksList.className = 'pomodoro-subtasks';
                                    taskItem.appendChild(subtasksList);
                                    
                                    // Render subtasks if there are any
                                    if (hasSubtasks) {
                                        renderTaskList(task.subtasks, subtasksList);
                                    }
                                }
                            });
                        };
                        
                        // Start rendering from top-level tasks
                        renderTaskList(this.taskData.tasks, tasksList);
                    },


                    // New method to set up task event handlers using event delegation
                    setupTaskEventHandlers: function() {
                        if (!this.popupWindow || this.popupWindow.closed) return;
                        
                        const popupDoc = this.popupWindow.document;
                        const tasksList = popupDoc.getElementById('pomodoro-tasks');
                        
                        if (!tasksList) return;
                        
                        // Remove existing listener if any
                        if (this.taskListClickHandler) {
                            tasksList.removeEventListener('click', this.taskListClickHandler);
                        }
                        
                        // Create a handler for all task-related clicks
                        this.taskListClickHandler = (e) => {
                            const target = e.target;
                            
                            // Toggle expand/collapse
                            if (target.closest('.pomodoro-toggle-expand')) {
                                const taskItem = target.closest('.pomodoro-task-item');
                                if (taskItem) {
                                    taskItem.classList.toggle('pomodoro-collapsed');
                                }
                            }
                            
                            // Add subtask
                            if (target.closest('.pomodoro-task-add-subtask')) {
                                const addBtn = target.closest('.pomodoro-task-add-subtask');
                                const taskId = addBtn.dataset.taskId;
                                if (taskId) {
                                    this.addSubtask(taskId);
                                }
                            }
                            
                            // Task checkbox
                            if (target.classList.contains('pomodoro-task-checkbox')) {
                                const taskItem = target.closest('.pomodoro-task-item');
                                if (taskItem) {
                                    const taskId = taskItem.dataset.id;
                                    const isChecked = target.checked;
                                    this.toggleTaskCompletion(taskId, isChecked);
                                }
                            }
                            
                            // Edit task
                            if (target.closest('.pomodoro-task-edit')) {
                                const taskItem = target.closest('.pomodoro-task-item');
                                if (taskItem) {
                                    const taskId = taskItem.dataset.id;
                                    const taskTextEl = taskItem.querySelector('.pomodoro-task-text');
                                    if (taskId && taskTextEl) {
                                        this.editTask(taskId, taskTextEl);
                                    }
                                }
                            }
                            
                            // Delete task
                            if (target.closest('.pomodoro-task-delete')) {
                                const taskItem = target.closest('.pomodoro-task-item');
                                if (taskItem) {
                                    const taskId = taskItem.dataset.id;
                                    if (taskId) {
                                        if (confirm('Are you sure you want to delete this task?')) {
                                            this.deleteTask(taskId);
                                        }
                                    }
                                }
                            }
                        };
                        
                        // Add the event listener
                        tasksList.addEventListener('click', this.taskListClickHandler);
                    },
                    
                    // Update task display based on display preference
                    updateTaskDisplay: function() {
                        if (!this.popupWindow || this.popupWindow.closed) return;
                        
                        // Re-render tasks with current display preference
                        this.renderTasks();
                    },
                    
                    // Add a new task
                    // Updated function to cleanly add task
                    addTask: function() {
                        if (!this.popupWindow || this.popupWindow.closed) return;
                        
                        const popupDoc = this.popupWindow.document;
                        const newTaskInput = popupDoc.getElementById('new-task-input');
                        
                        if (!newTaskInput) return;
                        
                        const taskText = newTaskInput.value.trim();
                        if (!taskText) return;
                        
                        // Create task object
                        const task = {
                            id: this.generateTaskId(),
                            text: taskText,
                            completed: false,
                            subtasks: []
                        };
                        
                        // Initialize tasks array if needed
                        if (!this.taskData.tasks) {
                            this.taskData.tasks = [];
                        }
                        
                        // Add task
                        this.taskData.tasks.push(task);
                        
                        // Clear input
                        newTaskInput.value = '';
                        
                        // Update display
                        this.renderTasks();
                        
                        // Save data
                        this.saveData();
                    },

                    // Updated addSubtask with direct prompt - this is a critical fix
                    addSubtask: function(parentTaskId) {
                        if (!this.popupWindow || this.popupWindow.closed) return;
                        
                        const popupDoc = this.popupWindow.document;
                        
                        // Show prompt directly in the popup window
                        const subtaskText = this.popupWindow.prompt('Enter subtask:');
                        if (!subtaskText || !subtaskText.trim()) return;
                        
                        console.log("Adding subtask to parent ID:", parentTaskId);
                        
                        // Recursive function to find a task by ID
                        const findTaskById = (tasks, id) => {
                            if (!tasks) return null;
                            
                            for (let i = 0; i < tasks.length; i++) {
                                if (tasks[i].id === id) {
                                    return tasks[i];
                                }
                                
                                // Check subtasks recursively
                                if (tasks[i].subtasks && tasks[i].subtasks.length > 0) {
                                    const found = findTaskById(tasks[i].subtasks, id);
                                    if (found) return found;
                                }
                            }
                            
                            return null;
                        };
                        
                        // Find the parent task
                        const parentTask = findTaskById(this.taskData.tasks, parentTaskId);
                        if (!parentTask) {
                            console.error("Parent task not found:", parentTaskId);
                            return;
                        }
                        
                        // Initialize subtasks array if needed
                        if (!parentTask.subtasks) {
                            parentTask.subtasks = [];
                        }
                        
                        // Create subtask object
                        const subtask = {
                            id: this.generateTaskId(),
                            text: subtaskText.trim(),
                            completed: false,
                            subtasks: []
                        };
                        
                        // Add subtask to parent
                        parentTask.subtasks.push(subtask);
                        
                        // Update display
                        this.renderTasks();
                        
                        // Save data
                        this.saveData();
                        
                        console.log("Subtask added successfully");
                    },

                        // Toggle task/subtask expansion
                        toggleTaskExpansion: function(taskId) {
                            if (!this.popupWindow || this.popupWindow.closed) return;
                            
                            const popupDoc = this.popupWindow.document;
                            const taskItem = popupDoc.querySelector(`.pomodoro-task-item[data-id="${taskId}"]`);
                            
                            if (taskItem) {
                                taskItem.classList.toggle('pomodoro-collapsed');
                            }
                        },
                    
                    // Clear method to generate unique task IDs
                    generateTaskId: function() {
                        return `task-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
                    },
                    
                    // Updated toggleTaskCompletion with handling for subtasks
                    toggleTaskCompletion: function(taskId, isCompleted) {
                        // Function to toggle task and its subtasks
                        const updateTaskAndSubtasks = (tasks, id, completed) => {
                            if (!tasks) return false;
                            
                            for (let i = 0; i < tasks.length; i++) {
                                if (tasks[i].id === id) {
                                    // Update this task
                                    tasks[i].completed = completed;
                                    
                                    // Also update all subtasks to match parent state
                                    if (tasks[i].subtasks && tasks[i].subtasks.length > 0) {
                                        tasks[i].subtasks.forEach(subtask => {
                                            updateTaskAndSubtasks([subtask], subtask.id, completed);
                                        });
                                    }
                                    
                                    return true;
                                }
                                
                                // Check subtasks recursively
                                if (tasks[i].subtasks && tasks[i].subtasks.length > 0) {
                                    if (updateTaskAndSubtasks(tasks[i].subtasks, id, completed)) {
                                        return true;
                                    }
                                }
                            }
                            
                            return false;
                        };
                        
                        // Update task completion status
                        if (updateTaskAndSubtasks(this.taskData.tasks, taskId, isCompleted)) {
                            // Update display
                            this.renderTasks();
                            
                            // Save data
                            this.saveData();
                        }
                    },
                    
                    // First, let's fix the delete task function itself to make sure it works recursively
                    deleteTask: function(taskId) {
                        console.log("Attempting to delete task with ID:", taskId);
                        
                        // Recursive function to search and delete task at any level
                        const deleteTaskById = (tasks, id) => {
                            if (!tasks || !Array.isArray(tasks)) return false;
                            
                            for (let i = 0; i < tasks.length; i++) {
                                if (tasks[i].id === id) {
                                    // Found the task to delete
                                    console.log("Found task to delete at index", i);
                                    // Remove this task
                                    tasks.splice(i, 1);
                                    return true;
                                }
                                
                                // Check subtasks recursively
                                if (tasks[i].subtasks && Array.isArray(tasks[i].subtasks)) {
                                    if (deleteTaskById(tasks[i].subtasks, id)) {
                                        return true;
                                    }
                                }
                            }
                            
                            return false;
                        };
                        
                        // Delete the task
                        if (deleteTaskById(this.taskData.tasks, taskId)) {
                            console.log("Task deleted successfully");
                            // Update display
                            this.renderTasks();
                            
                            // Save data
                            this.saveData();
                        } else {
                            console.error("Failed to delete task:", taskId);
                        }
                    },
                    

                    // Updated editTask with better handling
                    editTask: function(taskId, taskTextElement) {
                        if (!this.popupWindow || !taskTextElement) return;
                        
                        const originalText = taskTextElement.textContent;
                        
                        // Create an input for editing
                        const inputEl = this.popupWindow.document.createElement('input');
                        inputEl.type = 'text';
                        inputEl.value = originalText;
                        inputEl.className = 'pomodoro-task-edit-input';
                        inputEl.style.width = '100%';
                        inputEl.style.padding = '5px';
                        inputEl.style.border = '1px solid #ddd';
                        inputEl.style.borderRadius = '4px';
                        
                        // Replace the text element with the input
                        taskTextElement.innerHTML = '';
                        taskTextElement.appendChild(inputEl);
                        
                        // Focus the input
                        inputEl.focus();
                        
                        // Function to find and update a task by ID
                        const findAndUpdateTask = (tasks, id, newText) => {
                            if (!tasks) return false;
                            
                            for (let i = 0; i < tasks.length; i++) {
                                if (tasks[i].id === id) {
                                    tasks[i].text = newText;
                                    return true;
                                }
                                
                                // Check subtasks recursively
                                if (tasks[i].subtasks && tasks[i].subtasks.length > 0) {
                                    if (findAndUpdateTask(tasks[i].subtasks, id, newText)) {
                                        return true;
                                    }
                                }
                            }
                            
                            return false;
                        };
                        
                        // Handle saving changes
                        const saveChanges = () => {
                            const newText = inputEl.value.trim();
                            
                            if (newText) {
                                // Find and update the task
                                if (findAndUpdateTask(this.taskData.tasks, taskId, newText)) {
                                    // Save data
                                    this.saveData();
                                }
                            }
                            
                            // Restore the text element with updated content
                            taskTextElement.textContent = newText || originalText;
                        };
                        
                        // Save on Enter or blur
                        inputEl.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') {
                                saveChanges();
                            } else if (e.key === 'Escape') {
                                taskTextElement.textContent = originalText;
                            }
                        });
                        
                        inputEl.addEventListener('blur', saveChanges);
                    }},

    
                
                //Integrate Fire Mode implementation
                    fire: {
                    name: 'Fire Mode',
                    originalContent: null, // Store original content with paragraph breaks
                    selectedSentences: [], // Store IDs of selected important sentences
                    sentenceElements: {}, // Store references to sentence elements by ID
                    stage: 'initial', // 'initial', 'selection', 'restructuring'
                    
                    // Activate Fire Mode
                    activate: function(options) {
                        // Store the original content first
                        this.originalContent = editor.innerHTML;
                        this.selectedSentences = [];
                        this.sentenceElements = {};
                        
                        // Apply the fiery background to the editor
                        this.applyFireBackground();
                        
                        // Skip the initial stage and go directly to sentence selection
                        this.stage = 'selection';
                        
                        // Make editor editable
                        editor.contentEditable = 'true';
                        
                        // Split text into selectable sentences
                        this.makeSentencesSelectable();
                        
                        // Set up mode-specific options in the toolbar
                        this.setupOptions();
                        
                        showNotification('Fire Mode enabled - Select your key sentences.');
                    },
                    
                    // Deactivate Fire Mode
                    deactivate: function() {
                        // Restore original content if needed
                        if (this.originalContent) {
                            editor.innerHTML = this.originalContent;
                        }
                        
                        // Remove fire background
                        this.removeFireBackground();
                        
                        // Remove the restructuring class
                        editor.classList.remove('fire-restructuring');
                        
                        // Cleanup Fire elements but retain the content structure
                        this.cleanupFireElements(true);
                        
                        // Stop the observer if it exists
                        if (this.observer) {
                            this.observer.disconnect();
                            this.observer = null;
                        }
                        
                        // Reset state
                        this.selectedSentences = [];
                        this.sentenceElements = {};
                        this.stage = 'initial';
                        
                        // Clear mode options
                        clearModeOptions();
                        
                        showNotification('Fire Mode disabled - Your original content has been restored.');
                    },
                    
                    // Return current options
                    getOptions: function() {
                        return {
                            stage: this.stage,
                            selectedCount: this.selectedSentences.length
                        };
                    },
                    
                    // Set up toolbar options for Fire Mode
                    setupOptions: function() {
                        // Clear existing options
                        clearModeOptions();
                        
                        // Create options based on current stage
                        if (this.stage === 'selection') {
                            // Add counter and stage indicator
                            const stageIndicator = document.createElement('div');
                            stageIndicator.className = 'fire-stage-indicator';
                            stageIndicator.innerHTML = '<i class="fas fa-fire"></i> Stage 1: Select key sentences';
                            activeModeOptions.appendChild(stageIndicator);
                            
                            // Add selection counter
                            const selectionCounter = document.createElement('div');
                            selectionCounter.id = 'fire-selection-counter';
                            selectionCounter.className = 'fire-counter';
                            selectionCounter.textContent = `${this.selectedSentences.length} sentences selected`;
                            activeModeOptions.appendChild(selectionCounter);
                            
                            // Add restore original button
                            const restoreBtn = document.createElement('button');
                            restoreBtn.className = 'toolbar-btn';
                            restoreBtn.innerHTML = '<i class="fas fa-undo"></i> Restore Original';
                            restoreBtn.addEventListener('click', () => {
                                if (confirm('Restore original paragraphs? This will exit Fire Mode.')) {
                                    this.deactivate();
                                    
                                    // Hide the mode indicator
                                    activeModeIndicator.classList.remove('visible');
                                    
                                    // Update global state
                                    currentMode = null;
                                    
                                    // Update card states
                                    updateModeCardStates();
                                }
                            });
                            
                            // Add next stage button
                            const nextStageBtn = document.createElement('button');
                            nextStageBtn.className = 'toolbar-btn';
                            nextStageBtn.innerHTML = 'Next Stage <i class="fas fa-arrow-right"></i>';
                            nextStageBtn.addEventListener('click', () => {
                                if (this.selectedSentences.length > 0) {
                                    this.moveToRestructuringStage();
                                } else {
                                    showNotification('Please select at least one key sentence before proceeding.', 'warning');
                                }
                            });
                            
                            // Create container for the buttons
                            const btnContainer = document.createElement('div');
                            btnContainer.className = 'toolbar-group';
                            btnContainer.appendChild(restoreBtn);
                            btnContainer.appendChild(nextStageBtn);
                            
                            // Add to options
                            activeModeOptions.appendChild(btnContainer);
                        }
                        else if (this.stage === 'restructuring') {
                            // Add counter and stage indicator
                            const stageIndicator = document.createElement('div');
                            stageIndicator.className = 'fire-stage-indicator';
                            stageIndicator.innerHTML = '<i class="fas fa-fire"></i> Stage 2: Restructure';
                            activeModeOptions.appendChild(stageIndicator);
                            
                            // Add simplified counter for selected sentences
                            const sentenceCounter = document.createElement('div');
                            sentenceCounter.id = 'fire-sentence-counter';
                            sentenceCounter.className = 'fire-counter';
                            const selectedCount = editor.querySelectorAll('.fire-sentence.fire-selected').length;
                            sentenceCounter.textContent = `${selectedCount} key sentences highlighted`;
                            activeModeOptions.appendChild(sentenceCounter);
                            
                            // Add previous stage button
                            const prevStageBtn = document.createElement('button');
                            prevStageBtn.className = 'toolbar-btn';
                            prevStageBtn.innerHTML = '<i class="fas fa-arrow-left"></i> Previous Stage';
                            prevStageBtn.addEventListener('click', () => {
                                this.stage = 'selection';
                                
                                // Convert back to selection stage
                                this.convertToBlock();
                                this.makeSentencesSelectable();
                                
                                // Update toolbar options
                                this.setupOptions();
                                
                                showNotification('Returned to sentence selection stage.');
                            });
                            
                            // Add finish button
                            const finishBtn = document.createElement('button');
                            finishBtn.className = 'toolbar-btn';
                            finishBtn.innerHTML = 'Finish <i class="fas fa-check"></i>';
                            finishBtn.addEventListener('click', () => {
                                if (confirm('Finish Fire Mode? Your current content will be saved.')) {
                                    // Remove highlights but keep the content
                                    this.cleanupFireElements(true);
                                    
                                    // Remove fire background
                                    this.removeFireBackground();
                                    
                                    // Hide the mode indicator
                                    activeModeIndicator.classList.remove('visible');
                                    
                                    // Update global state
                                    currentMode = null;
                                    
                                    // Update card states
                                    updateModeCardStates();
                                    
                                    // Save document
                                    DocumentManager.saveDocument();
                                    
                                    showNotification('Fire Mode completed. Your revised content has been saved.');
                                }
                            });
                            
                            // Create container for the buttons
                            const btnContainer = document.createElement('div');
                            btnContainer.className = 'toolbar-group';
                            btnContainer.appendChild(prevStageBtn);
                            btnContainer.appendChild(finishBtn);
                            
                            // Add to options
                            activeModeOptions.appendChild(btnContainer);
                        }
                    },
                    
                    // Apply a fiery background to the editor
                    applyFireBackground: function() {
                        // Add a fire background div
                        const fireBackground = document.createElement('div');
                        fireBackground.id = 'fire-mode-background';
                        fireBackground.className = 'fire-background';
                        
                        // Insert the background
                        const editorContent = document.querySelector('.editor-content');
                        editorContent.appendChild(fireBackground);
                        
                        // Add fire-mode class to editor for styling
                        editor.classList.add('fire-mode');
                        
                        // No inline CSS generation - rely on the external stylesheet
                    },
                    
                    // Remove the fire background
                    removeFireBackground: function() {
                        // Remove the background element
                        const fireBackground = document.getElementById('fire-mode-background');
                        if (fireBackground) {
                            fireBackground.remove();
                        }
                        
                        // Remove fire-mode class
                        editor.classList.remove('fire-mode');
                    },
                    
                    // Convert text to a single block by removing paragraph breaks
                    convertToBlock: function() {
                        // Get all block-level elements
                        const blockElements = editor.querySelectorAll('p, div, h1, h2, h3, h4, h5, h6');
                        
                        // Create a single paragraph to hold all content
                        const singleBlock = document.createElement('p');
                        
                        // Extract text content from each block and add to the single block
                        blockElements.forEach((block, index) => {
                            // If not the first block, add a space between blocks
                            if (index > 0) {
                                singleBlock.appendChild(document.createTextNode(' '));
                            }
                            
                            // Get all child nodes of the block
                            const childNodes = Array.from(block.childNodes);
                            
                            // Process each child node
                            childNodes.forEach(node => {
                                // If it's a text node, copy it directly
                                if (node.nodeType === Node.TEXT_NODE) {
                                    singleBlock.appendChild(document.createTextNode(node.textContent));
                                } 
                                // For element nodes like <strong>, <em>, etc., clone them
                                else if (node.nodeType === Node.ELEMENT_NODE) {
                                    // Skip <br> elements as they create line breaks
                                    if (node.tagName.toLowerCase() === 'br') {
                                        singleBlock.appendChild(document.createTextNode(' '));
                                    } else {
                                        const clone = node.cloneNode(true);
                                        singleBlock.appendChild(clone);
                                    }
                                }
                            });
                        });
                        
                        // Replace editor content with the single block
                        editor.innerHTML = '';
                        editor.appendChild(singleBlock);
                        
                        // Remove any line breaks that might remain
                        const text = singleBlock.innerHTML;
                        // Replace any remaining <br> or newlines with spaces
                        singleBlock.innerHTML = text.replace(/<br\s*\/?>/gi, ' ').replace(/\n/g, ' ');
                    },
                    
                    // Move to the sentence selection stage
                  // Modified moveToSelectionStage function to correctly call detectSentences with content
                    moveToSelectionStage: function() {
                        this.stage = 'selection';
                        
                        // Make editor editable
                        editor.contentEditable = 'true';
                        
                        // Get the content from the editor - this was missing!
                        const content = editor.innerText;
                        
                        // Split text into selectable sentences
                        this.makeSentencesSelectable();
                        
                        // Update toolbar options
                        this.setupOptions();
                        
                        showNotification('Select key sentences that best represent your work');
                    },

                    
                    // Move back to initial stage
                    moveToInitialStage: function() {
                        this.stage = 'initial';
                        
                        // Restore the block view without sentence selection
                        this.convertToBlock();
                        
                        // Update toolbar options
                        this.setupOptions();
                    },
                    
                    // Move to restructuring stage
                    moveToRestructuringStage: function() {
                        this.stage = 'restructuring';
                        
                        // Restore paragraph breaks
                        this.restoreParagraphs();
                        
                        // Add a class to indicate restructuring mode - this will trigger CSS rules
                        editor.classList.add('fire-restructuring');
                        
                        // Make content fully editable
                        editor.contentEditable = 'true';
                        
                        // Update toolbar options
                        this.setupOptions();
                        
                        showNotification('Restructure your text. Position key sentences for maximum impact.');
                    },

                

                    //Detect sentences in block 
                    detectSentences: function(text) {
                        // First, protect special patterns that should not be split
                        let processedText = text;
                        
                        // Protect quotations by temporarily replacing end punctuation inside quotes
                        processedText = processedText.replace(/(['"])([^'"]*?[.!?])(['"])/g, 
                            (match, open, content, close) => {
                                // Replace ending punctuation with a special marker
                                return open + content.replace(/[.!?]/g, '___QUOTE_PUNCT___') + close;
                            }
                        );
                        
                        // Protect common abbreviations
                        const abbreviations = [
                            'Dr', 'Mr', 'Mrs', 'Ms', 'Prof', 'Inc', 'Ltd', 'Co', 'etc', 'i.e', 'e.g', 
                            'vs', 'Jan', 'Feb', 'Mar', 'Apr', 'Jun', 'Jul', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'
                        ];
                        
                        for (const abbr of abbreviations) {
                            const regex = new RegExp(`\\b${abbr}\\.`, 'gi');
                            processedText = processedText.replace(regex, match => 
                                match.replace('.', '___ABBR_DOT___')
                            );
                        }
                        
                        // Protect ellipses
                        processedText = processedText.replace(/\.{3,}/g, '___ELLIPSIS___');
                        
                        // Now split by sentence endings
                        const sentenceEndings = /([.!?])\s+(?=[A-Z])/g;
                        let sentences = processedText.split(sentenceEndings);
                        
                        // Process the split results to reconstruct sentences with their endings
                        const result = [];
                        for (let i = 0; i < sentences.length; i += 2) {
                            if (i + 1 < sentences.length) {
                                result.push(sentences[i] + sentences[i + 1]);
                            } else {
                                result.push(sentences[i]);
                            }
                        }
                        
                        // Process the last sentence if it doesn't end with punctuation
                        if (result.length > 0) {
                            const lastSentence = result[result.length - 1];
                            if (!lastSentence.match(/[.!?]$/)) {
                                // Find any remaining text and add it
                                const remaining = text.slice(text.lastIndexOf(lastSentence) + lastSentence.length);
                                if (remaining.trim()) {
                                    result[result.length - 1] += remaining;
                                }
                            }
                        }
                        
                        // Restore protected patterns
                        return result.map(sentence => {
                            return sentence
                                .replace(/___QUOTE_PUNCT___/g, '.')
                                .replace(/___ABBR_DOT___/g, '.')
                                .replace(/___ELLIPSIS___/g, '...')
                                .trim();
                        }).filter(s => s.length > 0);
                    },
                    
                    // Make sentences selectable by wrapping them in spans
                    // Also, replacing the makeSentencesSelectable method to avoid calling detectSentences directly
                    makeSentencesSelectable: function() {
                        // Get all content
                        const content = editor.innerText;
                        
                        // Create a new paragraph to hold the selectable sentences
                        const newPara = document.createElement('p');
                        
                        // Use the improved sentence detection
                        const sentences = this.detectSentences(content);
                        
                        // Reset sentence elements
                        this.sentenceElements = {};
                        
                        // Create spans for each detected sentence
                        sentences.forEach((sentence, sentenceId) => {
                            // Create a span for the sentence
                            const sentenceSpan = document.createElement('span');
                            sentenceSpan.className = 'fire-sentence';
                            sentenceSpan.textContent = sentence;
                            sentenceSpan.dataset.sentenceId = sentenceId;
                            
                            // Store reference to the element
                            this.sentenceElements[sentenceId] = sentenceSpan;
                            
                            // Add click handler for selection
                            sentenceSpan.addEventListener('click', (e) => {
                                this.toggleSentenceSelection(e.target);
                            });
                            
                            // Check if this sentence was previously selected
                            if (this.selectedSentences.includes(sentenceId.toString())) {
                                sentenceSpan.classList.add('fire-selected');
                            }
                            
                            // Add space between sentences
                            if (sentenceId > 0) {
                                newPara.appendChild(document.createTextNode(' '));
                            }
                            
                            // Add the sentence span
                            newPara.appendChild(sentenceSpan);
                        });
                        
                        // Replace editor content
                        editor.innerHTML = '';
                        editor.appendChild(newPara);
                    },
                    
                    // Toggle the selection of a sentence
                    toggleSentenceSelection: function(sentenceElement) {
                        const sentenceId = sentenceElement.dataset.sentenceId;
                        
                        if (sentenceElement.classList.contains('fire-selected')) {
                            // Deselect the sentence
                            sentenceElement.classList.remove('fire-selected');
                            
                            // Remove from selectedSentences array
                            const index = this.selectedSentences.indexOf(sentenceId);
                            if (index !== -1) {
                                this.selectedSentences.splice(index, 1);
                            }
                        } else {
                            // Select the sentence
                            sentenceElement.classList.add('fire-selected');
                            
                            // Add to selectedSentences array
                            if (!this.selectedSentences.includes(sentenceId)) {
                                this.selectedSentences.push(sentenceId);
                            }
                        }
                        
                        // Update the counter
                        const counter = document.getElementById('fire-selection-counter');
                        if (counter) {
                            counter.textContent = `${this.selectedSentences.length} sentences selected`;
                        }
                    },
                    
                    // Restore paragraph breaks using the original content
                   restoreParagraphs: function() {
                        // Store the texts of selected sentences for later highlighting
                        const selectedSentenceTexts = this.selectedSentences.map(id => 
                            this.sentenceElements[id] ? this.sentenceElements[id].textContent.trim() : ''
                        ).filter(text => text); // Filter out any empty strings
                        
                        // Restore the paragraphs
                        editor.innerHTML = this.originalContent;
                        
                        // After restoring paragraphs, re-identify sentences and highlight selected ones
                        this.highlightSelectedSentences(selectedSentenceTexts);
                    },
                    
                    // Highlight selected sentences after restoring paragraphs
                    highlightSelectedSentences: function(selectedTexts) {
                        // Create a set of selected texts for faster lookup
                        const selectedSentenceSet = new Set(selectedTexts);
                        
                        // Get all paragraph-like elements
                        const paragraphs = editor.querySelectorAll('p, div, h1, h2, h3, h4, h5, h6');
                        
                        // Process each paragraph to find and highlight sentences
                        paragraphs.forEach(paragraph => {
                            // Process the paragraph's content
                            const processNode = (node) => {
                                if (node.nodeType === Node.TEXT_NODE) {
                                    // Process text node to find sentences
                                    const text = node.textContent;
                                    let processedText = '';
                                    let lastTextIndex = 0;
                                    
                                    // Use the sentence detection regex
                                    const sentenceRegex = /([^.!?]+[.!?]+)/g;
                                    
                                    // Find all sentences in this text node
                                    let match;
                                    while ((match = sentenceRegex.exec(text)) !== null) {
                                        // Add text before the sentence
                                        processedText += text.substring(lastTextIndex, match.index);
                                        
                                        // Get the sentence text
                                        const sentenceText = match[0].trim();
                                        
                                        // Check if this is a selected sentence
                                        const isSelected = selectedSentenceSet.has(sentenceText);
                                        
                                        // Add the sentence with appropriate class
                                        if (isSelected) {
                                            processedText += `<span class="fire-sentence fire-selected">${match[0]}</span>`;
                                        } else {
                                            processedText += `<span class="fire-sentence">${match[0]}</span>`;
                                        }
                                        
                                        lastTextIndex = match.index + match[0].length;
                                    }
                                    
                                    // Add any remaining text
                                    processedText += text.substring(lastTextIndex);
                                    
                                    // Create a new HTML element with the processed text
                                    const newNode = document.createElement('span');
                                    newNode.innerHTML = processedText;
                                    node.parentNode.replaceChild(newNode, node);
                                } else if (node.nodeType === Node.ELEMENT_NODE) {
                                    // Skip certain elements that shouldn't be processed
                                    if (node.tagName === 'SCRIPT' || node.tagName === 'STYLE' || 
                                        node.classList.contains('fire-sentence')) {
                                        return;
                                    }
                                    
                                    // Process child nodes recursively
                                    Array.from(node.childNodes).forEach(processNode);
                                }
                            };
                            
                            // Process the paragraph
                            Array.from(paragraph.childNodes).forEach(processNode);
                        });
                        
                        // Make sure editor is editable
                        editor.contentEditable = 'true';
                    },
                    
                    highlightTargetPositions: function() {
                        // This function is now simplified - we don't track target positions anymore
                        // We just need to start monitoring for changes to update the display
                        this.startSentenceMonitoring();
                    },
                    
                  
                    
                   //Update the monitoring function to just track selected sentences
                    startSentenceMonitoring: function() {
                        // Create a MutationObserver to watch for DOM changes
                        const observer = new MutationObserver(() => {
                            // Simply ensure selected sentences stay highlighted
                            const selectedSentences = editor.querySelectorAll('.fire-sentence.fire-selected');
                            
                            // Update the UI to show count of highlighted sentences
                            const counter = document.getElementById('fire-sentence-counter');
                            if (counter) {
                                counter.textContent = `${selectedSentences.length} key sentences highlighted`;
                            }
                        });
                        
                        // Start observing the editor
                        observer.observe(editor, { 
                            childList: true, 
                            subtree: true, 
                            characterData: true 
                        });
                        
                        // Store the observer for cleanup
                        this.observer = observer;
                    },
                    
                    // Clean up Fire Mode specific elements/classes
                    cleanupFireElements: function(keepContent = false) {
                        // Stop the observer if it exists
                        if (this.observer) {
                            this.observer.disconnect();
                            this.observer = null;
                        }
                        
                        if (!keepContent) {
                            // If not keeping content, we've already restored original in deactivate
                            return;
                        }
                        
                        // If keeping content, remove fire-specific classes but keep structure
                        const fireSentences = editor.querySelectorAll('.fire-sentence');
                        fireSentences.forEach(sentence => {
                            // Create a text node with the sentence content
                            const textNode = document.createTextNode(sentence.textContent);
                            
                            // Replace the sentence element with the text node
                            sentence.parentNode.replaceChild(textNode, sentence);
                        });
                        
                        // Normalize the DOM to join adjacent text nodes
                        editor.normalize();
                    }
                },
                


                    meta: {
                        name: 'Meta Mode',
                        originalContent: null,
                        paragraphData: {}, // Will store says/does data for paragraphs
                        currentParagraphIndex: 0,
                        paragraphs: [], // Will store parsed paragraphs
                        modalElement: null, // Add this to store the modal reference
                        
                        // Method to activate Meta Mode
                        activate: function(options) {
                            // Store the original content
                            this.originalContent = editor.innerHTML;
                            
                            // Parse paragraphs from original content
                            this.parseParagraphs();
                            
                            // Make sure we have paragraphs
                            if (this.paragraphs.length === 0) {
                                showNotification('No paragraphs found in document', 'warning');
                                return;
                            }
                            
                            console.log("Parsed paragraphs:", this.paragraphs); // Debug log
                            
                            // Reset current paragraph index
                            this.currentParagraphIndex = 0;
                            
                            // Load saved data if it exists for the current document
                            this.loadSavedData();
                            
                            // Create and show the improved Meta Mode modal
                            this.createImprovedMetaModal();
                            
                            // Set up mode-specific options in the toolbar
                            this.setupOptions();
                            
                            showNotification('Meta Mode enabled - Analyze what each paragraph says and does');
                        },
                        
                        // Method to deactivate Meta Mode
                        deactivate: function() {
                            // Save current meta analysis before deactivating
                            this.saveMetaAnalysis();
                            
                            // Remove the modal if it exists
                            if (this.modalElement) {
                                document.body.removeChild(this.modalElement);
                                this.modalElement = null;
                            }
                            
                            // Remove any event handlers we added
                            document.removeEventListener('keydown', this.handleEscapeKey);
                            
                            // Clear mode options
                            clearModeOptions();
                            
                            showNotification('Meta Mode disabled - Your analysis has been saved');
                        },
                        
                        // Handle Escape key press
                        handleEscapeKey: function(e) {
                            if (e.key === 'Escape' && currentMode === 'meta') {
                                modes.meta.saveCurrentParagraphData();
                                disableCurrentMode(false);
                            }
                        },
                        
                        // Parse paragraphs from the original content
                        parseParagraphs: function() {
                            // Reset paragraphs array
                            this.paragraphs = [];
                            
                            // Create a temporary div to parse the HTML
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = this.originalContent;
                            
                            // Get all paragraph-like elements
                            const paragraphElements = tempDiv.querySelectorAll('p, div:not(.editor-content):not(.platform-container), h1, h2, h3, h4, h5, h6');
                            
                            // Filter out empty paragraphs and store the rest
                            paragraphElements.forEach((p, index) => {
                                if (p.textContent.trim()) {
                                    this.paragraphs.push({
                                        html: p.innerHTML,
                                        text: p.textContent.trim(),
                                        tagName: p.tagName.toLowerCase(),
                                        index: index // Keep track of the original index
                                    });
                                }
                            });
                            
                            console.log(`Found ${this.paragraphs.length} paragraphs`); // Debug log
                        },
                        
                        // Get options for toolbar
                        getOptions: function() {
                            return {
                                paragraphCount: this.paragraphs.length,
                                currentIndex: this.currentParagraphIndex,
                                analyzedCount: this.getAnalyzedCount()
                            };
                        },
                        
                        // Setup options in toolbar
                        setupOptions: function() {
                            // Clear existing options
                            clearModeOptions();
                            
                            // Create progress counter
                            const progress = document.createElement('span');
                            progress.className = 'mode-option-label';
                            progress.id = 'meta-progress-indicator';
                            progress.style.marginRight = '15px';
                            this.updateProgressIndicator(progress);
                            
                            // Add to options
                            activeModeOptions.appendChild(progress);
                        },
                        
                        // Update progress indicator in toolbar
                        updateProgressIndicator: function(element) {
                            const analyzed = this.getAnalyzedCount();
                            const total = this.paragraphs.length;
                            const current = this.currentParagraphIndex + 1;
                            
                            if (element) {
                                element.textContent = `Paragraph ${current}/${total} (${analyzed} analyzed)`;
                                
                                // Add color indication based on progress
                                if (analyzed === 0) {
                                    element.style.color = '#f44336'; // Red
                                } else if (analyzed < total) {
                                    element.style.color = '#ff9800'; // Orange
                                } else {
                                    element.style.color = '#4caf50'; // Green
                                }
                            }
                        },
                        
                        // Create an improved Meta Mode modal without nested scrollbars
                        createImprovedMetaModal: function() {
                            // Create modal backdrop (full screen)
                            const modalBackdrop = document.createElement('div');
                            modalBackdrop.className = 'reader-modal-backdrop';
                            modalBackdrop.style.zIndex = '2000';
                            
                            // Create the main modal
                            const modal = document.createElement('div');
                            modal.className = 'reader-modal';
                            modal.style.maxWidth = '90%';
                            modal.style.width = '1200px'; // Wider to accommodate three columns
                            modal.style.height = '90%'; // Take most of the screen height
                            modal.style.display = 'flex';
                            modal.style.flexDirection = 'column';
                            
                            // Simple header
                            const modalHeader = document.createElement('div');
                            modalHeader.className = 'reader-modal-header';
                            modalHeader.style.flexShrink = '0'; // Don't shrink header
                            
                            const modalTitle = document.createElement('h3');
                            modalTitle.textContent = 'Meta Mode';
                            
                            const statusText = document.createElement('div');
                            statusText.id = 'meta-status-text';
                            statusText.style.marginLeft = 'auto';
                            statusText.style.marginRight = '15px';
                            statusText.textContent = `Paragraph ${this.currentParagraphIndex + 1} of ${this.paragraphs.length}`;
                            
                            const closeButton = document.createElement('button');
                            closeButton.className = 'reader-modal-close';
                            closeButton.innerHTML = '&times;';
                            closeButton.setAttribute('aria-label', 'Close Meta Mode');
                            closeButton.addEventListener('click', () => {
                                this.saveMetaAnalysis();
                                disableCurrentMode(false);
                            });
                            
                            modalHeader.appendChild(modalTitle);
                            modalHeader.appendChild(statusText);
                            modalHeader.appendChild(closeButton);
                            
                            // Create a single content area - no nested scrolling
                            const contentArea = document.createElement('div');
                            contentArea.style.flex = '1'; // Take all available space
                            contentArea.style.display = 'flex'; // For the three columns
                            contentArea.style.position = 'relative'; // For absolute positioning
                            contentArea.style.minHeight = '0'; // Allow flex items to shrink below content size
                            
                            // Create three-column container
                            const columnContainer = document.createElement('div');
                            columnContainer.style.display = 'flex';
                            columnContainer.style.width = '100%';
                            columnContainer.style.height = '100%';
                            columnContainer.style.padding = '20px';
                            
                            // Create "Says" column - fixed width
                            const saysColumn = document.createElement('div');
                            saysColumn.style.width = '25%';
                            saysColumn.style.marginRight = '15px';
                            saysColumn.style.display = 'flex';
                            saysColumn.style.flexDirection = 'column';
                            
                            const saysHeading = document.createElement('div');
                            saysHeading.style.padding = '10px 0';
                            saysHeading.style.marginBottom = '10px';
                            saysHeading.style.fontWeight = 'bold';
                            saysHeading.style.color = '#57068c'; // Purple
                            saysHeading.innerHTML = '<i class="fas fa-quote-left"></i> Says (Content)';
                            
                            const saysTextarea = document.createElement('textarea');
                            saysTextarea.id = 'meta-says-textarea';
                            saysTextarea.style.flex = '1'; // Take remaining space
                            saysTextarea.style.resize = 'none'; // Prevent user resizing
                            saysTextarea.style.padding = '10px';
                            saysTextarea.style.border = '1px solid #ddd';
                            saysTextarea.style.borderRadius = '5px';
                            saysTextarea.style.backgroundColor = '#f9f9f9';
                            saysTextarea.placeholder = 'What is the main content or meaning?';
                            
                            // Fill with saved data if available
                            if (this.paragraphData[this.currentParagraphIndex] && 
                                this.paragraphData[this.currentParagraphIndex].says) {
                                saysTextarea.value = this.paragraphData[this.currentParagraphIndex].says;
                            }
                            
                            saysColumn.appendChild(saysHeading);
                            saysColumn.appendChild(saysTextarea);
                            
                            // Create paragraph column - takes most space
                            const paraColumn = document.createElement('div');
                            paraColumn.style.width = '50%';
                            paraColumn.style.marginRight = '15px';
                            paraColumn.style.display = 'flex';
                            paraColumn.style.flexDirection = 'column';
                            
                            const paraHeading = document.createElement('div');
                            paraHeading.style.padding = '10px 0';
                            paraHeading.style.marginBottom = '10px';
                            paraHeading.style.fontWeight = 'bold';
                            paraHeading.style.color = '#57068c'; // Purple
                            paraHeading.innerHTML = '<i class="fas fa-paragraph"></i> Paragraph';
                            
                            const paraContent = document.createElement('div');
                            paraContent.id = 'meta-paragraph-content';
                            paraContent.style.flex = '1'; // Take remaining space
                            paraContent.style.padding = '10px';
                            paraContent.style.border = '1px solid #ddd';
                            paraContent.style.borderRadius = '5px';
                            paraContent.style.backgroundColor = '#fff';
                            paraContent.style.overflowY = 'auto'; // Single scrollbar here if needed
                            
                            // Add paragraph content - with debug info
                            if (this.paragraphs.length > 0 && this.paragraphs[this.currentParagraphIndex]) {
                                console.log("Displaying paragraph:", this.currentParagraphIndex, this.paragraphs[this.currentParagraphIndex]);
                                paraContent.innerHTML = this.paragraphs[this.currentParagraphIndex].html;
                            } else {
                                paraContent.innerHTML = "<p>No paragraph content available.</p>";
                                console.error("No paragraph content found for index:", this.currentParagraphIndex);
                            }
                            
                            paraColumn.appendChild(paraHeading);
                            paraColumn.appendChild(paraContent);
                            
                            // Create "Does" column - fixed width
                            const doesColumn = document.createElement('div');
                            doesColumn.style.width = '25%';
                            doesColumn.style.display = 'flex';
                            doesColumn.style.flexDirection = 'column';
                            
                            const doesHeading = document.createElement('div');
                            doesHeading.style.padding = '10px 0';
                            doesHeading.style.marginBottom = '10px';
                            doesHeading.style.fontWeight = 'bold';
                            doesHeading.style.color = '#57068c'; // Purple
                            doesHeading.innerHTML = '<i class="fas fa-cogs"></i> Does (Function)';
                            
                            const doesTextarea = document.createElement('textarea');
                            doesTextarea.id = 'meta-does-textarea';
                            doesTextarea.style.flex = '1'; // Take remaining space
                            doesTextarea.style.resize = 'none'; // Prevent user resizing
                            doesTextarea.style.padding = '10px';
                            doesTextarea.style.border = '1px solid #ddd';
                            doesTextarea.style.borderRadius = '5px';
                            doesTextarea.style.backgroundColor = '#f9f9f9';
                            doesTextarea.placeholder = 'What function does this serve?';
                            
                            // Fill with saved data if available
                            if (this.paragraphData[this.currentParagraphIndex] && 
                                this.paragraphData[this.currentParagraphIndex].does) {
                                doesTextarea.value = this.paragraphData[this.currentParagraphIndex].does;
                            }
                            
                            doesColumn.appendChild(doesHeading);
                            doesColumn.appendChild(doesTextarea);
                            
                            // Assemble the columns
                            columnContainer.appendChild(saysColumn);
                            columnContainer.appendChild(paraColumn);
                            columnContainer.appendChild(doesColumn);
                            
                            contentArea.appendChild(columnContainer);
                            
                            // Create button container
                            const buttonContainer = document.createElement('div');
                            buttonContainer.style.display = 'flex';
                            buttonContainer.style.justifyContent = 'space-between';
                            buttonContainer.style.padding = '15px 20px';
                            buttonContainer.style.borderTop = '1px solid #eee';
                            buttonContainer.style.flexShrink = '0'; // Don't shrink button area
                            
                            // Previous button
                            const prevButton = document.createElement('button');
                            prevButton.id = 'meta-prev-button';
                            prevButton.className = 'reader-footer-button secondary';
                            prevButton.innerHTML = '<i class="fas fa-arrow-left"></i> Previous';
                            prevButton.disabled = this.currentParagraphIndex === 0;
                            prevButton.addEventListener('click', () => {
                                this.navigateToPrevious();
                            });
                            
                            // Create a center group for export button
                            const centerGroup = document.createElement('div');
                            
                            const exportButton = document.createElement('button');
                            exportButton.className = 'reader-footer-button secondary';
                            exportButton.innerHTML = '<i class="fas fa-file-export"></i> Export Analysis';
                            exportButton.addEventListener('click', () => {
                                this.saveCurrentParagraphData();
                                this.exportAnalysis();
                            });
                            
                            centerGroup.appendChild(exportButton);
                            
                            // Next button
                            const nextButton = document.createElement('button');
                            nextButton.id = 'meta-next-button';
                            nextButton.className = 'reader-footer-button secondary';
                            nextButton.innerHTML = 'Next <i class="fas fa-arrow-right"></i>';
                            nextButton.disabled = this.currentParagraphIndex === this.paragraphs.length - 1;
                            nextButton.addEventListener('click', () => {
                                this.navigateToNext();
                            });
                            
                            buttonContainer.appendChild(prevButton);
                            buttonContainer.appendChild(centerGroup);
                            buttonContainer.appendChild(nextButton);
                            
                            // Assemble modal
                            modal.appendChild(modalHeader);
                            modal.appendChild(contentArea);
                            modal.appendChild(buttonContainer);
                            
                            modalBackdrop.appendChild(modal);
                            document.body.appendChild(modalBackdrop);
                            
                            // Store the modal element for later cleanup
                            this.modalElement = modalBackdrop;
                            
                            // Add event listeners to save data as user types
                            saysTextarea.addEventListener('input', () => {
                                this.saveTextareaValue(this.currentParagraphIndex, 'says', saysTextarea.value);
                                this.updateProgressIndicator(document.getElementById('meta-progress-indicator'));
                            });
                            
                            doesTextarea.addEventListener('input', () => {
                                this.saveTextareaValue(this.currentParagraphIndex, 'does', doesTextarea.value);
                                this.updateProgressIndicator(document.getElementById('meta-progress-indicator'));
                            });
                            
                            // Focus on "says" textarea
                            setTimeout(() => {
                                saysTextarea.focus();
                            }, 100);
                            
                            // Add keyboard event listener for Escape key
                            this.handleEscapeKey = this.handleEscapeKey.bind(this);
                            document.addEventListener('keydown', this.handleEscapeKey);
                        },
                        
                        // Save the current paragraph data
                        saveCurrentParagraphData: function() {
                            const saysTextarea = document.getElementById('meta-says-textarea');
                            const doesTextarea = document.getElementById('meta-does-textarea');
                            
                            if (saysTextarea && doesTextarea) {
                                this.saveTextareaValue(this.currentParagraphIndex, 'says', saysTextarea.value);
                                this.saveTextareaValue(this.currentParagraphIndex, 'does', doesTextarea.value);
                            }
                        },
                        
                        // Navigate to previous paragraph
                        navigateToPrevious: function() {
                            if (this.currentParagraphIndex > 0) {
                                // Save current paragraph data
                                this.saveCurrentParagraphData();
                                
                                // Decrement index
                                this.currentParagraphIndex--;
                                
                                // Update UI with new paragraph content
                                this.updateModalContent();
                            }
                        },
                        
                        // Navigate to next paragraph
                        navigateToNext: function() {
                            if (this.currentParagraphIndex < this.paragraphs.length - 1) {
                                // Save current paragraph data
                                this.saveCurrentParagraphData();
                                
                                // Increment index
                                this.currentParagraphIndex++;
                                
                                // Update UI with new paragraph content
                                this.updateModalContent();
                            }
                        },
                        
                        // Update modal content based on current paragraph index
                        updateModalContent: function() {
                            // Update paragraph content
                            const paraContent = document.getElementById('meta-paragraph-content');
                            const saysTextarea = document.getElementById('meta-says-textarea');
                            const doesTextarea = document.getElementById('meta-does-textarea');
                            const statusText = document.getElementById('meta-status-text');
                            const prevButton = document.getElementById('meta-prev-button');
                            const nextButton = document.getElementById('meta-next-button');
                            
                            // Debug log
                            console.log("Updating to paragraph:", this.currentParagraphIndex, 
                                    "Total paragraphs:", this.paragraphs.length,
                                    "Current paragraph:", this.paragraphs[this.currentParagraphIndex]);
                            
                            // Update paragraph content
                            if (paraContent && this.paragraphs[this.currentParagraphIndex]) {
                                paraContent.innerHTML = this.paragraphs[this.currentParagraphIndex].html;
                            }
                            
                            // Update textareas
                            if (saysTextarea) {
                                saysTextarea.value = this.paragraphData[this.currentParagraphIndex]?.says || '';
                                saysTextarea.focus();
                            }
                            
                            if (doesTextarea) {
                                doesTextarea.value = this.paragraphData[this.currentParagraphIndex]?.does || '';
                            }
                            
                            // Update status text
                            if (statusText) {
                                statusText.textContent = `Paragraph ${this.currentParagraphIndex + 1} of ${this.paragraphs.length}`;
                            }
                            
                            // Update navigation buttons
                            if (prevButton) {
                                prevButton.disabled = this.currentParagraphIndex === 0;
                            }
                            
                            if (nextButton) {
                                nextButton.disabled = this.currentParagraphIndex === this.paragraphs.length - 1;
                            }
                            
                            // Update toolbar indicator
                            this.updateProgressIndicator(document.getElementById('meta-progress-indicator'));
                        },
                        
                        // Save textarea value to data structure
                        saveTextareaValue: function(index, type, value) {
                            // Initialize paragraph data object if needed
                            if (!this.paragraphData[index]) {
                                this.paragraphData[index] = {};
                            }
                            
                            // Save the value
                            this.paragraphData[index][type] = value;
                            
                            // Mark document as having unsaved changes
                            if (DocumentManager) {
                                DocumentManager.hasUnsavedChanges = true;
                            }
                        },
                        
                        // Calculate how many paragraphs have been analyzed
                        getAnalyzedCount: function() {
                            let count = 0;
                            
                            // Count paragraphs that have both says and does filled out
                            Object.values(this.paragraphData).forEach(para => {
                                if (para.says && para.does && para.says.trim() && para.does.trim()) {
                                    count++;
                                }
                            });
                            
                            return count;
                        },
                        
                        // Load saved data if available
                        loadSavedData: function() {
                            // Reset paragraph data
                            this.paragraphData = {};
                            
                            // Check if current document has meta analysis data
                            if (DocumentManager.currentDocument && DocumentManager.currentDocument.metaAnalysis) {
                                this.paragraphData = DocumentManager.currentDocument.metaAnalysis;
                            }
                        },
                        
                        // Save meta analysis to the current document
                        saveMetaAnalysis: function() {
                            // Save current paragraph data first
                            this.saveCurrentParagraphData();
                            
                            if (!DocumentManager.currentDocument) return;
                            
                            // Save analysis data to the document
                            DocumentManager.currentDocument.metaAnalysis = this.paragraphData;
                            
                            // Save the document to persist changes
                            DocumentManager.saveDocument();
                        },
                        
                        // Export the analysis as a document
                        exportAnalysis: function() {
                            // Create a new document with the analysis
                            const title = (DocumentManager.currentDocument?.title || 'Untitled') + ' - Says/Does Analysis';
                            
                            // Prepare content for the new document
                            let content = '<h1>Says/Does Analysis</h1>';
                            content += `<h2>${DocumentManager.currentDocument?.title || 'Untitled Document'}</h2>`;
                            content += '<p>This outline analyzes what each paragraph says (content) and does (function).</p>';
                            
                            // Create a table for the analysis
                            content += '<table style="width:100%; border-collapse: collapse; margin-top: 20px;">';
                            content += '<tr style="background-color: #f2f2f2;">';
                            content += '<th style="border: 1px solid #ddd; padding: 8px; text-align: left;">¶</th>';
                            content += '<th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Says (Content)</th>';
                            content += '<th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Does (Function)</th>';
                            content += '</tr>';
                            
                            // Add each paragraph's analysis to the table
                            this.paragraphs.forEach((paragraph, index) => {
                                const says = this.paragraphData[index]?.says || '';
                                const does = this.paragraphData[index]?.does || '';
                                
                                content += '<tr>';
                                content += `<td style="border: 1px solid #ddd; padding: 8px;">${index + 1}</td>`;
                                content += `<td style="border: 1px solid #ddd; padding: 8px;">${says}</td>`;
                                content += `<td style="border: 1px solid #ddd; padding: 8px;">${does}</td>`;
                                content += '</tr>';
                            });
                            
                            content += '</table>';
                            
                            // Create new document with this content
                            const docId = DocumentManager.createNewDocument(title, '');
                            
                            // Find the new document and update its content
                            const newDoc = DocumentManager.documents.find(doc => doc.id === docId);
                            if (newDoc) {
                                newDoc.content = content;
                                DocumentManager.saveDocument();
                                
                                // Show notification
                                showNotification('Analysis exported to a new document');
                            }
                        }
                    },



                // Add Audience Perspective Mode to the modes object
                audience: {
                    name: 'Audience Perspective Mode',
                        originalContent: null,
                        annotationData: {}, // Will store annotations for different reader perspectives
                        currentPersona: 'expert', // Default selected persona
                        
                        // Method to activate Audience Perspective Mode
                        activate: function(options) {
                            // Store the original content
                            this.originalContent = editor.innerHTML;
                            
                            // Load saved data if it exists for the current document
                            this.loadSavedData();
                            
                            // Transform the document into Audience Perspective Mode view
                            this.transformToAudienceView();
                            
                            // Make editor editable but with special handling
                            editor.contentEditable = 'true';
                            
                            // Add audience-mode class to editor
                            editor.classList.add('audience-mode');
                            
                            // Set up event delegation for the mode interactions
                            this.setupEventHandlers();
                            
                            // Set up mode-specific options in the toolbar
                            this.setupOptions();
                            
                            showNotification('Audience Perspective Mode enabled - Highlight text to add persona comments');
                        },
                        
                        // Method to deactivate Audience Perspective Mode
                        deactivate: function() {
                            // Save current annotations before deactivating
                            this.saveAnnotations();
                            
                            // Restore original content
                            if (this.originalContent) {
                                editor.innerHTML = this.originalContent;
                            }
                            
                            // Remove audience-mode class
                            editor.classList.remove('audience-mode');
                            
                            // Remove event handlers
                            this.removeEventHandlers();
                            
                            // Clear any annotation-related elements from the DOM
                            this.clearAnnotationElements();
                            
                            // Clear mode options
                            clearModeOptions();
                            
                            showNotification('Audience Perspective Mode disabled - Your annotations have been saved');
                        },
                        
                        // Get current options
                        getOptions: function() {
                            return {
                                personaCount: 5,
                                currentPersona: this.currentPersona,
                                annotationCount: this.getAnnotationCount()
                            };
                        },
                        
                        // Set up toolbar options for Audience Perspective Mode
                        setupOptions: function() {
                            // Clear existing options
                            clearModeOptions();
                            
                            // Create persona selector dropdown
                            const personaSelector = document.createElement('select');
                            personaSelector.className = 'toolbar-selector';
                            personaSelector.id = 'audience-persona-selector';
                            personaSelector.setAttribute('aria-label', 'Select reader persona');
                            
                            // Add options for each persona
                            const personas = [
                                { value: 'expert', label: 'Expert Reader' },
                                { value: 'novice', label: 'Novice Reader' },
                                { value: 'skeptical', label: 'Skeptical Reader' },
                                { value: 'timeconstrained', label: 'Time-Constrained Reader' },
                                { value: 'generous', label: 'Generous Reader' }
                            ];
                            
                            personas.forEach(persona => {
                                const option = document.createElement('option');
                                option.value = persona.value;
                                option.textContent = persona.label;
                                personaSelector.appendChild(option);
                            });
                            
                            // Set current persona
                            personaSelector.value = this.currentPersona;
                            
                            // Persona selector event handler
                            personaSelector.addEventListener('change', (e) => {
                                this.currentPersona = e.target.value;
                                this.updatePersonaGuidance();
                            });
                            
                            // Create clear annotations button
                            const clearButton = document.createElement('button');
                            clearButton.className = 'toolbar-btn';
                            clearButton.innerHTML = '<i class="fas fa-trash-alt"></i> Clear All';
                            clearButton.setAttribute('id', 'audience-clear-btn');
                            clearButton.setAttribute('aria-label', 'Clear all annotations');
                            
                            // Create export button
                            const exportButton = document.createElement('button');
                            exportButton.className = 'toolbar-btn';
                            exportButton.innerHTML = '<i class="fas fa-file-export"></i> Export';
                            exportButton.setAttribute('id', 'audience-export-btn');
                            exportButton.setAttribute('aria-label', 'Export annotations');
                            
                            // Create persona guidance panel container
                            const guidanceContainer = document.createElement('div');
                            guidanceContainer.className = 'toolbar-guidance';
                            guidanceContainer.id = 'audience-persona-guidance';
                            
                            // Create containers for the buttons
                            const selectorContainer = document.createElement('div');
                            selectorContainer.className = 'toolbar-group';
                            selectorContainer.appendChild(personaSelector);
                            
                            const actionContainer = document.createElement('div');
                            actionContainer.className = 'toolbar-group';
                            actionContainer.appendChild(clearButton);
                            actionContainer.appendChild(exportButton);
                            
                            // Add to options area
                            activeModeOptions.appendChild(selectorContainer);
                            activeModeOptions.appendChild(actionContainer);
                            
                            // Add guidance container below the toolbar
                            const toolbarModes = document.querySelector('.editor-toolbar-modes');
                            if (toolbarModes) {
                                toolbarModes.appendChild(guidanceContainer);
                            }
                            
                            // Update the guidance panel with current persona
                            this.updatePersonaGuidance();
                        },
                        
                        // Update the persona guidance panel with prompts for the current persona
                        updatePersonaGuidance: function() {
                            const guidanceContainer = document.getElementById('audience-persona-guidance');
                            if (!guidanceContainer) return;
                            
                            // Get guidance for the current persona
                            const guidance = this.getPersonaGuidance(this.currentPersona);
                            
                            // Update the container
                            guidanceContainer.innerHTML = `
                                <div class="audience-guidance-header ${this.currentPersona}-persona">
                                    <i class="${guidance.icon}"></i> 
                                    <span>Reading as: ${guidance.title}</span>
                                </div>
                                <div class="audience-guidance-prompts">
                                    ${guidance.prompts.map(prompt => `<div class="audience-prompt">${prompt}</div>`).join('')}
                                </div>
                            `;
                        },
                        
                        // Get guidance content for a specific persona
                        getPersonaGuidance: function(persona) {
                            const guidance = {
                                expert: {
                                    title: 'Expert Reader',
                                    icon: 'fas fa-graduation-cap',
                                    color: '#9b59b6',
                                    prompts: [
                                        'What specialized terminology needs more precision?',
                                        'Where could disciplinary conventions be better followed?',
                                        'What important citations or references are missing?',
                                        'Where could theoretical connections be strengthened?'
                                    ]
                                },
                                novice: {
                                    title: 'Novice Reader',
                                    icon: 'fas fa-book-open',
                                    color: '#3498db',
                                    prompts: [
                                        'What terms need definition for a newcomer?',
                                        'Where is background knowledge assumed?',
                                        'Which sections need more concrete examples?',
                                        'What connections need to be made more explicit?'
                                    ]
                                },
                                skeptical: {
                                    title: 'Skeptical Reader',
                                    icon: 'fas fa-question-circle',
                                    color: '#e67e22',
                                    prompts: [
                                        'What counterarguments might this reader raise?',
                                        'Where is the evidence weak or incomplete?',
                                        'What hidden assumptions might be questioned?',
                                        'Which leaps in logic might be challenged?'
                                    ]
                                },
                                timeconstrained: {
                                    title: 'Time-Constrained Reader',
                                    icon: 'fas fa-clock',
                                    color: '#2ecc71',
                                    prompts: [
                                        'Is the main point immediately clear?',
                                        'Which sections could be condensed?',
                                        'Are headings and topic sentences informative?',
                                        'Is the most essential information quickly accessible?'
                                    ]
                                },
                                generous: {
                                    title: 'Generous Reader',
                                    icon: 'fas fa-star',
                                    color: '#f1c40f',
                                    prompts: [
                                        'Which passages communicate ideas most clearly?',
                                        'What examples or metaphors are especially illuminating?',
                                        'Where do you establish a particularly strong connection?',
                                        'Which insights might stay with a reader after finishing?'
                                    ]
                                }
                            };
                            
                            return guidance[persona] || guidance.expert;
                        },
                        
                        // Transform the document into Audience Perspective Mode view
                        transformToAudienceView: function() {
                            // Add a container for the annotation interface
                            const annotationContainer = document.createElement('div');
                            annotationContainer.className = 'audience-annotation-container';
                            annotationContainer.id = 'audience-annotation-interface';
                            annotationContainer.style.display = 'none';
                            
                            // Create annotation interface
                            annotationContainer.innerHTML = `
                                <div class="audience-annotation-header">
                                    <span id="audience-annotation-title">Add Comment</span>
                                    <button id="audience-annotation-close" class="audience-close-btn">
                                        <i class="fas fa-times"></i>
                                    </button>
                                </div>
                                <div class="audience-annotation-personas">
                                    <div class="audience-persona-selector expert-persona" data-persona="expert">
                                        <i class="fas fa-graduation-cap"></i> Expert
                                    </div>
                                    <div class="audience-persona-selector novice-persona" data-persona="novice">
                                        <i class="fas fa-book-open"></i> Novice
                                    </div>
                                    <div class="audience-persona-selector skeptical-persona" data-persona="skeptical">
                                        <i class="fas fa-question-circle"></i> Skeptical
                                    </div>
                                    <div class="audience-persona-selector timeconstrained-persona" data-persona="timeconstrained">
                                        <i class="fas fa-clock"></i> Time-Constrained
                                    </div>
                                    <div class="audience-persona-selector generous-persona" data-persona="generous">
                                        <i class="fas fa-star"></i> Generous
                                    </div>
                                </div>
                                <textarea id="audience-annotation-content" placeholder="Enter your comment from this reader's perspective..."></textarea>
                                <div class="audience-annotation-footer">
                                    <button id="audience-annotation-cancel">Cancel</button>
                                    <button id="audience-annotation-save">Save Comment</button>
                                </div>
                            `;
                            
                            // Add the container to the editor
                            document.body.appendChild(annotationContainer);
                            
                            // Apply any existing annotations
                            this.applyAnnotations();
                        },
                        
                        // Set up event handlers using delegation
                        setupEventHandlers: function() {
                            // Handler for selecting text in the editor
                            editor.addEventListener('mouseup', this.handleTextSelection);
                            
                            // Handler for annotation interface buttons
                            document.addEventListener('click', this.handleAnnotationInterface);
                            
                            // Handler for clicking on existing annotations
                            editor.addEventListener('click', this.handleAnnotationClick);
                        },
                        
                        // Remove event handlers
                        removeEventHandlers: function() {
                            editor.removeEventListener('mouseup', this.handleTextSelection);
                            document.removeEventListener('click', this.handleAnnotationInterface);
                            editor.removeEventListener('click', this.handleAnnotationClick);
                        },
                        
                        // Handle text selection in the editor
                        handleTextSelection: function(e) {
                            // Check if Audience Perspective Mode is still active
                            if (!currentMode || currentMode !== 'audience') return;
                            
                            // Get the current selection
                            const selection = window.getSelection();
                            const selectedText = selection.toString().trim();
                            
                            // If there's selected text, show the annotation interface
                            if (selectedText) {
                                // Position the annotation interface near the selection
                                const range = selection.getRangeAt(0);
                                const rect = range.getBoundingClientRect();
                                
                                const annotationInterface = document.getElementById('audience-annotation-interface');
                                if (annotationInterface) {
                                    // Position it below the selection
                                    annotationInterface.style.position = 'absolute';
                                    annotationInterface.style.top = `${window.scrollY + rect.bottom + 10}px`;
                                    annotationInterface.style.left = `${window.scrollX + rect.left}px`;
                                    annotationInterface.style.display = 'block';
                                    
                                    // Reset the interface
                                    document.getElementById('audience-annotation-content').value = '';
                                    
                                    // Highlight the current persona
                                    const personaSelectors = document.querySelectorAll('.audience-persona-selector');
                                    personaSelectors.forEach(selector => {
                                        selector.classList.remove('active');
                                        if (selector.dataset.persona === modes.audience.currentPersona) {
                                            selector.classList.add('active');
                                        }
                                    });
                                    
                                    // Store the selection range for later use
                                    modes.audience.currentRange = range;
                                }
                            }
                        },
                        
                        // Handle clicks within the annotation interface
                        handleAnnotationInterface: function(e) {
                            // Check if Audience Perspective Mode is still active
                            if (!currentMode || currentMode !== 'audience') return;
                            
                            // Find the clicked element
                            const target = e.target.closest('[id], [data-persona]');
                            if (!target) return;
                            
                            // Handle annotation interface buttons
                            if (target.id === 'audience-annotation-close' || target.id === 'audience-annotation-cancel') {
                                // Close the annotation interface
                                const annotationInterface = document.getElementById('audience-annotation-interface');
                                if (annotationInterface) {
                                    annotationInterface.style.display = 'none';
                                }
                            }
                            else if (target.id === 'audience-annotation-save') {
                                // Save the annotation
                                modes.audience.saveCurrentAnnotation();
                            }
                            else if (target.id === 'audience-clear-btn') {
                                // Clear all annotations
                                if (confirm('Are you sure you want to remove all annotations? This cannot be undone.')) {
                                    modes.audience.clearAllAnnotations();
                                }
                            }
                            else if (target.id === 'audience-export-btn') {
                                // Export annotations
                                modes.audience.exportAnnotations();
                            }
                            else if (target.classList.contains('audience-persona-selector')) {
                                // Switch persona in the annotation interface
                                const personaSelectors = document.querySelectorAll('.audience-persona-selector');
                                personaSelectors.forEach(selector => {
                                    selector.classList.remove('active');
                                });
                                target.classList.add('active');
                                
                                // Update the current persona for this annotation
                                modes.audience.currentAnnotationPersona = target.dataset.persona;
                            }
                            else if (target.classList.contains('audience-annotation-delete')) {
                                // Delete an annotation
                                const annotationId = target.dataset.annotationId;
                                modes.audience.deleteAnnotation(annotationId);
                            }
                        },
                        
                        // Handle clicks on existing annotations
                        handleAnnotationClick: function(e) {
                            // Check if Audience Perspective Mode is still active
                            if (!currentMode || currentMode !== 'audience') return;
                            
                            // Check if clicked on a highlight
                            const highlight = e.target.closest('.audience-highlight');
                            if (!highlight) {
                                // If clicked outside a highlight, close any open annotation popups
                                modes.audience.closeAnnotationPopup();
                                return;
                            }
                            
                            // Get annotation details
                            const annotationId = highlight.dataset.annotationId;
                            if (!annotationId || !modes.audience.annotationData[annotationId]) return;
                            
                            // Close any existing popup
                            modes.audience.closeAnnotationPopup();
                            
                            // Create and show the popup for this annotation
                            modes.audience.showAnnotationPopup(highlight, annotationId);
                            
                            // Prevent the click from propagating to document
                            e.stopPropagation();
                        },
                        
                        // Create and show the annotation popup
                        showAnnotationPopup: function(highlight, annotationId) {
                            // Get the annotation data
                            const annotation = this.annotationData[annotationId];
                            if (!annotation) return;
                            
                            // Get the guidance for this persona
                            const guidance = this.getPersonaGuidance(annotation.persona);
                            
                            // Create popup element
                            const popup = document.createElement('div');
                            popup.className = `audience-annotation-popup ${annotation.persona}-annotation`;
                            popup.id = 'audience-active-popup';
                            popup.dataset.annotationId = annotationId;
                            
                            // Create popup content
                            popup.innerHTML = `
                                <div class="audience-annotation-header ${annotation.persona}-persona">
                                    <i class="${guidance.icon}"></i>
                                    <span>${guidance.title}</span>
                                    <div class="audience-popup-actions">
                                        <button class="audience-annotation-edit" data-annotation-id="${annotationId}">
                                            <i class="fas fa-edit"></i>
                                        </button>
                                        <button class="audience-annotation-delete" data-annotation-id="${annotationId}">
                                            <i class="fas fa-trash"></i>
                                        </button>
                                        <button class="audience-popup-close">
                                            <i class="fas fa-times"></i>
                                        </button>
                                    </div>
                                </div>
                                <div class="audience-annotation-content">
                                    ${annotation.content}
                                </div>
                            `;
                            
                            // Add to document
                            document.body.appendChild(popup);
                            
                            // Position the popup relative to the highlight
                            this.positionPopup(popup, highlight);
                            
                            // Add click listener to close button
                            const closeBtn = popup.querySelector('.audience-popup-close');
                            if (closeBtn) {
                                closeBtn.addEventListener('click', this.closeAnnotationPopup);
                            }
                            
                            // Add click listener to edit button
                            const editBtn = popup.querySelector('.audience-annotation-edit');
                            if (editBtn) {
                                editBtn.addEventListener('click', (e) => {
                                    this.editAnnotation(annotationId);
                                    e.stopPropagation();
                                });
                            }
                            
                            // Add document listener to close popup when clicking outside
                            setTimeout(() => {
                                document.addEventListener('click', this.handleDocumentClick);
                            }, 10);
                        },
                        
                        // Close the active annotation popup
                        closeAnnotationPopup: function() {
                            const popup = document.getElementById('audience-active-popup');
                            if (popup) {
                                popup.remove();
                            }
                            
                            // Remove document listener
                            document.removeEventListener('click', modes.audience.handleDocumentClick);
                        },
                        
                        // Handle document clicks to close popup when clicking outside
                        handleDocumentClick: function(e) {
                            const popup = document.getElementById('audience-active-popup');
                            const annotationInterface = document.getElementById('audience-annotation-interface');
                            
                            // If clicked outside popup and annotation interface, close popup
                            if (popup && !popup.contains(e.target) && 
                                (!annotationInterface || !annotationInterface.contains(e.target))) {
                                modes.audience.closeAnnotationPopup();
                            }
                        },
                        
                        // Position the popup relative to the highlight
                        positionPopup: function(popup, highlight) {
                            // Get highlight position
                            const rect = highlight.getBoundingClientRect();
                            
                            // Set initial position
                            popup.style.position = 'absolute';
                            popup.style.top = `${window.scrollY + rect.bottom + 10}px`;
                            popup.style.left = `${window.scrollX + rect.left}px`;
                            
                            // Ensure popup is within viewport
                            setTimeout(() => {
                                const popupRect = popup.getBoundingClientRect();
                                const viewportWidth = window.innerWidth;
                                const viewportHeight = window.innerHeight;
                                
                                // Adjust if off-screen horizontally
                                if (popupRect.right > viewportWidth - 20) {
                                    const overflow = popupRect.right - viewportWidth + 20;
                                    popup.style.left = `${parseInt(popup.style.left) - overflow}px`;
                                }
                                
                                // Adjust if off-screen vertically
                                if (popupRect.bottom > viewportHeight - 20) {
                                    // Position above the highlight instead
                                    popup.style.top = `${window.scrollY + rect.top - popupRect.height - 10}px`;
                                }
                            }, 0);
                        },
                        
                        // Edit an existing annotation
                        editAnnotation: function(annotationId) {
                            // Close the popup
                            this.closeAnnotationPopup();
                            
                            // Get the annotation data
                            const annotation = this.annotationData[annotationId];
                            if (!annotation) return;
                            
                            // Show the annotation interface
                            const annotationInterface = document.getElementById('audience-annotation-interface');
                            if (!annotationInterface) return;
                            
                            // Position the interface
                            const highlight = document.querySelector(`.audience-highlight[data-annotation-id="${annotationId}"]`);
                            if (highlight) {
                                const rect = highlight.getBoundingClientRect();
                                annotationInterface.style.position = 'absolute';
                                annotationInterface.style.top = `${window.scrollY + rect.bottom + 10}px`;
                                annotationInterface.style.left = `${window.scrollX + rect.left}px`;
                                annotationInterface.style.display = 'block';
                            }
                            
                            // Populate the interface
                            document.getElementById('audience-annotation-content').value = annotation.content;
                            
                            // Set the active persona
                            const personaSelectors = document.querySelectorAll('.audience-persona-selector');
                            personaSelectors.forEach(selector => {
                                selector.classList.remove('active');
                                if (selector.dataset.persona === annotation.persona) {
                                    selector.classList.add('active');
                                }
                            });
                            
                            // Store the annotation ID for update
                            this.editingAnnotationId = annotationId;
                            
                            // Change save button text
                            const saveBtn = document.getElementById('audience-annotation-save');
                            if (saveBtn) {
                                saveBtn.textContent = 'Update Comment';
                            }
                        },
                        
                        // Save the current annotation
                        saveCurrentAnnotation: function() {
                            // Get annotation content
                            const annotationContent = document.getElementById('audience-annotation-content').value.trim();
                            if (!annotationContent || !this.currentRange) return;
                            
                            // Get active persona
                            const activePersona = document.querySelector('.audience-persona-selector.active');
                            const persona = activePersona ? activePersona.dataset.persona : this.currentPersona;
                            
                            // Create a unique ID for the annotation
                            const annotationId = 'anno-' + Date.now();
                            
                            // Create annotation object
                            const annotation = {
                                id: annotationId,
                                content: annotationContent,
                                persona: persona,
                                range: {
                                    startContainer: this.getPathToNode(this.currentRange.startContainer),
                                    startOffset: this.currentRange.startOffset,
                                    endContainer: this.getPathToNode(this.currentRange.endContainer),
                                    endOffset: this.currentRange.endOffset
                                },
                                selectedText: this.currentRange.toString()
                            };
                            
                            // Add annotation to data
                            this.annotationData[annotationId] = annotation;
                            
                            // Apply the annotation to the document
                            this.applyAnnotation(annotation);
                            
                            // Close the annotation interface
                            const annotationInterface = document.getElementById('audience-annotation-interface');
                            if (annotationInterface) {
                                annotationInterface.style.display = 'none';
                            }
                            
                            // Clear the current range
                            this.currentRange = null;
                            
                            // Mark document as having unsaved changes
                            DocumentManager.hasUnsavedChanges = true;
                        },
                        
                        // Apply a single annotation to the document
                        applyAnnotation: function(annotation) {
                            try {
                                // Create a new range from the saved range data
                                const range = this.recreateRange(annotation.range);
                                if (!range) return;
                                
                                // Get the guidance for this persona
                                const guidance = this.getPersonaGuidance(annotation.persona);
                                
                                // Surround the range with a span
                                const highlightSpan = document.createElement('span');
                                highlightSpan.className = `audience-highlight ${annotation.persona}-highlight`;
                                highlightSpan.dataset.annotationId = annotation.id;
                                highlightSpan.title = "Click to view comment";
                                
                                // Apply the range contents to the span
                                range.surroundContents(highlightSpan);
                                
                                // We don't add the comment element here anymore
                                // It will be created when the user clicks on the highlight
                            } catch (error) {
                                console.error('Error applying annotation:', error);
                            }
                        },
                        
                        // Apply all saved annotations to the document
                        applyAnnotations: function() {
                            // Get all saved annotations
                            const annotations = Object.values(this.annotationData);
                            
                            // Apply each annotation
                            annotations.forEach(annotation => {
                                try {
                                    this.applyAnnotation(annotation);
                                } catch (error) {
                                    console.error('Error applying annotation:', error);
                                }
                            });
                            
                            // Update annotation counter
                            this.updateAnnotationCounter();
                        },
                        
                        // Position an annotation comment element
                        positionAnnotation: function(commentEl, highlightSpan) {
                            // For now, position relatively within the document flow
                            // A more sophisticated approach would use absolute positioning
                            commentEl.style.position = 'relative';
                            commentEl.style.zIndex = '100';
                            commentEl.style.marginTop = '5px';
                            commentEl.style.marginBottom = '5px';
                        },
                        
                        // Delete an annotation
                        deleteAnnotation: function(annotationId) {
                            // Remove the annotation data
                            delete this.annotationData[annotationId];
                            
                            // Remove the highlight span and comment element
                            const highlightSpan = document.querySelector(`.audience-highlight[data-annotation-id="${annotationId}"]`);
                            if (highlightSpan) {
                                // Get the parent node
                                const parent = highlightSpan.parentNode;
                                
                                // Replace the highlight span with its text content
                                const textNode = document.createTextNode(highlightSpan.textContent);
                                parent.replaceChild(textNode, highlightSpan);
                                
                                // Normalize the parent to combine adjacent text nodes
                                parent.normalize();
                            }
                            
                            // Mark document as having unsaved changes
                            DocumentManager.hasUnsavedChanges = true;
                        },
                        
                        // Clear all annotations
                        clearAllAnnotations: function() {
                            // Get all annotation IDs
                            const annotationIds = Object.keys(this.annotationData);
                            
                            // Delete each annotation
                            annotationIds.forEach(id => {
                                this.deleteAnnotation(id);
                            });
                            
                            // Clear annotation data
                            this.annotationData = {};
                            
                            // Save the document
                            DocumentManager.saveDocument();
                            
                            showNotification('All annotations have been cleared');
                        },
                        
                        // Update the annotation counter
                        updateAnnotationCounter: function(element) {
                            const counterElement = element || document.getElementById('audience-annotation-counter');
                            if (!counterElement) return;
                            
                            // Count annotations by persona
                            const counts = {
                                total: 0,
                                expert: 0,
                                novice: 0,
                                skeptical: 0,
                                timeconstrained: 0,
                                generous: 0
                            };
                            
                            // Count all annotations
                            Object.values(this.annotationData).forEach(annotation => {
                                counts.total++;
                                if (counts[annotation.persona] !== undefined) {
                                    counts[annotation.persona]++;
                                }
                            });
                            
                            // Update the counter text
                            counterElement.textContent = `${counts.total} annotations (Expert: ${counts.expert}, Novice: ${counts.novice}, Skeptical: ${counts.skeptical}, Time-Constrained: ${counts.timeconstrained}, Generous: ${counts.generous})`;
                            
                            // Add color based on count
                            if (counts.total === 0) {
                                counterElement.style.color = '#999';
                            } else {
                                counterElement.style.color = 'var(--primary-color, #57068c)';
                            }
                        },
                        
                        // Get total annotation count
                        getAnnotationCount: function() {
                            return Object.keys(this.annotationData).length;
                        },
                        
                        // Load saved annotations if available
                        loadSavedData: function() {
                            // Reset annotation data
                            this.annotationData = {};
                            
                            // Check if current document has audience annotations data
                            if (DocumentManager.currentDocument && DocumentManager.currentDocument.audienceAnnotations) {
                                this.annotationData = DocumentManager.currentDocument.audienceAnnotations;
                            }
                        },
                        
                        // Save annotations to the current document
                        saveAnnotations: function() {
                            if (!DocumentManager.currentDocument) return;
                            
                            // Save annotations data to the document
                            DocumentManager.currentDocument.audienceAnnotations = this.annotationData;
                            
                            // Save the document to persist changes
                            DocumentManager.saveDocument();
                        },
                        
                        // Clear annotation elements from the DOM
                        clearAnnotationElements: function() {
                            // Remove the annotation interface
                            const annotationInterface = document.getElementById('audience-annotation-interface');
                            if (annotationInterface) {
                                annotationInterface.remove();
                            }
                            
                            // Remove guidance container from toolbar
                            const guidanceContainer = document.getElementById('audience-persona-guidance');
                            if (guidanceContainer) {
                                guidanceContainer.remove();
                            }
                        },
                        
                        // Export annotations to a new document
                        exportAnnotations: function() {
                            // Save current annotations first
                            this.saveAnnotations();
                            
                            // Create title for new document
                            const title = (DocumentManager.currentDocument?.title || 'Untitled') + ' - Reader Feedback';
                            
                            // Create content for the new document
                            let content = '<h1>Audience Perspective Analysis</h1>';
                            content += `<h2>${DocumentManager.currentDocument?.title || 'Untitled Document'}</h2>`;
                            
                            // Get all annotations grouped by persona
                            const personaAnnotations = this.groupAnnotationsByPersona();
                            
                            // Add annotations by persona
                            for (const [persona, annotations] of Object.entries(personaAnnotations)) {
                                if (annotations.length === 0) continue;
                                
                                const guidance = this.getPersonaGuidance(persona);
                                
                                content += `<h3><i class="${guidance.icon}"></i> ${guidance.title} Feedback</h3>`;
                                content += '<ul>';
                                
                                annotations.forEach(annotation => {
                                    content += `<li>
                                        <blockquote style="background-color:#f9f9f9; padding:10px; border-left:3px solid ${guidance.color}">
                                            "${annotation.selectedText}"
                                        </blockquote>
                                        <p>${annotation.content}</p>
                                    </li>`;
                                });
                                
                                content += '</ul>';
                            }
                            
                            // Add a summary section
                            content += '<h3>Summary of Annotations</h3>';
                            content += '<table style="width:100%; border-collapse:collapse; margin-top:20px">';
                            content += '<tr style="background-color:#f2f2f2">';
                            content += '<th style="border:1px solid #ddd; padding:8px; text-align:left">Reader Perspective</th>';
                            content += '<th style="border:1px solid #ddd; padding:8px; text-align:left">Number of Comments</th>';
                            content += '</tr>';
                            
                            for (const [persona, annotations] of Object.entries(personaAnnotations)) {
                                const guidance = this.getPersonaGuidance(persona);
                                content += `<tr>
                                    <td style="border:1px solid #ddd; padding:8px">${guidance.title}</td>
                                    <td style="border:1px solid #ddd; padding:8px">${annotations.length}</td>
                                </tr>`;
                            }
                            
                            content += '</table>';
                            
                            // Add reflection prompts
                            content += '<h3>Reflection Questions</h3>';
                            content += '<ol>';
                            content += '<li>What patterns do you notice across different reader perspectives?</li>';
                            content += '<li>Which readers might need the most attention during revision?</li>';
                            content += '<li>What strengths did your Generous Reader identify that you should preserve?</li>';
                            content += '<li>What revisions would address multiple reader concerns simultaneously?</li>';
                            content += '</ol>';
                            
                            // Create new document with this content
                            const docId = DocumentManager.createNewDocument(title, '');
                            
                            // Find the new document and update its content
                            const newDoc = DocumentManager.documents.find(doc => doc.id === docId);
                            if (newDoc) {
                                newDoc.content = content;
                                DocumentManager.saveDocument();
                                
                                // Show notification
                                showNotification('Annotations exported to a new document');
                            }
                        },
                        
                        // Group annotations by persona
                        groupAnnotationsByPersona: function() {
                            const groupedAnnotations = {
                                expert: [],
                                novice: [],
                                skeptical: [],
                                timeconstrained: [],
                                generous: []
                            };
                            
                            // Group annotations by persona
                            Object.values(this.annotationData).forEach(annotation => {
                                if (groupedAnnotations[annotation.persona] !== undefined) {
                                    groupedAnnotations[annotation.persona].push(annotation);
                                }
                            });
                            
                            return groupedAnnotations;
                        },
                        
                        // Utility: Get path to node for serialization
                        getPathToNode: function(node) {
                            // This is a simplified approach - a more robust solution would be needed for complex documents
                            // For now, just store the node as a string representation
                            return node.textContent;
                        },
                        
                        // Utility: Recreate a range from serialized data
                        recreateRange: function(rangeData) {
                            try {
                                // Create a new range
                                const range = document.createRange();
                                
                                // Create a text finder function (simplified)
                                const findTextNode = (root, text, startOffset) => {
                                    // Simple implementation - walk the DOM looking for the text node
                                    const walker = document.createTreeWalker(
                                        root,
                                        NodeFilter.SHOW_TEXT,
                                        null,
                                        false
                                    );
                                    
                                    let node;
                                    while (node = walker.nextNode()) {
                                        if (node.textContent.includes(text)) {
                                            return node;
                                        }
                                    }
                                    
                                    return null;
                                };
                                
                                // Find start and end containers (simplified)
                                const startContainer = findTextNode(editor, rangeData.startContainer, rangeData.startOffset);
                                const endContainer = findTextNode(editor, rangeData.endContainer, rangeData.endOffset);
                                
                                if (!startContainer || !endContainer) {
                                    return null;
                                }
                                
                                // Set range boundaries
                                range.setStart(startContainer, rangeData.startOffset);
                                range.setEnd(endContainer, rangeData.endOffset);
                                
                                return range;
                            } catch (error) {
                                console.error('Error recreating range:', error);
                                return null;
                            }
                        }
                    },



                
                // Integrated Reader Mode implementation
                reader: {
                    name: 'Reader Mode',
                    currentSentenceIndex: 0,
                    sentences: [],
                    selectedText: null,
                    reflections: {},
                    modalElement: null,
                    
                    activate: function() {
                        // Store the current selection, if any
                        const selection = window.getSelection();
                        if (selection && selection.toString().trim().length > 0) {
                            this.selectedText = selection.toString();
                        } else {
                            this.selectedText = null;
                        }
                        
                        // Parse sentences from the selection or the entire document
                        this.parseSentences();
                        
                        // Reset current index
                        this.currentSentenceIndex = 0;

                        // Load any saved reflections for this document
                        this.loadReflections();
                        
                        // Create and show the Reader Mode modal
                        this.createReaderModal();
                        
                        // Set up mode-specific options in the active indicator
                        this.setupOptions();
                        
                        showNotification('Reader Mode enabled - Reflect as you reveal each sentence');
                    },
                    
                    // Replace the deactivate function in the reader mode object
                    deactivate: function() {
                        console.log("Reader mode deactivate called");
  
                    // Save reflections first
                    try {
                        this.saveReflections();
                    } catch (e) {
                        console.error("Error saving reflections:", e);
                    }
                    
                    // Find and remove modal directly
                    const readerModal = document.querySelector('.reader-modal-backdrop');
                    if (readerModal && readerModal.parentNode) {
                        readerModal.parentNode.removeChild(readerModal);
                    }
                    
                    // Reset internal state
                    this.modalElement = null;
                    this.currentSentenceIndex = 0;
                    this.sentences = [];
                    this.selectedText = null;
                    
                    // Clear mode options
                    clearModeOptions();
                    },


    // NEW METHOD: Save reflections to the document and localStorage
    saveReflections: function() {
        // Only save if there are reflections and a current document
        if (Object.keys(this.reflections).length === 0 || !DocumentManager.currentDocument) {
            return;
        }
        
        // Store reflections in the current document
        if (!DocumentManager.currentDocument.readerData) {
            DocumentManager.currentDocument.readerData = {};
        }
        
        // Create a key based on the content to link reflections to specific content
        // This handles cases where the document text might change
        const contentKey = this.createContentKey();
        
        DocumentManager.currentDocument.readerData[contentKey] = {
            sentences: this.sentences,
            reflections: this.reflections,
            timestamp: new Date().toISOString()
        };
        
        // Save the document to persist changes to localStorage
        DocumentManager.saveDocument();
    },
    
    // NEW METHOD: Load reflections from the document
    loadReflections: function() {
        // Reset reflections
        this.reflections = {};
        
        // Check if we have a current document with readerData
        if (!DocumentManager.currentDocument || !DocumentManager.currentDocument.readerData) {
            return;
        }
        
        // Create a key based on the current content
        const contentKey = this.createContentKey();
        
        // Check if we have reflections for this content
        if (DocumentManager.currentDocument.readerData[contentKey]) {
            const savedData = DocumentManager.currentDocument.readerData[contentKey];
            
            // Only use the saved data if the sentences match what we've parsed
            // This prevents misalignment if the document has changed significantly
            if (this.sentencesMatch(savedData.sentences, this.sentences)) {
                this.reflections = savedData.reflections;
                console.log('Loaded saved reflections for document');
            }
        }
    },
    
    // NEW METHOD: Create a content key to identify specific text content
    createContentKey: function() {
        // Using a hash of the sentences to create a unique identifier
        // This approach allows reflections to be associated with specific content
        // even if the document contains multiple sections
        const contentString = this.sentences.join('|');
        return this.hashString(contentString);
    },
    
    // NEW METHOD: Simple string hashing function
    hashString: function(str) {
        let hash = 0;
        if (str.length === 0) return hash;
        
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        
        return 'content_' + Math.abs(hash).toString(16);
    },
    
    // NEW METHOD: Check if two sentence arrays are similar enough
    sentencesMatch: function(savedSentences, currentSentences) {
        // If lengths are significantly different, they don't match
        if (Math.abs(savedSentences.length - currentSentences.length) > 2) {
            return false;
        }
        
        // If exactly the same, they match
        if (savedSentences.join('') === currentSentences.join('')) {
            return true;
        }
        
        // Check for at least 70% similarity in content
        let matchCount = 0;
        const minLength = Math.min(savedSentences.length, currentSentences.length);
        
        for (let i = 0; i < minLength; i++) {
            // Compare with some tolerance for small edits
            if (this.stringSimilarity(savedSentences[i], currentSentences[i]) > 0.7) {
                matchCount++;
            }
        }
        
        return (matchCount / minLength) > 0.7;
    },
    
    // NEW METHOD: Calculate string similarity (simple implementation)
    stringSimilarity: function(str1, str2) {
        // Simple length-based comparison for efficiency
        const maxLength = Math.max(str1.length, str2.length);
        if (maxLength === 0) return 1.0; // Both empty strings
        
        // Calculate Levenshtein distance (edit distance)
        const distance = this.levenshteinDistance(str1, str2);
        return 1 - (distance / maxLength);
    },
    
    // NEW METHOD: Calculate Levenshtein distance between strings
    levenshteinDistance: function(str1, str2) {
        const m = str1.length;
        const n = str2.length;
        
        // Create distance matrix
        const d = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
        
        // Initialize first row and column
        for (let i = 0; i <= m; i++) d[i][0] = i;
        for (let j = 0; j <= n; j++) d[0][j] = j;
        
        // Fill the matrix
        for (let j = 1; j <= n; j++) {
            for (let i = 1; i <= m; i++) {
                const cost = str1[i-1] === str2[j-1] ? 0 : 1;
                d[i][j] = Math.min(
                    d[i-1][j] + 1,      // deletion
                    d[i][j-1] + 1,      // insertion
                    d[i-1][j-1] + cost  // substitution
                );
            }
        }
        
        return d[m][n];
    },
    
    // Update addSentenceWithReflection to use debounced saving
        addSentenceWithReflection: function(container, index) {
                    // Check bounds
            if (index < 0 || index >= this.sentences.length) {
                return;
            }
            
            // Create a block for this sentence and its reflection
            const block = document.createElement('div');
            block.className = 'reader-sentence-block';
            block.dataset.index = index;
            
            // Current sentence display
            const sentenceDisplay = document.createElement('div');
            sentenceDisplay.className = 'reader-sentence';
            sentenceDisplay.textContent = this.sentences[index];
            
            // Reflection area
            const reflectionArea = document.createElement('div');
            reflectionArea.className = 'reader-reflection-wrapper';
            
            // Reflection prompt
            const reflectionPrompt = document.createElement('div');
            reflectionPrompt.className = 'reader-prompt';
            
            if (index === 0) {
                reflectionPrompt.innerHTML = '<strong>Reflect:</strong> What might your reader expect to come next?';
            } else if (index === this.sentences.length - 1) {
                reflectionPrompt.innerHTML = '<strong>Reflect:</strong> How does this concluding sentence complete the passage?';
            } else {
                reflectionPrompt.innerHTML = '<strong>Reflect:</strong> Did this sentence meet your expectations? What might come next?';
            }
            
            // Reflection input
            const reflectionInput = document.createElement('textarea');
            reflectionInput.className = 'reader-reflection-input';
            reflectionInput.rows = 3;
            reflectionInput.placeholder = 'Enter your reflection here...';
            reflectionInput.value = this.reflections[index] || '';
            
            // Store the index in the DOM element to make it easier to reference
            reflectionInput.dataset.reflectionIndex = index;
            
            // Critical fix: Use a simpler approach to save reflections
            // Instead of using complex binding, just use a global handler
            reflectionInput.addEventListener('input', function() {
                // Get the reflection index from the dataset
                const idx = parseInt(this.dataset.reflectionIndex, 10);
                
                // Update the reflection directly in the modes.reader object
                if (!isNaN(idx) && modes.reader) {
                modes.reader.reflections[idx] = this.value;
                }
            });
            
            // Reveal next button (only if not the last sentence)
            if (index < this.sentences.length - 1) {
                const revealButton = document.createElement('button');
                revealButton.className = 'reader-reveal-button';
                revealButton.innerHTML = 'Reveal Next Sentence <i class="fas fa-arrow-right"></i>';
                
                // Set up a global function for revealing the next sentence
                const revealFunctionName = `revealNextSentence_${index}`;
                window[revealFunctionName] = () => {
                // Hide this button once clicked
                revealButton.style.display = 'none';
                
                // Move to next sentence index
                if (modes.reader) {
                    modes.reader.currentSentenceIndex = index + 1;
                    
                    // Add the next sentence block
                    modes.reader.addSentenceWithReflection(container, index + 1);
                    
                    // Update counter in options
                    const sentenceCounter = document.getElementById('reader-sentence-counter');
                    if (sentenceCounter) {
                    sentenceCounter.textContent = `Sentence ${modes.reader.currentSentenceIndex + 1} of ${modes.reader.sentences.length}`;
                    }
                    
                    // Update status text in modal footer
                    const statusText = document.querySelector('.reader-status-text');
                    if (statusText) {
                    statusText.textContent = `Sentence ${modes.reader.currentSentenceIndex + 1} of ${modes.reader.sentences.length}`;
                    }
                    
                    // Scroll to the new block
                    const newBlock = container.querySelector(`.reader-sentence-block[data-index="${index + 1}"]`);
                    if (newBlock) {
                    newBlock.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
                };
                
                // Use onclick attribute to ensure reliable event handling
                revealButton.setAttribute('onclick', `${revealFunctionName}()`);
                
                reflectionArea.appendChild(reflectionPrompt);
                reflectionArea.appendChild(reflectionInput);
                reflectionArea.appendChild(revealButton);
            } else {
                reflectionArea.appendChild(reflectionPrompt);
                reflectionArea.appendChild(reflectionInput);
            }
            
            // Assemble the block
            block.appendChild(sentenceDisplay);
            block.appendChild(reflectionArea);
            
            // Add to container
            container.appendChild(block);
            
            // Focus on the reflection input
            setTimeout(() => {
                reflectionInput.focus();
            }, 100);
            },
    
    // NEW METHOD: Debounce helper for efficient saving
    debounce: function(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },
                    
                    getOptions: function() {
                        return {
                            currentIndex: this.currentSentenceIndex
                        };
                    },
                    
                    setupOptions: function() {
                        // Clear existing options
                        clearModeOptions();
                        
                        // Create navigation controls
                        const optionContainer = document.createElement('div');
                        optionContainer.className = 'mode-option';
                        
                        const sentenceCounter = document.createElement('span');
                        sentenceCounter.className = 'mode-option-label';
                        sentenceCounter.id = 'reader-sentence-counter';
                        sentenceCounter.textContent = `Sentence ${this.currentSentenceIndex + 1} of ${this.sentences.length}`;
                        
                        optionContainer.appendChild(sentenceCounter);
                        
                        // Add to the active mode options container
                        activeModeOptions.appendChild(optionContainer);
                    },
                    
                    parseSentences: function() {
                        let textToProcess = '';
                        
                        // Use selected text if available, otherwise use the entire document
                        if (this.selectedText) {
                            textToProcess = this.selectedText;
                        } else {
                            textToProcess = editor.innerText;
                        }
                        
                        // Simple sentence splitting - can be improved for edge cases
                        const sentenceRegex = /([^.!?]+[.!?]+)/g;
                        
                        this.sentences = [];
                        let match;
                        
                        while ((match = sentenceRegex.exec(textToProcess)) !== null) {
                            this.sentences.push(match[0].trim());
                        }
                        
                        // Handle case where regex doesn't match (e.g., no punctuation)
                        if (this.sentences.length === 0 && textToProcess.trim().length > 0) {
                            this.sentences.push(textToProcess.trim());
                        }
                        
                        // Initialize reflections object with empty entries for each transition
                        for (let i = 0; i < this.sentences.length - 1; i++) {
                            if (!this.reflections[i]) {
                                this.reflections[i] = '';
                            }
                        }
                    },

                    
                    createReaderModal: function() {
                       // Store a reference to this for use in event handlers
                    // Create modal structure
                    const modalBackdrop = document.createElement('div');
                    modalBackdrop.className = 'reader-modal-backdrop';
                    
                    const modal = document.createElement('div');
                    modal.className = 'reader-modal';
                    
                    // Modal header with exit button
                    const modalHeader = document.createElement('div');
                    modalHeader.className = 'reader-modal-header';
                    
                    const modalTitle = document.createElement('h3');
                    modalTitle.textContent = 'Reader Mode: Reader Expectation Analysis';
                    
                    const closeButton = document.createElement('button');
                    closeButton.className = 'reader-modal-close';
                    closeButton.innerHTML = '&times;';
                    closeButton.setAttribute('aria-label', 'Close Reader Mode');
                    
                    // Critical fix: Use a direct onclick attribute instead of addEventListener
                    // This ensures the function reference doesn't get lost when DOM changes
                    closeButton.setAttribute('onclick', 'exitReaderMode()');
                    
                    modalHeader.appendChild(modalTitle);
                    modalHeader.appendChild(closeButton);
                    
                    // Modal content
                    const modalContent = document.createElement('div');
                    modalContent.className = 'reader-modal-content';
                    
                    const container = document.createElement('div');
                    container.id = 'reader-mode-container';
                    container.className = 'reader-mode-integrated-container';
                    
                    // Add first sentence
                    this.addSentenceWithReflection(container, 0);
                    modalContent.appendChild(container);
                    
                    // Modal footer with another exit button
                    const modalFooter = document.createElement('div');
                    modalFooter.className = 'reader-modal-footer';
                    
                    const statusText = document.createElement('div');
                    statusText.className = 'reader-status-text';
                    statusText.textContent = `Sentence ${this.currentSentenceIndex + 1} of ${this.sentences.length}`;
                    
                    const footerButtons = document.createElement('div');
                    footerButtons.className = 'reader-footer-buttons';
                    
                    const exitButton = document.createElement('button');
                    exitButton.className = 'reader-footer-button secondary';
                    exitButton.textContent = 'Exit Reader Mode';
                    
                    // Critical fix: Use a direct onclick attribute
                    exitButton.setAttribute('onclick', 'exitReaderMode()');
                    
                    const revealAllButton = document.createElement('button');
                    revealAllButton.className = 'reader-footer-button secondary';
                    revealAllButton.textContent = 'Reveal All';
                    
                   
                    revealAllButton.setAttribute('onclick', 'readerRevealAll()');
                    
                    footerButtons.appendChild(exitButton);
                    footerButtons.appendChild(revealAllButton);
                    
                    modalFooter.appendChild(statusText);
                    modalFooter.appendChild(footerButtons);
                    
                    // Assemble and add to document
                    modal.appendChild(modalHeader);
                    modal.appendChild(modalContent);
                    modal.appendChild(modalFooter);
                    modalBackdrop.appendChild(modal);
                    document.body.appendChild(modalBackdrop);
                    
                    // Store reference, though we're not relying on it for removal
                    this.modalElement = modalBackdrop;
                    
                    // Add a body class that we can use as another way to detect if reader mode is active
                    document.body.classList.add('reader-mode-active');
                    
                    // Add global escape key handler
                    document.addEventListener('keydown', function(e) {
                        if (e.key === 'Escape' && document.body.classList.contains('reader-mode-active')) {
                        exitReaderMode();
                        }
                    });
                    },
                    
                    addSentenceWithReflection: function(container, index) {
                        // Check bounds
                        if (index < 0 || index >= this.sentences.length) {
                            return;
                        }
                        
                        // Create a block for this sentence and its reflection
                        const block = document.createElement('div');
                        block.className = 'reader-sentence-block';
                        block.dataset.index = index;
                        
                        // Current sentence display
                        const sentenceDisplay = document.createElement('div');
                        sentenceDisplay.className = 'reader-sentence';
                        sentenceDisplay.textContent = this.sentences[index];
                        
                        // Reflection area
                        const reflectionArea = document.createElement('div');
                        reflectionArea.className = 'reader-reflection-wrapper';
                        
                        // Reflection prompt (changes based on position)
                        const reflectionPrompt = document.createElement('div');
                        reflectionPrompt.className = 'reader-prompt';
                        
                        if (index === 0) {
                            reflectionPrompt.innerHTML = '<strong>Reflect:</strong> What might your reader expect to come next?';
                        } else if (index === this.sentences.length - 1) {
                            reflectionPrompt.innerHTML = '<strong>Reflect:</strong> How does this concluding sentence complete the passage?';
                        } else {
                            reflectionPrompt.innerHTML = '<strong>Reflect:</strong> Did this sentence meet your expectations? What might come next?';
                        }
                        
                        // Reflection input
                        const reflectionInput = document.createElement('textarea');
                        reflectionInput.className = 'reader-reflection-input';
                        reflectionInput.rows = 3;
                        reflectionInput.placeholder = 'Enter your reflection here...';
                        reflectionInput.value = this.reflections[index] || '';
                        
                        // Save reflection as user types
                        reflectionInput.addEventListener('input', (e) => {
                            this.reflections[index] = e.target.value;
                        });
                        
                        // Reveal next button (only if not the last sentence)
                        if (index < this.sentences.length - 1) {
                            const revealButton = document.createElement('button');
                            revealButton.className = 'reader-reveal-button';
                            revealButton.innerHTML = 'Reveal Next Sentence <i class="fas fa-arrow-right"></i>';
                            
                            revealButton.addEventListener('click', () => {
                                // Hide this button once clicked
                                revealButton.style.display = 'none';
                                
                                // Move to next sentence index
                                this.currentSentenceIndex = index + 1;
                                
                                // Add the next sentence block
                                this.addSentenceWithReflection(container, index + 1);
                                
                                // Update counter in options
                                const sentenceCounter = document.getElementById('reader-sentence-counter');
                                if (sentenceCounter) {
                                    sentenceCounter.textContent = `Sentence ${this.currentSentenceIndex + 1} of ${this.sentences.length}`;
                                }
                                
                                // Update status text in modal footer
                                const statusText = document.querySelector('.reader-status-text');
                                if (statusText) {
                                    statusText.textContent = `Sentence ${this.currentSentenceIndex + 1} of ${this.sentences.length}`;
                                }
                                
                                // Scroll to the new block
                                const newBlock = container.querySelector(`.reader-sentence-block[data-index="${index + 1}"]`);
                                if (newBlock) {
                                    newBlock.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            });
                            
                            reflectionArea.appendChild(reflectionPrompt);
                            reflectionArea.appendChild(reflectionInput);
                            reflectionArea.appendChild(revealButton);
                        } else {
                            reflectionArea.appendChild(reflectionPrompt);
                            reflectionArea.appendChild(reflectionInput);
                        }
                        
                        // Assemble the block
                        block.appendChild(sentenceDisplay);
                        block.appendChild(reflectionArea);
                        
                        // Add to container
                        container.appendChild(block);
                        
                        // Focus on the reflection input
                        setTimeout(() => {
                            reflectionInput.focus();
                        }, 100);
                    },
                    
                    revealAllSentences: function(container) {
                        // Clear the container
                        container.innerHTML = '';
                        
                        // Add all sentences at once
                        for (let i = 0; i < this.sentences.length; i++) {
                            this.addSentenceWithReflection(container, i);
                            
                            // Hide reveal buttons since we're showing everything
                            const revealButton = container.querySelector(`.reader-sentence-block[data-index="${i}"] .reader-reveal-button`);
                            if (revealButton) {
                                revealButton.style.display = 'none';
                            }
                        }
                        
                        // Update current index
                        this.currentSentenceIndex = this.sentences.length - 1;
                        
                        // Update the status
                        const sentenceCounter = document.getElementById('reader-sentence-counter');
                        if (sentenceCounter) {
                            sentenceCounter.textContent = `All ${this.sentences.length} sentences revealed`;
                        }
                        
                        // Update status text in modal footer
                        const statusText = document.querySelector('.reader-status-text');
                        if (statusText) {
                            statusText.textContent = `All ${this.sentences.length} sentences revealed`;
                        }
                    }
                },


                wordCloud: {
    name: 'Word Cloud Mode',
    modalElement: null,
    canvas: null,
    ctx: null,
    settings: {
        maxWords: 50,
        minFontSize: 12,
        maxFontSize: 48,
        colorScheme: 'frequency',
        backgroundColor: '#ffffff',
        textColor: '#333333',
        excludeNumbers: true,
        minWordLength: 3,
        fontFamily: 'Arial, sans-serif',
        maxRotation: 90,
        rotationSteps: 2
    },
    wordFrequency: {},
    placedWords: [], // Track placed words for collision detection
    
    // Common stop words to exclude
    stopWords: new Set([
        'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with',
        'by', 'from', 'up', 'about', 'into', 'through', 'during', 'before', 'after',
        'above', 'below', 'between', 'among', 'until', 'while', 'within', 'since',
        'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had',
        'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might',
        'must', 'can', 'shall', 'this', 'that', 'these', 'those', 'i', 'you', 'he',
        'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them', 'my', 'your',
        'his', 'its', 'our', 'their', 'mine', 'yours', 'hers', 'ours', 'theirs',
        'who', 'what', 'where', 'when', 'why', 'how', 'which', 'whose', 'whom',
        'all', 'any', 'both', 'each', 'few', 'more', 'most', 'other', 'some',
        'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than', 'too',
        'very', 'just', 'now', 'then', 'here', 'there', 'also', 'however',
        'therefore', 'thus', 'furthermore', 'moreover', 'nevertheless', 'although',
        'because', 'if', 'unless', 'whether', 'as', 'like', 'one', 'two', 'three'
    ]),
    
    activate: function(options) {
        // Parse the document text
        this.parseText();
        
        // Create and show the word cloud modal
        this.createWordCloudModal();
        
        // Set up mode-specific options in the toolbar
        this.setupOptions();
        
        // Generate initial word cloud
        setTimeout(() => {
            this.generateWordCloud();
        }, 100);
        
        showNotification('Word Cloud Mode enabled - Analyzing word frequency', 'info');
    },
    
    deactivate: function() {
        // Remove the modal if it exists
        if (this.modalElement) {
            document.body.removeChild(this.modalElement);
            this.modalElement = null;
        }
        
        // Clear canvas references
        this.canvas = null;
        this.ctx = null;
        this.placedWords = [];
        
        // Clear mode options
        clearModeOptions();
        
        showNotification('Word Cloud Mode disabled', 'info');
    },
    
    getOptions: function() {
        return {
            wordCount: Object.keys(this.wordFrequency).length,
            maxFrequency: Math.max(...Object.values(this.wordFrequency))
        };
    },
    
    setupOptions: function() {
        // Clear existing options
        clearModeOptions();
        
        // Create regenerate button
        const regenerateButton = document.createElement('button');
        regenerateButton.className = 'toolbar-btn';
        regenerateButton.textContent = 'Regenerate';
        regenerateButton.setAttribute('aria-label', 'Regenerate word cloud');
        regenerateButton.addEventListener('click', () => {
            this.regenerateCloud();
        });
        
        // Create export button
        const exportButton = document.createElement('button');
        exportButton.className = 'toolbar-btn';
        exportButton.textContent = 'Export Image';
        exportButton.setAttribute('aria-label', 'Export word cloud as image');
        exportButton.addEventListener('click', () => this.exportImage());
        
        // Create container for the buttons
        const btnContainer = document.createElement('div');
        btnContainer.className = 'toolbar-group';
        btnContainer.appendChild(regenerateButton);
        btnContainer.appendChild(exportButton);
        
        // Add word count display
        const wordInfo = document.createElement('span');
        wordInfo.className = 'mode-option-label';
        wordInfo.textContent = `${Object.keys(this.wordFrequency).length} unique words found`;
        wordInfo.style.marginLeft = '10px';
        
        // Add all elements to options
        activeModeOptions.appendChild(btnContainer);
        activeModeOptions.appendChild(wordInfo);
    },
    
    createWordCloudModal: function() {
        // Create modal structure
        const modalBackdrop = document.createElement('div');
        modalBackdrop.className = 'word-cloud-modal-backdrop';
        
        const modal = document.createElement('div');
        modal.className = 'word-cloud-modal';
        
        // Modal header
        const modalHeader = document.createElement('div');
        modalHeader.className = 'word-cloud-modal-header';
        
        const modalTitle = document.createElement('h3');
        modalTitle.textContent = 'Word Cloud Analysis';
        
        const closeButton = document.createElement('button');
        closeButton.className = 'word-cloud-modal-close';
        closeButton.innerHTML = '&times;';
        closeButton.setAttribute('aria-label', 'Close Word Cloud');
        closeButton.addEventListener('click', () => {
            disableCurrentMode(false);
        });
        
        modalHeader.appendChild(modalTitle);
        modalHeader.appendChild(closeButton);
        
        // Modal content
        const modalContent = document.createElement('div');
        modalContent.className = 'word-cloud-content';
        
        // Sidebar with settings
        const sidebar = document.createElement('div');
        sidebar.className = 'word-cloud-sidebar';
        sidebar.innerHTML = this.createSettingsHTML();
        
        // Main area with canvas
        const mainArea = document.createElement('div');
        mainArea.className = 'word-cloud-main';
        
        const canvas = document.createElement('canvas');
        canvas.className = 'word-cloud-canvas';
        canvas.width = 700;
        canvas.height = 500;
        
        mainArea.appendChild(canvas);
        
        // Assemble content
        modalContent.appendChild(sidebar);
        modalContent.appendChild(mainArea);
        
        // Assemble modal
        modal.appendChild(modalHeader);
        modal.appendChild(modalContent);
        modalBackdrop.appendChild(modal);
        document.body.appendChild(modalBackdrop);
        
        // Store references
        this.modalElement = modalBackdrop;
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        
        // Set up event listeners for settings
        this.setupSettingsEventListeners();
    },
    
    createSettingsHTML: function() {
        return `
            <div class="word-cloud-settings">
                <h4>Word Cloud Settings</h4>
                
                <div class="word-cloud-setting">
                    <label for="max-words">Maximum Words</label>
                    <input type="range" id="max-words" min="10" max="100" value="${this.settings.maxWords}">
                    <div class="range-display">${this.settings.maxWords} words</div>
                </div>
                
                <div class="word-cloud-setting">
                    <label for="min-font-size">Minimum Font Size</label>
                    <input type="range" id="min-font-size" min="8" max="24" value="${this.settings.minFontSize}">
                    <div class="range-display">${this.settings.minFontSize}px</div>
                </div>
                
                <div class="word-cloud-setting">
                    <label for="max-font-size">Maximum Font Size</label>
                    <input type="range" id="max-font-size" min="24" max="72" value="${this.settings.maxFontSize}">
                    <div class="range-display">${this.settings.maxFontSize}px</div>
                </div>
                
                <div class="word-cloud-setting">
                    <label for="min-word-length">Minimum Word Length</label>
                    <input type="range" id="min-word-length" min="1" max="8" value="${this.settings.minWordLength}">
                    <div class="range-display">${this.settings.minWordLength} characters</div>
                </div>
                
                <div class="word-cloud-setting">
                    <label for="color-scheme">Color Scheme</label>
                    <select id="color-scheme">
                        <option value="professional">Professional</option>
                        <option value="frequency">Frequency-based</option>
                        <option value="rainbow">Rainbow</option>
                        <option value="warm">Warm Colors</option>
                        <option value="cool">Cool Colors</option>
                        <option value="monochrome">Monochrome</option>
                    </select>
                </div>
                
                <div class="word-cloud-setting">
                    <label for="font-family">Font Style</label>
                    <select id="font-family">
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Georgia, serif">Georgia</option>
                        <option value="Impact, sans-serif">Impact</option>
                        <option value="'Times New Roman', serif">Times New Roman</option>
                        <option value="'Trebuchet MS', sans-serif">Trebuchet MS</option>
                    </select>
                </div>
                
                <div class="word-cloud-setting">
                    <label for="background-color">Background Color</label>
                    <input type="color" id="background-color" value="${this.settings.backgroundColor}">
                </div>
                
                <div class="word-cloud-setting">
                    <label>
                        <input type="checkbox" id="exclude-numbers" ${this.settings.excludeNumbers ? 'checked' : ''}>
                        Exclude Numbers
                    </label>
                </div>
            </div>
            
            <div class="word-cloud-buttons">
                <button class="word-cloud-btn" id="regenerate-cloud">Regenerate Cloud</button>
                <button class="word-cloud-btn secondary" id="export-image">Export as Image</button>
                <button class="word-cloud-btn secondary" id="export-data">Export Word List</button>
            </div>
            
            <div class="word-cloud-stats">
                <h4>Statistics</h4>
                <p>Total words: <span id="total-words">0</span></p>
                <p>Unique words: <span id="unique-words">0</span></p>
                <p>Most frequent: <span id="most-frequent">-</span></p>
                <p>Displayed: <span id="displayed-words">0</span></p>
            </div>
        `;
    },
    
    setupSettingsEventListeners: function() {
        const modal = this.modalElement;
        
        // Range inputs with live updates
        const ranges = ['max-words', 'min-font-size', 'max-font-size', 'min-word-length'];
        ranges.forEach(rangeId => {
            const range = modal.querySelector(`#${rangeId}`);
            const display = range.nextElementSibling;
            
            range.addEventListener('input', (e) => {
                const value = e.target.value;
                const settingKey = rangeId.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
                this.settings[settingKey] = parseInt(value);
                
                // Update display
                if (rangeId === 'max-words') {
                    display.textContent = `${value} words`;
                } else if (rangeId === 'min-word-length') {
                    display.textContent = `${value} characters`;
                } else {
                    display.textContent = `${value}px`;
                }
                
                // Regenerate cloud after a brief delay
                clearTimeout(this.updateTimeout);
                this.updateTimeout = setTimeout(() => {
                    this.generateWordCloud();
                }, 300);
            });
        });
        
        // Color scheme selector
        modal.querySelector('#color-scheme').addEventListener('change', (e) => {
            this.settings.colorScheme = e.target.value;
            this.generateWordCloud();
        });
        
        // Font family selector
        modal.querySelector('#font-family').addEventListener('change', (e) => {
            this.settings.fontFamily = e.target.value;
            this.generateWordCloud();
        });
        
        // Background color
        modal.querySelector('#background-color').addEventListener('change', (e) => {
            this.settings.backgroundColor = e.target.value;
            this.generateWordCloud();
        });
        
        // Checkbox
        modal.querySelector('#exclude-numbers').addEventListener('change', (e) => {
            this.settings.excludeNumbers = e.target.checked;
            this.parseText();
            this.generateWordCloud();
        });
        
        // Buttons - Fixed event listeners
        modal.querySelector('#regenerate-cloud').addEventListener('click', () => {
            this.regenerateCloud();
        });
        
        modal.querySelector('#export-image').addEventListener('click', () => {
            this.exportImage();
        });
        
        modal.querySelector('#export-data').addEventListener('click', () => {
            this.exportWordData();
        });
    },
    
    // Fixed regenerate function
    regenerateCloud: function() {
        console.log('Regenerating word cloud...');
        this.parseText();
        this.generateWordCloud();
        showNotification('Word cloud regenerated', 'success');
    },
    
    parseText: function() {
        // Get text from editor
        const text = editor.innerText || '';
        
        // Reset word frequency
        this.wordFrequency = {};
        
        // Split into words and clean
        const words = text.toLowerCase()
            .replace(/[^\w\s]/g, ' ') // Replace punctuation with spaces
            .split(/\s+/)
            .filter(word => {
                // Filter out empty strings, stop words, and numbers if specified
                if (!word || this.stopWords.has(word)) return false;
                if (word.length < this.settings.minWordLength) return false;
                if (this.settings.excludeNumbers && /^\d+$/.test(word)) return false;
                return true;
            });
        
        // Count frequency
        words.forEach(word => {
            this.wordFrequency[word] = (this.wordFrequency[word] || 0) + 1;
        });
        
        // Update stats
        this.updateStats(text.split(/\s+/).length);
    },
    
    // Completely rewritten word cloud generation with better algorithm
    generateWordCloud: function() {
        if (!this.ctx) return;
        
        console.log('Generating word cloud with', Object.keys(this.wordFrequency).length, 'unique words');
        
        // Clear canvas
        this.ctx.fillStyle = this.settings.backgroundColor;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Reset placed words
        this.placedWords = [];
        
        // Get sorted words by frequency
        const sortedWords = Object.entries(this.wordFrequency)
            .sort((a, b) => b[1] - a[1])
            .slice(0, this.settings.maxWords);
        
        if (sortedWords.length === 0) {
            this.ctx.fillStyle = '#666';
            this.ctx.font = '16px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('No words to display', this.canvas.width / 2, this.canvas.height / 2);
            return;
        }
        
        const maxFreq = sortedWords[0][1];
        const minFreq = sortedWords[sortedWords.length - 1][1];
        
        // Calculate center point
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        
        // Place words using spiral algorithm
        sortedWords.forEach(([word, freq], index) => {
            // Calculate font size based on frequency
            const fontScale = (freq - minFreq) / (maxFreq - minFreq || 1);
            const fontSize = this.settings.minFontSize + 
                (this.settings.maxFontSize - this.settings.minFontSize) * fontScale;
            
            // Random rotation for visual interest
            const rotation = this.getRandomRotation();
            
            // Set font style - vary weight based on frequency
            const fontWeight = fontScale > 0.7 ? 'bold' : fontScale > 0.3 ? '600' : 'normal';
            this.ctx.font = `${fontWeight} ${fontSize}px ${this.settings.fontFamily}`;
            
            // Get text metrics
            const metrics = this.ctx.measureText(word);
            const textWidth = metrics.width;
            const textHeight = fontSize;
            
            // Find position using spiral algorithm
            let position = this.findWordPosition(textWidth, textHeight, centerX, centerY, rotation);
            
            if (position) {
                // Set color
                this.ctx.fillStyle = this.getWordColor(freq, maxFreq, index, sortedWords.length);
                
                // Save context for rotation
                this.ctx.save();
                
                // Apply rotation
                this.ctx.translate(position.x, position.y);
                this.ctx.rotate((rotation * Math.PI) / 180);
                
                // Draw the word
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(word, 0, 0);
                
                // Restore context
                this.ctx.restore();
                
                // Store the placed word for collision detection
                this.placedWords.push({
                    x: position.x,
                    y: position.y,
                    width: textWidth,
                    height: textHeight,
                    rotation: rotation,
                    word: word
                });
            }
        });
        
        // Update displayed words count
        const modal = this.modalElement;
        if (modal) {
            const displayedElement = modal.querySelector('#displayed-words');
            if (displayedElement) {
                displayedElement.textContent = this.placedWords.length;
            }
        }
        
        console.log('Word cloud generated with', this.placedWords.length, 'words placed');
    },
    
    // Spiral algorithm to find non-overlapping positions
    findWordPosition: function(width, height, centerX, centerY, rotation) {
        const maxRadius = Math.min(this.canvas.width, this.canvas.height) / 2;
        const spiralStep = 2;
        const angleStep = 0.1;
        
        // Start from center and spiral outward
        for (let radius = 0; radius < maxRadius; radius += spiralStep) {
            for (let angle = 0; angle < Math.PI * 2; angle += angleStep) {
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                // Check if position is within canvas bounds
                if (x - width/2 < 0 || x + width/2 > this.canvas.width ||
                    y - height/2 < 0 || y + height/2 > this.canvas.height) {
                    continue;
                }
                
                // Check for collisions with existing words
                if (!this.checkCollision(x, y, width, height, rotation)) {
                    return { x: x, y: y };
                }
            }
        }
        
        return null; // No position found
    },
    
    // Check if a word position collides with existing words
    checkCollision: function(x, y, width, height, rotation) {
        const padding = 2; // Minimum space between words
        
        for (let placedWord of this.placedWords) {
            // Simple bounding box collision detection
            const distance = Math.sqrt(
                Math.pow(x - placedWord.x, 2) + Math.pow(y - placedWord.y, 2)
            );
            
            const minDistance = Math.max(
                (width + placedWord.width) / 2 + padding,
                (height + placedWord.height) / 2 + padding
            );
            
            if (distance < minDistance) {
                return true; // Collision detected
            }
        }
        
        return false; // No collision
    },
    
    // Get random rotation for visual variety
    getRandomRotation: function() {
        const rotations = [-90, -45, 0, 45, 90];
        return rotations[Math.floor(Math.random() * rotations.length)];
    },
    
    // Improved color schemes
    getWordColor: function(freq, maxFreq, index, totalWords) {
        switch (this.settings.colorScheme) {
            case 'professional':
                // Professional color palette
                const profColors = ['#2C3E50', '#E74C3C', '#3498DB', '#E67E22', '#9B59B6', '#1ABC9C', '#F39C12', '#34495E'];
                return profColors[index % profColors.length];
                
            case 'frequency':
                // Color intensity based on frequency
                const intensity = freq / maxFreq;
                const r = Math.floor(87 * intensity + 168 * (1 - intensity));
                const g = Math.floor(6 * intensity + 249 * (1 - intensity));
                const b = Math.floor(140 * intensity + 115 * (1 - intensity));
                return `rgb(${r}, ${g}, ${b})`;
                
            case 'rainbow':
                // Rainbow colors
                const hue = (index / totalWords) * 360;
                return `hsl(${hue}, 70%, 50%)`;
                
            case 'warm':
                // Warm color palette
                const warmColors = ['#FF6B6B', '#FF8E53', '#FF6B9D', '#C44569', '#F8B500', '#FF7F50'];
                return warmColors[index % warmColors.length];
                
            case 'cool':
                // Cool color palette
                const coolColors = ['#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
                return coolColors[index % coolColors.length];
                
            case 'monochrome':
                // Different shades of gray/primary color
                const alpha = 0.3 + (freq / maxFreq) * 0.7;
                const color = this.hexToRgb(this.settings.textColor || '#333333');
                return `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
                
            default:
                return '#333333';
        }
    },
    
    updateStats: function(totalWords) {
        const modal = this.modalElement;
        if (!modal) return;
        
        const uniqueWords = Object.keys(this.wordFrequency).length;
        const mostFrequent = uniqueWords > 0 ? 
            Object.entries(this.wordFrequency).sort((a, b) => b[1] - a[1])[0] : 
            null;
        
        modal.querySelector('#total-words').textContent = totalWords;
        modal.querySelector('#unique-words').textContent = uniqueWords;
        modal.querySelector('#most-frequent').textContent = mostFrequent ? 
            `"${mostFrequent[0]}" (${mostFrequent[1]}x)` : '-';
    },
    
    exportImage: function() {
        if (!this.canvas) return;
        
        // Create download link
        const link = document.createElement('a');
        link.download = `word-cloud-${new Date().toISOString().slice(0, 10)}.png`;
        link.href = this.canvas.toDataURL('image/png');
        
        // Trigger download
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showNotification('Word cloud exported as image', 'success');
    },
    
    exportWordData: function() {
        // Create CSV data
        const sortedWords = Object.entries(this.wordFrequency)
            .sort((a, b) => b[1] - a[1]);
        
        let csvContent = 'Word,Frequency,Percentage\n';
        const totalFreq = Object.values(this.wordFrequency).reduce((a, b) => a + b, 0);
        
        sortedWords.forEach(([word, freq]) => {
            const percentage = ((freq / totalFreq) * 100).toFixed(2);
            csvContent += `"${word}",${freq},${percentage}%\n`;
        });
        
        // Create and download file
        const blob = new Blob([csvContent], { type: 'text/csv' });
        const link = document.createElement('a');
        link.download = `word-frequency-${new Date().toISOString().slice(0, 10)}.csv`;
        link.href = URL.createObjectURL(blob);
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // Clean up
        URL.revokeObjectURL(link.href);
        
        showNotification('Word frequency data exported', 'success');
    },
    
    // Helper function to convert hex to RGB
    hexToRgb: function(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
    }
},

sourceSynthesis: {
    name: 'Source Synthesis Mode',
    sources: [], // Will hold objects like {name: "Smith 2021", terms: ["example", "test*"], color: "#ff0000"}
    sourcesData: {}, // Will store sources for each document ID
    integrationStats: {}, // Will store statistics about source integration
    
    activate: function(options) {
        // Load saved data for current document
        if (DocumentManager.currentDocument && DocumentManager.currentDocument.id) {
            if (DocumentManager.currentDocument.sourceSynthesis && DocumentManager.currentDocument.sourceSynthesis.length > 0) {
                this.sources = DocumentManager.currentDocument.sourceSynthesis;
                this.sourcesData[DocumentManager.currentDocument.id] = DocumentManager.currentDocument.sourceSynthesis;
            } else {
                this.sources = this.sourcesData[DocumentManager.currentDocument.id] || [];
            }
        } else {
            this.sources = [];
        }
        
        // Reset sources if options provided to reset
        if (options && options.resetSources) {
            this.sources = [];
        }
        
        // Show the source synthesis panel
        this.showSourceSynthesisPanel();
        
        // Set up mode-specific options in the active indicator
        this.setupOptions();
        
        // Apply highlighting if there are already sources defined
        if (this.sources.length > 0) {
            this.applyHighlighting();
        }
        
        showNotification('Source Synthesis Mode enabled - Define sources to track', 'info');
    },
    
    deactivate: function() {
        // Hide the panel if it's open
        this.hideSourceSynthesisPanel();
        
        // Remove all highlighting
        this.removeHighlighting();
        
        // Remove any highlight styles from the document
        const styleElements = document.querySelectorAll('style[data-source-synthesis-style]');
        styleElements.forEach(el => el.remove());
        
        // Clear mode options
        clearModeOptions();
        
        // Make sure editor is editable
        editor.contentEditable = 'true';
        
        showNotification('Source Synthesis Mode disabled', 'info');
    },
    
    getOptions: function() {
        return {
            sourceCount: this.sources.length,
            integrationStats: this.integrationStats
        };
    },
    
    setupOptions: function() {
        // Clear existing options
        clearModeOptions();
        
        // Create highlight button
        const highlightButton = document.createElement('button');
        highlightButton.className = 'toolbar-btn';
        highlightButton.textContent = 'Apply Highlighting';
        highlightButton.setAttribute('aria-label', 'Apply source highlighting');
        highlightButton.addEventListener('click', () => this.applyHighlighting());
        
        // Create clear button
        const clearButton = document.createElement('button');
        clearButton.className = 'toolbar-btn';
        clearButton.textContent = 'Clear Highlighting';
        clearButton.setAttribute('aria-label', 'Clear all highlighting');
        clearButton.addEventListener('click', () => this.removeHighlighting());
        
        // Create edit sources button
        const editButton = document.createElement('button');
        editButton.className = 'toolbar-btn';
        editButton.textContent = 'Edit Sources';
        editButton.setAttribute('aria-label', 'Edit sources');
        editButton.addEventListener('click', () => this.showSourceSynthesisPanel());
        
        // Create export stats button
        const exportStatsButton = document.createElement('button');
        exportStatsButton.className = 'toolbar-btn';
        exportStatsButton.textContent = 'Export Analysis';
        exportStatsButton.setAttribute('aria-label', 'Export integration analysis');
        exportStatsButton.addEventListener('click', () => this.exportIntegrationAnalysis());
        
        // Create container for the buttons
        const btnContainer = document.createElement('div');
        btnContainer.className = 'toolbar-group';
        btnContainer.appendChild(editButton);
        btnContainer.appendChild(highlightButton);
        btnContainer.appendChild(clearButton);
        btnContainer.appendChild(exportStatsButton);
        
        // Add source count and integration stats display
        const statsContainer = document.createElement('div');
        statsContainer.className = 'toolbar-group';
        statsContainer.style.marginLeft = '15px';
        
        const sourceCount = document.createElement('span');
        sourceCount.className = 'mode-option-label';
        sourceCount.textContent = `${this.sources.length} source${this.sources.length !== 1 ? 's' : ''} defined`;
        
        // Add integration statistics if available
        if (this.integrationStats && this.integrationStats.totalSentences > 0) {
            const integrationInfo = document.createElement('div');
            integrationInfo.className = 'source-integration-stats';
            integrationInfo.style.fontSize = '0.85rem';
            integrationInfo.style.color = '#666';
            integrationInfo.style.marginTop = '5px';
            
            const multiSourcePercent = Math.round((this.integrationStats.multiSourceSentences / this.integrationStats.totalSentences) * 100);
            const multiParaPercent = Math.round((this.integrationStats.multiSourceParagraphs / this.integrationStats.totalParagraphs) * 100);
            
            integrationInfo.innerHTML = `
                <div><strong>Integration Analysis:</strong></div>
                <div>Multi-source sentences: ${this.integrationStats.multiSourceSentences}/${this.integrationStats.totalSentences} (${multiSourcePercent}%)</div>
                <div>Multi-source paragraphs: ${this.integrationStats.multiSourceParagraphs}/${this.integrationStats.totalParagraphs} (${multiParaPercent}%)</div>
            `;
            
            statsContainer.appendChild(sourceCount);
            statsContainer.appendChild(integrationInfo);
        } else {
            statsContainer.appendChild(sourceCount);
        }
        
        // Add all elements to options
        activeModeOptions.appendChild(btnContainer);
        activeModeOptions.appendChild(statsContainer);
    },
    
    showSourceSynthesisPanel: function() {
        // Check if the panel already exists
        let panel = document.getElementById('source-synthesis-panel');
        
        if (!panel) {
            // Create panel - REMOVED the stats section from the layout
            panel = document.createElement('div');
            panel.id = 'source-synthesis-panel';
            panel.className = 'modal';
            panel.setAttribute('role', 'dialog');
            panel.setAttribute('aria-labelledby', 'source-synthesis-title');
            
            // Create panel content WITHOUT stats section
            panel.innerHTML = `
                <div class="modal-content" style="max-width: 700px;">
                    <div class="modal-header">
                        <div id="source-synthesis-title" class="modal-title">Source Synthesis</div>
                        <button class="modal-close" aria-label="Close panel">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="source-synthesis-instructions">
                            <p><strong>Track your sources:</strong> Enter the name of each source (e.g., "Smith 2021", "Johnson") and list the key terms, phrases, or concepts associated with that source. Separate multiple terms with commas.</p>
                            <p><strong>Analyze integration:</strong> After highlighting, look for monochrome sections (single source) vs. multicolored sections (multiple sources in conversation).</p>
                            <p>Use <code>*</code> as a wildcard (e.g., <code>analy*</code> matches "analyze", "analysis", etc.)</p>
                        </div>
                        
                        <h4>Sources</h4>
                        <div id="source-list">
                            <!-- Source rows will be added here -->
                        </div>
                        
                        <button id="add-source-btn" class="action-btn" style="margin-top: 15px;">
                            <i class="fas fa-plus"></i> Add Source
                        </button>
                    </div>
                    <div class="modal-footer">
                        <button id="source-synthesis-cancel" class="action-btn">Cancel</button>
                        <button id="source-synthesis-apply" class="action-btn primary">Apply Highlighting</button>
                    </div>
                </div>
            `;
            
            // Add to document
            document.body.appendChild(panel);
            
            // Set up event listeners
            panel.querySelector('.modal-close').addEventListener('click', () => this.hideSourceSynthesisPanel());
            panel.querySelector('#source-synthesis-cancel').addEventListener('click', () => this.hideSourceSynthesisPanel());
            panel.querySelector('#source-synthesis-apply').addEventListener('click', () => {
                this.saveSources();
                this.applyHighlighting();
                // AUTOMATICALLY HIDE PANEL AFTER APPLYING HIGHLIGHTING
                this.hideSourceSynthesisPanel();
            });
            panel.querySelector('#add-source-btn').addEventListener('click', () => this.addSourceRow());
        }
        
        // Clear existing source rows
        const sourcesList = panel.querySelector('#source-list');
        sourcesList.innerHTML = '';
        
        // Add a row for each existing source
        if (this.sources.length > 0) {
            this.sources.forEach((source, index) => {
                this.addSourceRow(source.name, source.terms.join(', '), source.color);
            });
        } else {
            // Add an empty row if no sources exist
            this.addSourceRow();
        }
        
        // Show the panel
        panel.style.display = 'flex';
    },
    
    hideSourceSynthesisPanel: function() {
        const panel = document.getElementById('source-synthesis-panel');
        if (panel) {
            panel.style.display = 'none';
        }
    },
    
    addSourceRow: function(nameValue = '', termsValue = '', colorValue = '#ffff00') {
        const sourcesList = document.getElementById('source-list');
        
        const rowId = 'source-row-' + Date.now();
        const row = document.createElement('div');
        row.id = rowId;
        row.className = 'source-row';
        
        // Source name input
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.className = 'form-input source-name-input';
        nameInput.placeholder = 'Source name (e.g., Smith 2021)';
        nameInput.value = nameValue;
        
        // Terms input
        const termsInput = document.createElement('input');
        termsInput.type = 'text';
        termsInput.className = 'form-input source-terms-input';
        termsInput.placeholder = 'Associated terms, separated by commas';
        termsInput.value = termsValue;
        
        // Color selector
        const colorInput = document.createElement('input');
        colorInput.type = 'color';
        colorInput.className = 'color-input';
        colorInput.value = colorValue;
        
        // Remove button
        const removeBtn = document.createElement('button');
        removeBtn.className = 'action-btn';
        removeBtn.innerHTML = '<i class="fas fa-trash"></i>';
        removeBtn.setAttribute('aria-label', 'Remove source');
        removeBtn.addEventListener('click', () => {
            row.remove();
        });
        
        // Assemble row
        row.appendChild(nameInput);
        row.appendChild(termsInput);
        row.appendChild(colorInput);
        row.appendChild(removeBtn);
        
        // Add to list
        sourcesList.appendChild(row);
        
        // Focus the new input
        nameInput.focus();
    },
    
    saveSources: function() {
        const panel = document.getElementById('source-synthesis-panel');
        if (!panel) return;
        
        // Clear existing sources
        this.sources = [];
        
        // Get all source rows
        const rows = panel.querySelectorAll('#source-list > div');
        
        rows.forEach(row => {
            const nameInput = row.querySelector('.source-name-input');
            const termsInput = row.querySelector('.source-terms-input');
            const colorInput = row.querySelector('.color-input');
            
            if (nameInput && termsInput && colorInput && nameInput.value.trim() && termsInput.value.trim()) {
                // Split by comma and trim each term
                const termsList = termsInput.value.split(',').map(term => term.trim()).filter(term => term);
                
                if (termsList.length > 0) {
                    this.sources.push({
                        name: nameInput.value.trim(),
                        terms: termsList,
                        color: colorInput.value
                    });
                }
            }
        });
        
        // Save sources for the current document
        if (DocumentManager.currentDocument && DocumentManager.currentDocument.id) {
            // Store in sourcesData object
            this.sourcesData[DocumentManager.currentDocument.id] = this.sources;
            
            // Also update the document object directly
            DocumentManager.currentDocument.sourceSynthesis = this.sources;
            
            // Save the document to persist changes
            DocumentManager.saveDocument();
        }
        
        // Update the source count in the options
        this.setupOptions();
    },
    
    applyHighlighting: function() {
        // First, remove any existing highlighting
        this.removeHighlighting();

        if (this.sources.length === 0) {
            showNotification('No sources defined for highlighting', 'warning');
            return;
        }
        
        // Make editor temporarily not editable to apply highlighting
        const wasEditable = editor.contentEditable;
        editor.contentEditable = 'false';
        
        // Create an object to store highlight styles
        const highlightStyles = {};
        
        // Process each source to prepare regex patterns
        const sourcePatterns = this.sources.map(source => {
            // Create patterns for each term in the source
            const patterns = source.terms.map(term => {
                // Check if it's a wildcard term
                const isWildcard = term.includes('*');
                let pattern;
                
                if (isWildcard) {
                    // Convert wildcard to regex pattern
                    const termBase = term.replace('*', '');
                    const escapedTerm = this.escapeRegex(termBase);
                    pattern = new RegExp(`^${escapedTerm}\\w*$`, 'i');
                } else {
                    // Create pattern for exact match (case insensitive)
                    const escapedTerm = this.escapeRegex(term);
                    pattern = new RegExp(`^${escapedTerm}$`, 'i');
                }
                
                return {
                    original: term,
                    pattern: pattern
                };
            });
            
            // Generate a unique class name for this source
            const highlightClass = `source-highlight-${this.generateId()}`;
            
            // Store style information
            highlightStyles[highlightClass] = {
                color: source.color,
                name: source.name
            };
            
            return {
                patterns: patterns,
                highlightClass: highlightClass,
                name: source.name,
                color: source.color
            };
        });
        
        // Add styles for all highlight classes
        Object.entries(highlightStyles).forEach(([className, data]) => {
            this.addHighlightStyle(className, data.color, data.name);
        });
        
        // Walk through the DOM tree and apply highlighting to text nodes only
        const walkDOM = (node) => {
            // Skip highlight spans we've already created
            if (node.classList && node.classList.contains('source-highlight')) {
                return;
            }
            
            // Process text nodes
            if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
                // Split text into words while preserving whitespace and punctuation
                const text = node.textContent;
                const words = [];
                let currentWord = '';
                let currentNonWord = '';
                
                // Helper to add current segments to the arrays
                const addSegments = () => {
                    if (currentWord) words.push({ type: 'word', text: currentWord });
                    if (currentNonWord) words.push({ type: 'nonword', text: currentNonWord });
                    currentWord = '';
                    currentNonWord = '';
                };
                
                // Split text into word and non-word segments
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    if (/\w/.test(char)) {
                        // If we were collecting non-word chars and now found a word char
                        if (currentNonWord) {
                            words.push({ type: 'nonword', text: currentNonWord });
                            currentNonWord = '';
                        }
                        currentWord += char;
                    } else {
                        // If we were collecting word chars and now found a non-word char
                        if (currentWord) {
                            words.push({ type: 'word', text: currentWord });
                            currentWord = '';
                        }
                        currentNonWord += char;
                    }
                }
                
                // Add any remaining segments
                addSegments();
                
                // If we have words to process
                if (words.length > 0) {
                    // Create a document fragment to build the new content
                    const fragment = document.createDocumentFragment();
                    
                    // Process each segment
                    words.forEach(segment => {
                        if (segment.type === 'nonword') {
                            // For non-word segments, just add a text node
                            fragment.appendChild(document.createTextNode(segment.text));
                        } else {
                            // For word segments, check for matches
                            const matchingSources = [];
                            
                            // Check each source pattern
                            for (let i = 0; i < sourcePatterns.length; i++) {
                                const sourcePattern = sourcePatterns[i];
                                
                                // Check each pattern in this source
                                for (let j = 0; j < sourcePattern.patterns.length; j++) {
                                    const pattern = sourcePattern.patterns[j];
                                    
                                    if (pattern.pattern.test(segment.text)) {
                                        matchingSources.push(sourcePattern);
                                        break; // Found a match for this source, no need to check other patterns
                                    }
                                }
                            }
                            
                            if (matchingSources.length > 0) {
                                // Create a highlight span
                                const span = document.createElement('span');
                                
                                if (matchingSources.length === 1) {
                                    // Single source
                                    span.className = `source-highlight ${matchingSources[0].highlightClass}`;
                                    span.setAttribute('title', `Source: ${matchingSources[0].name}`);
                                    span.setAttribute('data-source-count', '1');
                                    span.setAttribute('data-sources', matchingSources[0].name);
                                } else {
                                    // Multiple sources - create a special multi-source highlight
                                    span.className = 'source-highlight multi-source-highlight';
                                    const sourceNames = matchingSources.map(s => s.name).join(', ');
                                    span.setAttribute('title', `Sources: ${sourceNames}`);
                                    span.setAttribute('data-source-count', matchingSources.length.toString());
                                    span.setAttribute('data-sources', sourceNames);
                                    
                                    // Create a gradient background with the source colors
                                    const colors = matchingSources.map(s => s.color);
                                    const gradientStops = colors.map((color, index) => {
                                        const position = (index / colors.length) * 100;
                                        const nextPosition = ((index + 1) / colors.length) * 100;
                                        return `${color} ${position}%, ${color} ${nextPosition}%`;
                                    }).join(', ');
                                    
                                    span.style.background = `linear-gradient(45deg, ${gradientStops})`;
                                    span.style.border = '1px solid rgba(0,0,0,0.3)';
                                }
                                
                                span.textContent = segment.text;
                                fragment.appendChild(span);
                            } else {
                                // No match, add as plain text
                                fragment.appendChild(document.createTextNode(segment.text));
                            }
                        }
                    });
                    
                    // Replace the original text node with our processed fragment
                    node.parentNode.replaceChild(fragment, node);
                }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                // Skip script and style elements
                if (node.tagName.toLowerCase() === 'script' || 
                    node.tagName.toLowerCase() === 'style') {
                    return;
                }
                
                // Process child nodes (make a copy of the list as it might change during processing)
                Array.from(node.childNodes).forEach(child => {
                    walkDOM(child);
                });
            }
        };
        
        // Start walking the DOM from the editor
        walkDOM(editor);
        
        // Restore editability
        editor.contentEditable = wasEditable;
        
        // Calculate integration statistics
        this.calculateIntegrationStats();
        
        // Update the options toolbar with new stats
        this.setupOptions();
        
        showNotification('Sources highlighted - Check integration statistics in the toolbar', 'success');
    },
    
    calculateIntegrationStats: function() {
        // Initialize stats object
        this.integrationStats = {
            totalSentences: 0,
            singleSourceSentences: 0,
            multiSourceSentences: 0,
            unsourcedSentences: 0,
            totalParagraphs: 0,
            singleSourceParagraphs: 0,
            multiSourceParagraphs: 0,
            sourceUsage: {}
        };
        
        // Initialize source usage tracking
        this.sources.forEach(source => {
            this.integrationStats.sourceUsage[source.name] = 0;
        });
        
        // Get all paragraphs
        const paragraphs = editor.querySelectorAll('p, div, h1, h2, h3, h4, h5, h6');
        this.integrationStats.totalParagraphs = paragraphs.length;
        
        paragraphs.forEach(paragraph => {
            // Get all highlighted spans in this paragraph
            const highlightedSpans = paragraph.querySelectorAll('.source-highlight');
            
            // Track unique sources in this paragraph
            const paragraphSources = new Set();
            
            // Process each sentence in the paragraph
            const sentences = this.splitIntoSentences(paragraph.textContent);
            
            sentences.forEach(sentence => {
                this.integrationStats.totalSentences++;
                
                // Find highlighted spans that contain words from this sentence
                const sentenceHighlights = [];
                highlightedSpans.forEach(span => {
                    if (sentence.includes(span.textContent.trim())) {
                        sentenceHighlights.push(span);
                        
                        // Track source usage
                        const sources = span.getAttribute('data-sources');
                        if (sources) {
                            sources.split(', ').forEach(sourceName => {
                                if (this.integrationStats.sourceUsage[sourceName] !== undefined) {
                                    this.integrationStats.sourceUsage[sourceName]++;
                                }
                                paragraphSources.add(sourceName);
                            });
                        }
                    }
                });
                
                // Categorize the sentence
                if (sentenceHighlights.length === 0) {
                    this.integrationStats.unsourcedSentences++;
                } else {
                    // Check if sentence has multiple sources
                    const sentenceSources = new Set();
                    sentenceHighlights.forEach(span => {
                        const sourceCount = parseInt(span.getAttribute('data-source-count') || '1');
                        if (sourceCount > 1) {
                            this.integrationStats.multiSourceSentences++;
                            return; // This sentence definitely has multiple sources
                        } else {
                            const sources = span.getAttribute('data-sources');
                            if (sources) {
                                sources.split(', ').forEach(source => sentenceSources.add(source));
                            }
                        }
                    });
                    
                    if (sentenceSources.size > 1) {
                        this.integrationStats.multiSourceSentences++;
                    } else if (sentenceSources.size === 1) {
                        this.integrationStats.singleSourceSentences++;
                    }
                }
            });
            
            // Categorize the paragraph
            if (paragraphSources.size > 1) {
                this.integrationStats.multiSourceParagraphs++;
            } else if (paragraphSources.size === 1) {
                this.integrationStats.singleSourceParagraphs++;
            }
        });
    },
    
    splitIntoSentences: function(text) {
        // Simple sentence splitting - could be enhanced
        return text.split(/[.!?]+/).filter(sentence => sentence.trim().length > 0);
    },
    
    exportIntegrationAnalysis: function() {
        if (!this.integrationStats || this.integrationStats.totalSentences === 0) {
            showNotification('No integration statistics available. Apply highlighting first.', 'warning');
            return;
        }
        
        // Create title for new document
        const title = (DocumentManager.currentDocument?.title || 'Untitled') + ' - Source Integration Analysis';
        
        // Calculate percentages
        const stats = this.integrationStats;
        const multiSentencePercent = Math.round((stats.multiSourceSentences / stats.totalSentences) * 100);
        const multiParaPercent = Math.round((stats.multiSourceParagraphs / stats.totalParagraphs) * 100);
        
        // Create content for the new document - REMOVED evaluations and suggestions
        let content = '<h1>Source Integration Analysis</h1>';
        content += `<h2>${DocumentManager.currentDocument?.title || 'Untitled Document'}</h2>`;
        content += `<p><em>Analysis conducted on ${new Date().toLocaleDateString()}</em></p>`;
        
        // Detailed Statistics
        content += '<h3>Integration Statistics</h3>';
        content += '<table style="width:100%; border-collapse: collapse; margin: 20px 0;">';
        content += '<tr style="background-color: #f2f2f2; border: 1px solid #ddd;"><th style="padding: 10px; border: 1px solid #ddd;">Metric</th><th style="padding: 10px; border: 1px solid #ddd;">Count</th><th style="padding: 10px; border: 1px solid #ddd;">Percentage</th></tr>';
        
        // Sentence-level data
        content += `<tr><td style="padding: 8px; border: 1px solid #ddd;">Total Sentences</td><td style="padding: 8px; border: 1px solid #ddd;">${stats.totalSentences}</td><td style="padding: 8px; border: 1px solid #ddd;">100%</td></tr>`;
        content += `<tr><td style="padding: 8px; border: 1px solid #ddd;">Multi-Source Sentences</td><td style="padding: 8px; border: 1px solid #ddd;">${stats.multiSourceSentences}</td><td style="padding: 8px; border: 1px solid #ddd;">${multiSentencePercent}%</td></tr>`;
        content += `<tr><td style="padding: 8px; border: 1px solid #ddd;">Single-Source Sentences</td><td style="padding: 8px; border: 1px solid #ddd;">${stats.singleSourceSentences}</td><td style="padding: 8px; border: 1px solid #ddd;">${Math.round((stats.singleSourceSentences / stats.totalSentences) * 100)}%</td></tr>`;
        content += `<tr><td style="padding: 8px; border: 1px solid #ddd;">Unsourced Sentences</td><td style="padding: 8px; border: 1px solid #ddd;">${stats.unsourcedSentences}</td><td style="padding: 8px; border: 1px solid #ddd;">${Math.round((stats.unsourcedSentences / stats.totalSentences) * 100)}%</td></tr>`;
        
        // Paragraph-level data
        content += `<tr style="background-color: #f9f9f9;"><td style="padding: 8px; border: 1px solid #ddd;"><strong>Total Paragraphs</strong></td><td style="padding: 8px; border: 1px solid #ddd;"><strong>${stats.totalParagraphs}</strong></td><td style="padding: 8px; border: 1px solid #ddd;"><strong>100%</strong></td></tr>`;
        content += `<tr><td style="padding: 8px; border: 1px solid #ddd;">Multi-Source Paragraphs</td><td style="padding: 8px; border: 1px solid #ddd;">${stats.multiSourceParagraphs}</td><td style="padding: 8px; border: 1px solid #ddd;">${multiParaPercent}%</td></tr>`;
        content += `<tr><td style="padding: 8px; border: 1px solid #ddd;">Single-Source Paragraphs</td><td style="padding: 8px; border: 1px solid #ddd;">${stats.singleSourceParagraphs}</td><td style="padding: 8px; border: 1px solid #ddd;">${Math.round((stats.singleSourceParagraphs / stats.totalParagraphs) * 100)}%</td></tr>`;
        
        content += '</table>';
        
        // Source usage
        content += '<h3>Source Usage Distribution</h3>';
        content += '<ul>';
        Object.entries(stats.sourceUsage)
            .sort((a, b) => b[1] - a[1])
            .forEach(([sourceName, count]) => {
                content += `<li><strong>${sourceName}:</strong> ${count} mentions</li>`;
            });
        content += '</ul>';
        
        // Create new document with this content
        const docId = DocumentManager.createNewDocument(title, '');
        
        // Find the new document and update its content
        const newDoc = DocumentManager.documents.find(doc => doc.id === docId);
        if (newDoc) {
            newDoc.content = content;
            DocumentManager.saveDocument();
            
            // Show notification
            showNotification('Integration analysis exported to a new document');
        }
    },
    
    removeHighlighting: function() {
        // Find all highlight spans
        const highlightSpans = editor.querySelectorAll('.source-highlight');
        
        if (highlightSpans.length === 0) return;
        
        // Make editor temporarily not editable
        const wasEditable = editor.contentEditable;
        editor.contentEditable = 'false';
        
        // Remove each highlight span while preserving its content
        highlightSpans.forEach(span => {
            const parent = span.parentNode;
            if (parent) {
                // Replace the span with its text content
                const text = document.createTextNode(span.textContent);
                parent.replaceChild(text, span);
            }
        });
        
        // Normalize the editor to combine adjacent text nodes
        editor.normalize();
        
        // Remove any highlight styles
        const styleElements = document.querySelectorAll('style[data-source-synthesis-style]');
        styleElements.forEach(el => el.remove());
        
        // Clear stats
        this.integrationStats = {};
        
        // Update options
        this.setupOptions();
        
        // Restore editability
        editor.contentEditable = wasEditable;
    },
    
    // Helper function to escape special regex characters
    escapeRegex: function(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    },
    
    // Generate a unique ID for highlight classes
    generateId: function() {
        return `id-${Math.random().toString(36).substr(2, 9)}`;
    },
    
    // Add a style for a highlight class
    addHighlightStyle: function(className, color, sourceName) {
        // Create style element
        const style = document.createElement('style');
        style.setAttribute('data-source-synthesis-style', 'true');
        
        // Create CSS rule with semi-transparent background
        const rgba = this.hexToRgba(color, 0.3);
        
        style.textContent = `
            .${className} {
                background-color: ${rgba};
                border-bottom: 1px solid ${color};
                border-radius: 2px;
                padding: 0 2px;
                margin: 0 -2px;
            }
            
            .${className}:hover {
                background-color: ${this.hexToRgba(color, 0.5)};
            }
        `;
        
        // Add to document head
        document.head.appendChild(style);
    },
    
    // Convert hex color to rgba
    hexToRgba: function(hex, alpha = 1) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
}, 


// Add this to the modes object in your existing code

greening: {
    name: 'Greening Mode',
    originalContent: null,
    goalType: null, // 'percentage', 'wordCount', 'lineCount'
    goalValue: 0,
    originalStats: {
        wordCount: 0,
        lineCount: 0,
        charCount: 0
    },
    selectedForDeletion: [], // Array of {id, element, text, wordCount}
    selectionCounter: 0,
    isActive: false,
    
    activate: function(options) {
        console.log('Activating Greening Mode');
        
        // Store original content
        this.originalContent = editor.innerHTML;
        
        // Calculate original statistics
        this.calculateOriginalStats();
        
        // Reset state
        this.selectedForDeletion = [];
        this.selectionCounter = 0;
        this.isActive = false;
        this.isTutorial = false;
        
        // Check if this is a first-time user or if tutorial is requested
        const hasSeenTutorial = localStorage.getItem('greening_tutorial_completed');
        
        if (!hasSeenTutorial || (options && options.tutorial)) {
            this.showTutorialModal();
        } else {
            this.showGoalModal();
        }
        
        // Set up mode-specific options (will be populated after goal is set)
        this.setupOptions();
        
        showNotification('Greening Mode activated', 'info');
    },
    
    deactivate: function() {
        // Remove greening-specific elements
        this.clearGreeningElements();
        
        // Restore original content if user wants to cancel
        if (this.originalContent && !this.isCompleted) {
            if (confirm('Exit Greening Mode? All greening selections will be lost.')) {
                editor.innerHTML = this.originalContent;
            } else {
                return; // Don't deactivate if user cancels
            }
        }
        
        // Remove event listeners
        this.removeEventListeners();
        
        // Reset state
        this.goalType = null;
        this.goalValue = 0;
        this.selectedForDeletion = [];
        this.isActive = false;
        
        // Clear mode options
        clearModeOptions();
        
        showNotification('Greening Mode disabled', 'info');
    },
    
    getOptions: function() {
        return {
            goalType: this.goalType,
            goalValue: this.goalValue,
            progress: this.calculateProgress(),
            isCompleted: this.isGoalMet()
        };
    },
    
    setupOptions: function() {
        clearModeOptions();
        
        if (!this.goalType) {
            // Show goal setting prompt
            const goalPrompt = document.createElement('span');
            goalPrompt.className = 'mode-option-label';
            goalPrompt.textContent = 'Set your greening goal first';
            goalPrompt.style.color = '#f44336';
            activeModeOptions.appendChild(goalPrompt);
            return;
        }
        
        // Create progress display
        const progressContainer = document.createElement('div');
        progressContainer.className = 'greening-progress-container';
        progressContainer.style.display = 'flex';
        progressContainer.style.alignItems = 'center';
        progressContainer.style.gap = '15px';
        
        // Goal description
        const goalText = document.createElement('span');
        goalText.className = 'mode-option-label';
        goalText.innerHTML = this.getGoalDescription();
        
        // Progress indicator
        const progressIndicator = document.createElement('div');
        progressIndicator.id = 'greening-progress';
        progressIndicator.className = 'greening-progress';
        progressIndicator.style.padding = '5px 12px';
        progressIndicator.style.backgroundColor = '#e8f5e8';
        progressIndicator.style.border = '1px solid #4caf50';
        progressIndicator.style.borderRadius = '15px';
        progressIndicator.style.fontSize = '0.9rem';
        progressIndicator.style.fontWeight = '600';
        this.updateProgressDisplay(progressIndicator);
        
        // Control buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'toolbar-group';
        
        // Clear selections button
        const clearBtn = document.createElement('button');
        clearBtn.className = 'toolbar-btn';
        clearBtn.innerHTML = '<i class="fas fa-eraser"></i> Clear';
        clearBtn.setAttribute('aria-label', 'Clear all greening selections');
        clearBtn.addEventListener('click', () => this.clearAllSelections());
        
        // Apply greening button
        const applyBtn = document.createElement('button');
        applyBtn.className = 'toolbar-btn';
        applyBtn.innerHTML = '<i class="fas fa-cut"></i> Apply Cuts';
        applyBtn.setAttribute('aria-label', 'Apply greening cuts');
        applyBtn.addEventListener('click', () => this.applyGreening());
        
        // Goal settings button
        const goalBtn = document.createElement('button');
        goalBtn.className = 'toolbar-btn';
        goalBtn.innerHTML = '<i class="fas fa-target"></i> Change Goal';
        goalBtn.setAttribute('aria-label', 'Change greening goal');
        goalBtn.addEventListener('click', () => this.showGoalModal());
        
        buttonContainer.appendChild(goalBtn);
        buttonContainer.appendChild(clearBtn);
        buttonContainer.appendChild(applyBtn);
        
        // Assemble all elements
        progressContainer.appendChild(goalText);
        progressContainer.appendChild(progressIndicator);
        
        activeModeOptions.appendChild(progressContainer);
        activeModeOptions.appendChild(buttonContainer);
    },
    
    showTutorialModal: function() {
        // Create tutorial modal if it doesn't exist
        let modal = document.getElementById('greening-tutorial-modal');
        
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'greening-tutorial-modal';
            modal.className = 'modal';
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-labelledby', 'greening-tutorial-title');
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
                    <div class="modal-header">
                        <div id="greening-tutorial-title" class="modal-title">Learn Greening: John McPhee's Editing Practice</div>
                        <button class="modal-close" aria-label="Close">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div style="background-color: #f9f4ff; padding: 20px; border-radius: 8px; margin-bottom: 25px; border-left: 4px solid var(--primary-color, #57068c);">
                            <h3 style="color: var(--primary-color, #57068c); margin-top: 0;">What is Greening?</h3>
                            <p style="font-size: 1rem; line-height: 1.6; margin-bottom: 15px;">
                                <strong>"Greening"</strong> is a precise editing technique developed by renowned writer John McPhee. 
                                At <em>The New Yorker</em>, editors would leave notes like "Green 5" or "Green 8" on articles, 
                                meaning the writer had to reduce the text by that many lines to fit the magazine's layout.
                            </p>
                            <p style="font-size: 1rem; line-height: 1.6; margin-bottom: 0;">
                                The challenge: <strong>Remove text so skillfully that no reader would notice anything is missing.</strong> 
                                You must preserve the author's voice, style, and meaning while making the piece more concise.
                            </p>
                        </div>
                        
                        <div style="background-color: #e8f5e8; padding: 15px; border-radius: 6px; margin-bottom: 20px;">
                            <h4 style="color: #2e7d32; margin-top: 0;">Your Challenge</h4>
                            <p style="color: #1b5e20; margin-bottom: 0;">
                                Practice on McPhee's own passage! We'll load this text into the editor and challenge you to 
                                <strong>"Green 5"</strong> - reduce it by 5 lines while preserving its meaning and voice.
                            </p>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button id="tutorial-skip" class="action-btn">Skip Tutorial</button>
                        <button id="tutorial-start" class="action-btn primary">Start Practice Session</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            this.setupTutorialModalEvents(modal);
        }
        
        // Show modal
        modal.style.display = 'flex';
        
        // Focus the start button
        const startBtn = modal.querySelector('#tutorial-start');
        if (startBtn) {
            setTimeout(() => startBtn.focus(), 100);
        }
    },
    
    setupTutorialModalEvents: function(modal) {
        modal.querySelector('.modal-close').addEventListener('click', () => this.hideTutorialModal());
        modal.querySelector('#tutorial-skip').addEventListener('click', () => {
            this.hideTutorialModal();
            this.showGoalModal();
        });
        modal.querySelector('#tutorial-start').addEventListener('click', () => {
            this.hideTutorialModal();
            this.startTutorial();
        });
    },
    
    hideTutorialModal: function() {
        const modal = document.getElementById('greening-tutorial-modal');
        if (modal) {
            modal.style.display = 'none';
        }
    },
    
    startTutorial: function() {
        // Mark as tutorial mode
        this.isTutorial = true;
        
        // Load McPhee passage into editor
        const mcPhoePassage = `<h2>Practice Passage: "Omission" by John McPhee</h2>
<p><em>Your challenge: Green 5 lines from this passage while preserving McPhee's voice and meaning.</em></p>

<p>After four days of preparation and writing—after routinely staying up almost all night on the fourth night—and after tailoring your stories past the requests, demands, fine tips, and incomprehensible suggestions of the managing editor and your senior editor, you came in Day 5 and were greeted by galleys from Makeup with notes on them that said "Green 3" or "Green 8" or "Green 15" or some such, telling you to condense the text by that number of lines or the piece would not fit in the magazine. You were supposed to use a green pencil so Makeup would know what could be put back, if it came to that. I can't remember it coming to that.</p>

<p>Groan as much as you liked, you had to green nearly all your pieces, and greening was a craft in itself—studying your completed and approved product, your "finished" piece, to see what could be left out. In fifty years, The New Yorker's makeup department has asked me only once to remove some lines so a piece would fit. Greening has stayed with me, though, because for four decades I have inflicted it on my college writing students, handing them nine or ten swatches of photocopied prose, each marked "Green 3" or "Green 4" or whatever.</p>

<p>Green 4 does not mean lop off four lines at the bottom, I tell them. The idea is to remove words in such a manner that no one would notice that anything has been removed. Easier with some writers than with others. It's as if you were removing freight cars here and there in order to shorten a train—or pruning bits and pieces of a plant for reasons of aesthetics or plant pathology, not to mention size. Do not do violence to the author's tone, manner, nature, style, thumbprint. Measure cumulatively the fragments you remove and see how many lines would be gone if the prose were reformatted.</p>`;
        
        editor.innerHTML = mcPhoePassage;
        
        // Set tutorial goal: Green 5 lines
        this.goalType = 'lineCount';
        this.goalValue = 5;
        
        // Calculate stats for the tutorial passage
        this.calculateOriginalStats();
        
        // Start greening mode
        this.startGreening();
        
        // Show tutorial-specific notification
        showNotification('Tutorial started! Try to "Green 5" - reduce by 5 lines. Double-click words or drag to select text for removal.', 'info');
        
        // Add tutorial completion tracking
        this.setupTutorialCompletion();
    },
    
    setupTutorialCompletion: function() {
        // Override the apply greening function for tutorial
        this.originalApplyGreening = this.applyGreening;
        this.applyGreening = () => {
            // Call original function
            this.originalApplyGreening();
            
            // Show tutorial completion
            setTimeout(() => {
                this.showTutorialCompletion();
            }, 1000);
        };
    },
    
    showTutorialCompletion: function() {
        // Mark tutorial as completed
        localStorage.setItem('greening_tutorial_completed', 'true');
        
        // Create completion modal
        let modal = document.getElementById('greening-tutorial-complete-modal');
        
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'greening-tutorial-complete-modal';
            modal.className = 'modal';
            modal.setAttribute('role', 'dialog');
            
            const finalWordCount = this.countWords(editor.innerText);
            const wordsReduced = this.originalStats.wordCount - finalWordCount;
            const linesReduced = Math.round(wordsReduced / 12); // Approximate lines
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px;">
                    <div class="modal-header">
                        <div class="modal-title">🎯 Tutorial Complete!</div>
                        <button class="modal-close" aria-label="Close">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 3rem; margin-bottom: 10px;">✅</div>
                            <h3 style="color: var(--primary-color, #57068c); margin-bottom: 15px;">Great work!</h3>
                            <p style="font-size: 1.1rem; margin-bottom: 20px;">
                                You reduced the passage by <strong>${wordsReduced} words</strong> 
                                (approximately <strong>${linesReduced} lines</strong>).
                            </p>
                        </div>
                        
                        <div style="background-color: #f8f9fa; padding: 15px; border-radius: 6px; margin-bottom: 20px;">
                            <h4 style="margin-top: 0;">Greening Principles to Remember:</h4>
                            <ul style="margin-bottom: 0; padding-left: 20px;">
                                <li>Remove words "so no one would notice anything has been removed"</li>
                                <li>Preserve the author's voice, style, and tone</li>
                                <li>Think of it like "removing freight cars to shorten a train"</li>
                                <li>Look for redundancy, filler words, and unnecessary modifiers</li>
                                <li>Every word should earn its place</li>
                            </ul>
                        </div>
                        
                        <div style="background-color: #e8f5e8; padding: 15px; border-radius: 6px;">
                            <h4 style="color: #2e7d32; margin-top: 0;">Ready for Your Own Writing?</h4>
                            <p style="color: #1b5e20; margin-bottom: 0;">
                                Now you can apply greening to your own documents. Use this technique to meet word limits, 
                                improve concision, or simply practice the craft of precise editing.
                            </p>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button id="tutorial-complete-close" class="action-btn primary">Start Greening My Writing</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Set up close handler
            modal.querySelector('.modal-close').addEventListener('click', () => this.hideTutorialCompleteModal());
            modal.querySelector('#tutorial-complete-close').addEventListener('click', () => {
                this.hideTutorialCompleteModal();
                // Return to original document and show goal modal
                editor.innerHTML = this.originalContent;
                this.isTutorial = false;
                this.calculateOriginalStats();
                this.showGoalModal();
            });
        }
        
        // Show modal
        modal.style.display = 'flex';
    },
    
    hideTutorialCompleteModal: function() {
        const modal = document.getElementById('greening-tutorial-complete-modal');
        if (modal) {
            modal.style.display = 'none';
        }
    },

    showGoalModal: function() {
        // Create modal if it doesn't exist
        let modal = document.getElementById('greening-goal-modal');
        
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'greening-goal-modal';
            modal.className = 'modal';
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-labelledby', 'greening-goal-title');
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px;">
                    <div class="modal-header">
                        <div id="greening-goal-title" class="modal-title">Set Greening Goal</div>
                        <button class="modal-close" aria-label="Close">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div style="background-color: #f9f4ff; padding: 15px; border-radius: 6px; margin-bottom: 20px; border-left: 4px solid var(--primary-color, #57068c);">
                            <h4 style="margin-top: 0; color: var(--primary-color, #57068c);">About Greening</h4>
                            <p style="margin-bottom: 0; font-size: 0.9rem; line-height: 1.4;">
                                Based on John McPhee's editing practice: reduce your text to fit constraints while preserving voice, message, and tone. 
                                Select words and phrases to cut by double-clicking or dragging. Marked text appears in green.
                            </p>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <strong>Current Document Stats:</strong><br>
                            <span id="greening-current-stats"></span>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label"><strong>Choose your greening goal:</strong></label>
                            
                            <div style="margin: 15px 0;">
                                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                                    <input type="radio" name="goalType" value="percentage" style="margin-right: 8px;">
                                    <span>Reduce by percentage</span>
                                </label>
                                <div id="percentage-input" style="margin-left: 25px; display: none;">
                                    <label>Reduce by: 
                                        <input type="number" id="percentage-value" min="1" max="50" value="10" style="width: 60px; margin-left: 5px;">%
                                    </label>
                                    <div style="font-size: 0.85rem; color: #666; margin-top: 5px;">
                                        Target: <span id="percentage-target"></span> words
                                    </div>
                                </div>
                            </div>
                            
                            <div style="margin: 15px 0;">
                                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                                    <input type="radio" name="goalType" value="wordCount" style="margin-right: 8px;">
                                    <span>Cut specific word count</span>
                                </label>
                                <div id="wordcount-input" style="margin-left: 25px; display: none;">
                                    <label>Cut: 
                                        <input type="number" id="wordcount-value" min="1" max="1000" value="50" style="width: 80px; margin-left: 5px;"> words
                                    </label>
                                </div>
                            </div>
                            
                            <div style="margin: 15px 0;">
                                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                                    <input type="radio" name="goalType" value="lineCount" style="margin-right: 8px;">
                                    <span>Reduce line count (McPhee style)</span>
                                </label>
                                <div id="linecount-input" style="margin-left: 25px; display: none;">
                                    <label>Green: 
                                        <input type="number" id="linecount-value" min="1" max="20" value="5" style="width: 60px; margin-left: 5px;"> lines
                                    </label>
                                    <div style="font-size: 0.85rem; color: #666; margin-top: 5px;">
                                        Current: <span id="current-lines"></span> lines
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button id="greening-goal-cancel" class="action-btn">Cancel</button>
                        <button id="greening-goal-set" class="action-btn primary">Start Greening</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            this.setupGoalModalEvents(modal);
        }
        
        // Update current stats
        this.updateGoalModalStats();
        
        // Show modal
        modal.style.display = 'flex';
        
        // Focus first radio button
        const firstRadio = modal.querySelector('input[type="radio"]');
        if (firstRadio) {
            setTimeout(() => firstRadio.focus(), 100);
        }
    },
    
    setupGoalModalEvents: function(modal) {
        // Radio button handling
        const radios = modal.querySelectorAll('input[name="goalType"]');
        radios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                // Hide all input sections
                modal.querySelectorAll('[id$="-input"]').forEach(section => {
                    section.style.display = 'none';
                });
                
                // Show selected input section
                const targetSection = modal.querySelector(`#${e.target.value}-input`);
                if (targetSection) {
                    targetSection.style.display = 'block';
                }
                
                // Update percentage target calculation
                if (e.target.value === 'percentage') {
                    this.updatePercentageTarget();
                }
            });
        });
        
        // Percentage input handling
        const percentageInput = modal.querySelector('#percentage-value');
        if (percentageInput) {
            percentageInput.addEventListener('input', () => this.updatePercentageTarget());
        }
        
        // Modal buttons
        modal.querySelector('.modal-close').addEventListener('click', () => this.hideGoalModal());
        modal.querySelector('#greening-goal-cancel').addEventListener('click', () => this.hideGoalModal());
        modal.querySelector('#greening-goal-set').addEventListener('click', () => this.setGoalFromModal());
    },
    
    updateGoalModalStats: function() {
        const modal = document.getElementById('greening-goal-modal');
        if (!modal) return;
        
        const statsEl = modal.querySelector('#greening-current-stats');
        const linesEl = modal.querySelector('#current-lines');
        
        if (statsEl) {
            statsEl.textContent = `${this.originalStats.wordCount} words, ${this.originalStats.lineCount} lines, ${this.originalStats.charCount} characters`;
        }
        
        if (linesEl) {
            linesEl.textContent = this.originalStats.lineCount;
        }
        
        this.updatePercentageTarget();
    },
    
    updatePercentageTarget: function() {
        const modal = document.getElementById('greening-goal-modal');
        if (!modal) return;
        
        const percentageInput = modal.querySelector('#percentage-value');
        const targetEl = modal.querySelector('#percentage-target');
        
        if (percentageInput && targetEl) {
            const percentage = parseInt(percentageInput.value) || 0;
            const wordsToRemove = Math.round(this.originalStats.wordCount * percentage / 100);
            targetEl.textContent = `${this.originalStats.wordCount - wordsToRemove}`;
        }
    },
    
    setGoalFromModal: function() {
        const modal = document.getElementById('greening-goal-modal');
        const selectedRadio = modal.querySelector('input[name="goalType"]:checked');
        
        if (!selectedRadio) {
            showNotification('Please select a goal type', 'warning');
            return;
        }
        
        this.goalType = selectedRadio.value;
        
        switch (this.goalType) {
            case 'percentage':
                const percentage = parseInt(modal.querySelector('#percentage-value').value) || 10;
                this.goalValue = Math.round(this.originalStats.wordCount * percentage / 100);
                break;
            case 'wordCount':
                this.goalValue = parseInt(modal.querySelector('#wordcount-value').value) || 50;
                break;
            case 'lineCount':
                this.goalValue = parseInt(modal.querySelector('#linecount-value').value) || 5;
                break;
        }
        
        // Validate goal
        if (this.goalValue <= 0) {
            showNotification('Goal value must be greater than 0', 'warning');
            return;
        }
        
        if (this.goalType === 'wordCount' && this.goalValue >= this.originalStats.wordCount) {
            showNotification('Cannot cut more words than the document contains', 'warning');
            return;
        }
        
        // Hide modal and start greening
        this.hideGoalModal();
        this.startGreening();
    },
    
    hideGoalModal: function() {
        const modal = document.getElementById('greening-goal-modal');
        if (modal) {
            modal.style.display = 'none';
        }
    },
    
    startGreening: function() {
        this.isActive = true;
        
        // Make editor non-editable during greening
        editor.contentEditable = 'false';
        
        // Add greening class to editor
        editor.classList.add('greening-mode');
        
        // Set up event listeners for text selection
        this.setupEventListeners();
        
        // Update toolbar options
        this.setupOptions();
        
        showNotification(`Greening goal set: ${this.getGoalDescription()}. Double-click or drag to select text for removal.`, 'success');
    },
    
    setupEventListeners: function() {
        // Double-click selection
        editor.addEventListener('dblclick', this.handleDoubleClick.bind(this));
        
        // Drag selection
        editor.addEventListener('mouseup', this.handleMouseUp.bind(this));
        
        // Prevent text editing
        editor.addEventListener('keydown', this.preventEditing.bind(this));
    },
    
    removeEventListeners: function() {
        editor.removeEventListener('dblclick', this.handleDoubleClick.bind(this));
        editor.removeEventListener('mouseup', this.handleMouseUp.bind(this));
        editor.removeEventListener('keydown', this.preventEditing.bind(this));
    },
    
    preventEditing: function(e) {
        // Allow navigation keys but prevent text input
        const allowedKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Home', 'End', 'PageUp', 'PageDown'];
        if (!allowedKeys.includes(e.key) && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
        }
    },
    
    handleDoubleClick: function(e) {
        e.preventDefault();
        
        // Get the word at click position
        const range = this.getWordAtPosition(e);
        if (range) {
            this.toggleSelection(range);
        }
    },
    
    handleMouseUp: function(e) {
        const selection = window.getSelection();
        const selectedText = selection.toString().trim();
        
        if (selectedText && selectedText.length > 0) {
            const range = selection.getRangeAt(0);
            this.toggleSelection(range);
        }
    },
    
    getWordAtPosition: function(e) {
        // Create a range at the click position
        const range = document.createRange();
        const textNode = e.target.childNodes[0] || e.target;
        
        if (textNode.nodeType !== Node.TEXT_NODE) {
            return null;
        }
        
        // Find word boundaries
        const text = textNode.textContent;
        const clickOffset = this.getClickOffset(e, textNode);
        
        let start = clickOffset;
        let end = clickOffset;
        
        // Find start of word
        while (start > 0 && /\w/.test(text[start - 1])) {
            start--;
        }
        
        // Find end of word
        while (end < text.length && /\w/.test(text[end])) {
            end++;
        }
        
        if (start < end) {
            range.setStart(textNode, start);
            range.setEnd(textNode, end);
            return range;
        }
        
        return null;
    },
    
    getClickOffset: function(e, textNode) {
        // Simplified offset calculation
        // In a real implementation, you might want more sophisticated text position detection
        return Math.floor(textNode.textContent.length / 2);
    },
    
    toggleSelection: function(range) {
        const selectedText = range.toString().trim();
        if (!selectedText) return;
        
        // Check if this text is already selected
        const existingSelection = this.findExistingSelection(selectedText, range);
        
        if (existingSelection) {
            // Remove existing selection
            this.removeSelection(existingSelection);
        } else {
            // Add new selection
            this.addSelection(range);
        }
        
        // Update progress display
        this.updateProgressDisplay();
    },
    
    findExistingSelection: function(text, range) {
        // Check if this range overlaps with any existing selection
        return this.selectedForDeletion.find(selection => {
            if (selection.text === text) {
                return true;
            }
            
            // Check if ranges overlap
            try {
                const comparison = range.compareBoundaryPoints(Range.START_TO_START, selection.range);
                return comparison === 0;
            } catch (e) {
                return false;
            }
        });
    },
    
    addSelection: function(range) {
        const selectedText = range.toString().trim();
        const wordCount = this.countWords(selectedText);
        
        // Create unique ID for this selection
        const selectionId = `greening-selection-${++this.selectionCounter}`;
        
        // Create a span to mark the selection
        const span = document.createElement('span');
        span.className = 'greening-selected';
        span.id = selectionId;
        span.setAttribute('title', `Selected for deletion: "${selectedText}"`);
        span.style.backgroundColor = 'rgba(76, 175, 80, 0.3)';
        span.style.borderBottom = '2px solid #4caf50';
        span.style.cursor = 'pointer';
        
        // Surround the range with the span
        try {
            range.surroundContents(span);
            
            // Store selection data
            const selectionData = {
                id: selectionId,
                element: span,
                text: selectedText,
                wordCount: wordCount,
                range: range.cloneRange()
            };
            
            this.selectedForDeletion.push(selectionData);
            
            // Add click handler to remove selection
            span.addEventListener('click', () => {
                this.removeSelection(selectionData);
                this.updateProgressDisplay();
            });
            
        } catch (error) {
            console.error('Error adding selection:', error);
            showNotification('Could not select that text. Try selecting a different portion.', 'warning');
        }
    },
    
    removeSelection: function(selectionData) {
        // Remove from array
        const index = this.selectedForDeletion.indexOf(selectionData);
        if (index > -1) {
            this.selectedForDeletion.splice(index, 1);
        }
        
        // Remove from DOM
        if (selectionData.element && selectionData.element.parentNode) {
            const parent = selectionData.element.parentNode;
            while (selectionData.element.firstChild) {
                parent.insertBefore(selectionData.element.firstChild, selectionData.element);
            }
            parent.removeChild(selectionData.element);
            parent.normalize();
        }
    },
    
    clearAllSelections: function() {
        // Remove all selections
        const selections = [...this.selectedForDeletion]; // Copy array
        selections.forEach(selection => {
            this.removeSelection(selection);
        });
        
        this.selectedForDeletion = [];
        this.updateProgressDisplay();
        
        showNotification('All greening selections cleared', 'info');
    },
    
    applyGreening: function() {
        if (this.selectedForDeletion.length === 0) {
            showNotification('No text selected for deletion', 'warning');
            return;
        }
        
        const totalWords = this.selectedForDeletion.reduce((sum, sel) => sum + sel.wordCount, 0);
        
        if (confirm(`Apply greening? This will permanently delete ${this.selectedForDeletion.length} selections (${totalWords} words).`)) {
            // Remove all selected elements
            this.selectedForDeletion.forEach(selection => {
                if (selection.element && selection.element.parentNode) {
                    selection.element.parentNode.removeChild(selection.element);
                }
            });
            
            // Normalize the editor
            editor.normalize();
            
            // Mark as completed
            this.isCompleted = true;
            
            // Re-enable editing
            editor.contentEditable = 'true';
            editor.classList.remove('greening-mode');
            
            // Calculate final stats
            const finalWordCount = this.countWords(editor.innerText);
            const wordsReduced = this.originalStats.wordCount - finalWordCount;
            
            showNotification(`Greening applied! Reduced by ${wordsReduced} words (${Math.round((wordsReduced / this.originalStats.wordCount) * 100)}%)`, 'success');
            
            // Save document
            DocumentManager.saveDocument();
            
            // Update progress display one final time
            this.updateProgressDisplay();
        }
    },
    
    calculateOriginalStats: function() {
        const text = editor.innerText || '';
        this.originalStats = {
            wordCount: this.countWords(text),
            charCount: text.length,
            lineCount: this.countLines(text)
        };
    },
    
    countWords: function(text) {
        if (!text || !text.trim()) return 0;
        return text.trim().split(/\s+/).filter(word => word.length > 0).length;
    },
    
    countLines: function(text) {
        if (!text) return 0;
        // Approximate line counting based on character width
        // This is a simplified version - you might want to make it more sophisticated
        const avgCharsPerLine = 80; // Approximate characters per line
        const paragraphs = text.split(/\n\s*\n/);
        let totalLines = 0;
        
        paragraphs.forEach(paragraph => {
            const paragraphLength = paragraph.replace(/\s+/g, ' ').trim().length;
            totalLines += Math.max(1, Math.ceil(paragraphLength / avgCharsPerLine));
        });
        
        return totalLines;
    },
    
    calculateProgress: function() {
        const selectedWords = this.selectedForDeletion.reduce((sum, sel) => sum + sel.wordCount, 0);
        
        switch (this.goalType) {
            case 'percentage':
            case 'wordCount':
                return {
                    current: selectedWords,
                    target: this.goalValue,
                    percentage: Math.min(100, Math.round((selectedWords / this.goalValue) * 100))
                };
            case 'lineCount':
                // Approximate lines from word count
                const avgWordsPerLine = 12; // Approximate
                const selectedLines = Math.round(selectedWords / avgWordsPerLine);
                return {
                    current: selectedLines,
                    target: this.goalValue,
                    percentage: Math.min(100, Math.round((selectedLines / this.goalValue) * 100))
                };
            default:
                return { current: 0, target: 0, percentage: 0 };
        }
    },
    
    isGoalMet: function() {
        const progress = this.calculateProgress();
        return progress.percentage >= 100;
    },
    
    getGoalDescription: function() {
        if (!this.goalType) return 'No goal set';
        
        switch (this.goalType) {
            case 'percentage':
                const targetWords = this.originalStats.wordCount - this.goalValue;
                return `Reduce to ${targetWords} words (${Math.round((this.goalValue / this.originalStats.wordCount) * 100)}% reduction)`;
            case 'wordCount':
                return `Cut ${this.goalValue} words`;
            case 'lineCount':
                return `Green ${this.goalValue} lines`;
            default:
                return 'Unknown goal';
        }
    },
    
    updateProgressDisplay: function(element) {
        const progressEl = element || document.getElementById('greening-progress');
        if (!progressEl) return;
        
        const progress = this.calculateProgress();
        const isComplete = this.isGoalMet();
        
        let displayText = '';
        switch (this.goalType) {
            case 'percentage':
            case 'wordCount':
                displayText = `${progress.current}/${progress.target} words selected`;
                break;
            case 'lineCount':
                displayText = `${progress.current}/${progress.target} lines selected`;
                break;
        }
        
        progressEl.textContent = `${displayText} (${progress.percentage}%)`;
        
        // Update styling based on progress
        if (isComplete) {
            progressEl.style.backgroundColor = '#d4edda';
            progressEl.style.borderColor = '#28a745';
            progressEl.style.color = '#155724';
        } else if (progress.percentage > 50) {
            progressEl.style.backgroundColor = '#fff3cd';
            progressEl.style.borderColor = '#ffc107';
            progressEl.style.color = '#856404';
        } else {
            progressEl.style.backgroundColor = '#e8f5e8';
            progressEl.style.borderColor = '#4caf50';
            progressEl.style.color = '#2e7d32';
        }
        
        // Show completion notification
        if (isComplete && !this.goalNotificationShown) {
            showNotification('🎯 Greening goal achieved! You can now apply the cuts or continue selecting.', 'success');
            this.goalNotificationShown = true;
        }
    },
    
    clearGreeningElements: function() {
        // Remove all greening selection spans
        const selections = editor.querySelectorAll('.greening-selected');
        selections.forEach(span => {
            const parent = span.parentNode;
            if (parent) {
                while (span.firstChild) {
                    parent.insertBefore(span.firstChild, span);
                }
                parent.removeChild(span);
            }
        });
        
        // Normalize the editor
        editor.normalize();
        
        // Remove greening mode class
        editor.classList.remove('greening-mode');
        
        // Remove modal if it exists
        const modal = document.getElementById('greening-goal-modal');
        if (modal) {
            modal.remove();
        }
    }
},

// Add this to your modes object in the main script

infrared: {
    name: 'Infrared Mode',
    activePattern: null, // 'jargon' or 'nuance'
    highlightedElements: [], // Track highlighted spans for cleanup
    
    // Pattern definitions
    patterns: {
        jargon: {
            name: 'Jargon Words (Latinate)',
            color: '#8B0000', // Dark red (infrared-like)
            description: 'Highlights complex Latinate words that may have simpler alternatives',
            words: [
                // Common Latinate words with simpler alternatives
                'accommodate', 'acquisition', 'advantageous', 'anticipate', 'approximately',
                'ascertain', 'assistance', 'commence', 'communicate', 'component',
                'comprehend', 'concerning', 'consequently', 'consideration', 'constitute',
                'demonstrate', 'designation', 'determination', 'documentation', 'facilitate',
                'fundamental', 'implement', 'indication', 'individuals', 'information',
                'initiate', 'institution', 'intention', 'investigate', 'knowledge',
                'legislation', 'maintenance', 'methodology', 'modification', 'necessity',
                'notification', 'objective', 'observation', 'operation', 'opportunity',
                'participate', 'particular', 'percentage', 'performance', 'permission',
                'personnel', 'population', 'position', 'possession', 'possibility',
                'preparation', 'presentation', 'previously', 'priority', 'procedure',
                'profession', 'provision', 'publication', 'purchase', 'receive',
                'recommendation', 'registration', 'regulation', 'relationship', 'represent',
                'requirement', 'reservation', 'resolution', 'responsibility', 'situation',
                'specification', 'sufficient', 'terminate', 'transportation', 'utilization',
                'vocation', 'occupation', 'employment', 'residence', 'substantial',
                'eliminate', 'establish', 'examine', 'exercise', 'explanation',
                'expression', 'extension', 'extraordinary', 'identification', 'illustration',
                'imagination', 'immediately', 'importance', 'improvement', 'including',
                'incredible', 'independent', 'inevitable', 'influence', 'initial',
                'installation', 'intelligence', 'interesting', 'introduction', 'magnificent',
                'majority', 'maximum', 'minimum', 'negative', 'obviously',
                'organization', 'original', 'particularly', 'positive', 'practical',
                'principle', 'probably', 'recognize', 'relatively', 'significance',
                'similar', 'specific', 'superior', 'temporary', 'traditional'
            ],
            // Suggestions for alternatives (optional for future enhancement)
            alternatives: {
                'accommodate': 'fit, help',
                'acquisition': 'buying, getting',
                'advantageous': 'helpful, good',
                'anticipate': 'expect, await',
                'approximately': 'about, around',
                'assistance': 'help, aid',
                'commence': 'start, begin',
                'communicate': 'talk, tell',
                'demonstrate': 'show, prove',
                'facilitate': 'help, ease',
                'fundamental': 'basic, key',
                'implement': 'carry out, do',
                'individuals': 'people',
                'initiate': 'start, begin',
                'intention': 'plan, goal',
                'investigate': 'look into, study',
                'methodology': 'method, way',
                'necessity': 'need',
                'objective': 'goal, aim',
                'operation': 'work, process',
                'participate': 'take part, join',
                'particular': 'specific, certain',
                'personnel': 'staff, workers',
                'population': 'people',
                'possess': 'have, own',
                'previously': 'before, earlier',
                'procedure': 'process, steps',
                'profession': 'job, career',
                'purchase': 'buy',
                'receive': 'get',
                'requirement': 'need',
                'residence': 'home',
                'sufficient': 'enough',
                'terminate': 'end, stop',
                'transportation': 'transport',
                'utilization': 'use',
                'vocation': 'job, career'
            }
        },
        
        nuance: {
            name: 'Nuance Words',
            color: '#B22222', // Fire brick red (infrared variant)
            description: 'Highlights words that signal complexity, qualification, or nuanced thinking',
            words: [
                // Core contrast and qualification words
                'but', 'despite', 'although', 'yet', 'though', 'however', 'nevertheless', 
                'nonetheless', 'notwithstanding', 'regardless', 'while', 'whereas', 
                'conversely', 'alternatively', 'instead', 'rather', 'albeit', 'except', 
                'still', 'granted', 'admittedly', 'even', 'if',
                
                // Contrast phrases and expressions
                'in spite of', 'on the one hand', 'on the other hand', 'in contrast', 
                'even though', 'provided that', 'unless', 'contrary to', 'paradoxically', 
                'ironically', 'unexpectedly', 'surprisingly', 'at the same time', 
                'all the same', 'be that as it may', 'in any case', 'in any event', 
                'even so', 'even if', 'then again', 'for all that', 'as much as', 
                'by contrast', 'on the contrary',
                
                // Initial appearance and theory
                'at first glance', 'initially', 'on the surface', 'at the outset', 'ostensibly', 'apparently', 
                'in theory', 'hypothetically', 'ideally', 'nominally', 'officially', 
                'outwardly', 'seemingly', 'supposedly', 'allegedly', 'purportedly', 
                'reportedly', 'reputedly', 'at first blush','apparently', 'prima facie', 'superficially',
                'notwithstanding appearances', 'despite appearances',
                
                // Against expectations
                'by comparison', 'against expectations', 'counter-intuitively', 'counterintuitively',
                'in defiance of', 'in the face of', 'against all odds', 'despite the odds', 
                'in spite of the odds', 'all the odds',
                
                // Equal conditions and normal circumstances
                'all things being equal', 'all other things being equal', 
                'assuming all else is equal', 'ceteris paribus', 'other things being equal', 
                'under normal circumstances', 'ordinarily', 'usually', 'typically', 
                'generally', 'in general', 'as a rule', 'for the most part', 
                'more often than not', 'oft-times', 'oftentimes',
                
                // Figurative and approximate language
                'so to speak', 'as it were', 'in a manner of speaking', 'so to say', 
                'strictly speaking', 'technically speaking', 'in a sense', 'in one sense', 
                'in some sense', 'in a way', 'in some respects', 'in some ways',
                
                // Degree and extent qualifiers
                'almost', 'somewhat', 'kind of', 'sort of', 'sorta', 'mildly', 'nearly', 'verging on',
                'to some degree', 'to some extent', 'to an extent', 'to a degree', 'to a certain degree','to a certain extent', 'to a limited extent', 
                'to a limited degree', 'up to a point', 'up to a certain point', 'within limits', 'relatively', 
                'comparatively', 'moderately', 'rather', 'fairly', 'reasonably', 
                'pretty', 'slightly', 'a bit', 'a little', 'a little bit', 'faintly', 
                'just', 'only just', 'barely', 'scarcely', 'hardly', 'to a certain extent',
                
                // Minimal degree markers
                'no more than', 'not much', 'almost not', 'nearly not', 
                'close to', 'bordering on', 'verging on not', 'nearing',
                
                // Uncertainty and hedging
                'arguably', 'perhaps', 'possibly', 'probably', 'likely', 'unlikely', 
                'conceivably', 'presumably', 'may', 'might', 'could', 'would', 'should', 
                'potentially', 'supposedly', 'theoretically', 'speculatively', 
                'tentatively', 'provisionally', 'conditionally', 'debatably', 
                'questionably', 'doubtfully', 'dubiously',
                
                // Verbal hedges
                'appears', 'seems','tends', 'inclines', 'resembles', 'hints', 'alludes', 
            ]
        }
    },
    
    activate: function(options) {
        // Set default pattern if none specified
        this.activePattern = options?.pattern || 'jargon';
        
        // Clear any existing highlights
        this.removeHighlighting();
        
        // Set up mode-specific options in the toolbar
        this.setupOptions();
        
        // Apply initial highlighting
        this.applyHighlighting();
        
        showNotification(`Infrared Mode enabled - Highlighting ${this.patterns[this.activePattern].name}`, 'info');
    },
    
    deactivate: function() {
        // Remove all highlighting
        this.removeHighlighting();
        
        // Reset state
        this.activePattern = null;
        this.highlightedElements = [];
        
        // Clear mode options
        clearModeOptions();
        
        // Ensure editor is editable
        editor.contentEditable = 'true';
        
        showNotification('Infrared Mode disabled', 'info');
    },
    
    getOptions: function() {
        return {
            activePattern: this.activePattern,
            highlightCount: this.highlightedElements.length,
            availablePatterns: Object.keys(this.patterns)
        };
    },
    
    setupOptions: function() {
        // Clear existing options
        clearModeOptions();
        
        // Create pattern selector
        const selectorContainer = document.createElement('div');
        selectorContainer.className = 'toolbar-group';
        
        const selectorLabel = document.createElement('span');
        selectorLabel.className = 'mode-option-label';
        selectorLabel.textContent = 'Pattern: ';
        selectorLabel.style.marginRight = '8px';
        
        const patternSelector = document.createElement('select');
        patternSelector.className = 'toolbar-selector';
        patternSelector.id = 'infrared-pattern-selector';
        patternSelector.setAttribute('aria-label', 'Select infrared pattern');
        
        // Add options for each pattern
        Object.entries(this.patterns).forEach(([key, pattern]) => {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = pattern.name;
            if (key === this.activePattern) {
                option.selected = true;
            }
            patternSelector.appendChild(option);
        });
        
        // Pattern change handler
        patternSelector.addEventListener('change', (e) => {
            this.activePattern = e.target.value;
            this.applyHighlighting();
            this.updateStatsDisplay();
            
            // Show notification about the change
            const patternInfo = this.patterns[this.activePattern];
            showNotification(`Switched to ${patternInfo.name}`, 'info');
        });
        
        selectorContainer.appendChild(selectorLabel);
        selectorContainer.appendChild(patternSelector);
        
        // Create control buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'toolbar-group';
        
        // Clear highlighting button
        const clearBtn = document.createElement('button');
        clearBtn.className = 'toolbar-btn';
        clearBtn.innerHTML = '<i class="fas fa-eraser"></i> Clear';
        clearBtn.setAttribute('aria-label', 'Clear infrared highlighting');
        clearBtn.addEventListener('click', () => this.removeHighlighting());
        
        // Refresh highlighting button
        const refreshBtn = document.createElement('button');
        refreshBtn.className = 'toolbar-btn';
        refreshBtn.innerHTML = '<i class="fas fa-sync"></i> Refresh';
        refreshBtn.setAttribute('aria-label', 'Refresh infrared highlighting');
        refreshBtn.addEventListener('click', () => this.applyHighlighting());
        
        // Export analysis button
        const exportBtn = document.createElement('button');
        exportBtn.className = 'toolbar-btn';
        exportBtn.innerHTML = '<i class="fas fa-file-export"></i> Export';
        exportBtn.setAttribute('aria-label', 'Export infrared analysis');
        exportBtn.addEventListener('click', () => this.exportAnalysis());
        
        buttonContainer.appendChild(clearBtn);
        buttonContainer.appendChild(refreshBtn);
        buttonContainer.appendChild(exportBtn);
        
        // Create stats display
        const statsContainer = document.createElement('div');
        statsContainer.className = 'infrared-stats-container';
        statsContainer.style.marginLeft = '15px';
        
        const statsDisplay = document.createElement('span');
        statsDisplay.id = 'infrared-stats';
        statsDisplay.className = 'mode-option-label';
        
        // Add pattern description
        const descriptionDiv = document.createElement('div');
        descriptionDiv.className = 'infrared-description';
        descriptionDiv.style.fontSize = '0.85rem';
        descriptionDiv.style.color = '#666';
        descriptionDiv.style.marginTop = '5px';
        descriptionDiv.style.maxWidth = '400px';
        descriptionDiv.style.lineHeight = '1.3';
        
        statsContainer.appendChild(statsDisplay);
        statsContainer.appendChild(descriptionDiv);
        
        // Add all elements to options
        activeModeOptions.appendChild(selectorContainer);
        activeModeOptions.appendChild(buttonContainer);
        activeModeOptions.appendChild(statsContainer);
        
        // Update initial stats display
        this.updateStatsDisplay();
    },
    
    updateStatsDisplay: function() {
        const statsEl = document.getElementById('infrared-stats');
        const descEl = document.querySelector('.infrared-description');
        
        if (statsEl && this.activePattern) {
            const count = this.highlightedElements.length;
            const patternInfo = this.patterns[this.activePattern];
            
            statsEl.textContent = `${count} ${patternInfo.name.toLowerCase()} found`;
            statsEl.style.color = count > 0 ? patternInfo.color : '#666';
            
            if (descEl) {
                descEl.textContent = patternInfo.description;
            }
        }
    },
    
    applyHighlighting: function() {
        if (!this.activePattern) return;
        
        // Remove existing highlighting first
        this.removeHighlighting();
        
        const pattern = this.patterns[this.activePattern];
        if (!pattern) return;
        
        // Make editor temporarily non-editable
        const wasEditable = editor.contentEditable;
        editor.contentEditable = 'false';
        
        // Create a set for faster lookup
        const wordsToHighlight = new Set(pattern.words.map(word => word.toLowerCase()));
        
        // Walk through the DOM and highlight matching words
        this.walkDOMAndHighlight(editor, wordsToHighlight, pattern);
        
        // Restore editability
        editor.contentEditable = wasEditable;
        
        // Update stats
        this.updateStatsDisplay();
        
        // Show completion notification
        if (this.highlightedElements.length > 0) {
            showNotification(`Found ${this.highlightedElements.length} ${pattern.name.toLowerCase()}`, 'success');
        } else {
            showNotification(`No ${pattern.name.toLowerCase()} found in document`, 'info');
        }
    },
    
    walkDOMAndHighlight: function(node, wordsToHighlight, pattern) {
        // Skip already highlighted elements
        if (node.classList && node.classList.contains('infrared-highlight')) {
            return;
        }
        
        // Process text nodes
        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
            this.processTextNode(node, wordsToHighlight, pattern);
        } else if (node.nodeType === Node.ELEMENT_NODE) {
            // Skip script and style elements
            if (node.tagName && (node.tagName.toLowerCase() === 'script' || node.tagName.toLowerCase() === 'style')) {
                return;
            }
            
            // Process child nodes (make a copy as the list might change)
            Array.from(node.childNodes).forEach(child => {
                this.walkDOMAndHighlight(child, wordsToHighlight, pattern);
            });
        }
    },
    
    processTextNode: function(textNode, wordsToHighlight, pattern) {
        const text = textNode.textContent;
        const words = [];
        let currentWord = '';
        let currentNonWord = '';
        
        // Split text into word and non-word segments
        for (let i = 0; i < text.length; i++) {
            const char = text[i];
            if (/\w/.test(char)) {
                if (currentNonWord) {
                    words.push({ type: 'nonword', text: currentNonWord });
                    currentNonWord = '';
                }
                currentWord += char;
            } else {
                if (currentWord) {
                    words.push({ type: 'word', text: currentWord });
                    currentWord = '';
                }
                currentNonWord += char;
            }
        }
        
        // Add any remaining segments
        if (currentWord) words.push({ type: 'word', text: currentWord });
        if (currentNonWord) words.push({ type: 'nonword', text: currentNonWord });
        
        // Check if any words need highlighting
        const hasMatches = words.some(segment => 
            segment.type === 'word' && this.shouldHighlightWord(segment.text, wordsToHighlight)
        );
        
        if (hasMatches) {
            // Create document fragment with highlighted words
            const fragment = document.createDocumentFragment();
            
            words.forEach(segment => {
                if (segment.type === 'nonword') {
                    fragment.appendChild(document.createTextNode(segment.text));
                } else {
                    // Check if this word should be highlighted
                    if (this.shouldHighlightWord(segment.text, wordsToHighlight)) {
                        const span = this.createHighlightSpan(segment.text, pattern);
                        fragment.appendChild(span);
                        this.highlightedElements.push(span);
                    } else {
                        fragment.appendChild(document.createTextNode(segment.text));
                    }
                }
            });
            
            // Replace the original text node
            textNode.parentNode.replaceChild(fragment, textNode);
        }
    },
    
    shouldHighlightWord: function(word, wordsToHighlight) {
        const cleanWord = word.toLowerCase().replace(/[^\w]/g, '');
        
        // Only check exact matches - no substring matching
        return wordsToHighlight.has(cleanWord);
    },
    
    createHighlightSpan: function(text, pattern) {
        const span = document.createElement('span');
        span.className = 'infrared-highlight';
        span.textContent = text;
        span.style.backgroundColor = pattern.color;
        span.style.color = 'white';
        span.style.padding = '1px 3px';
        span.style.borderRadius = '2px';
        span.style.fontWeight = '500';
        span.style.transition = 'all 0.2s ease';
        span.setAttribute('title', `${pattern.name}: ${text}`);
        
        // Add hover effect
        span.addEventListener('mouseenter', () => {
            span.style.backgroundColor = this.lightenColor(pattern.color, 20);
            span.style.transform = 'scale(1.05)';
        });
        
        span.addEventListener('mouseleave', () => {
            span.style.backgroundColor = pattern.color;
            span.style.transform = 'scale(1)';
        });
        
        return span;
    },
    
    removeHighlighting: function() {
        // Make editor temporarily non-editable
        const wasEditable = editor.contentEditable;
        editor.contentEditable = 'false';
        
        // Remove all infrared highlight spans
        this.highlightedElements.forEach(span => {
            if (span.parentNode) {
                const textNode = document.createTextNode(span.textContent);
                span.parentNode.replaceChild(textNode, span);
            }
        });
        
        // Clear the tracking array
        this.highlightedElements = [];
        
        // Normalize the editor to combine adjacent text nodes
        editor.normalize();
        
        // Restore editability
        editor.contentEditable = wasEditable;
        
        // Update stats
        this.updateStatsDisplay();
    },
    
    exportAnalysis: function() {
        if (!this.activePattern) return;
        
        const pattern = this.patterns[this.activePattern];
        const highlightCount = this.highlightedElements.length;
        
        if (highlightCount === 0) {
            showNotification('No patterns found to export', 'warning');
            return;
        }
        
        // Create title for new document
        const title = (DocumentManager.currentDocument?.title || 'Untitled') + ` - ${pattern.name} Analysis`;
        
        // Collect all highlighted words and their contexts
        const findings = [];
        this.highlightedElements.forEach(span => {
            const word = span.textContent;
            const sentence = this.getSentenceContext(span);
            findings.push({ word, sentence });
        });
        
        // Group by word frequency
        const wordCounts = {};
        findings.forEach(finding => {
            const word = finding.word.toLowerCase();
            if (!wordCounts[word]) {
                wordCounts[word] = { count: 0, examples: [] };
            }
            wordCounts[word].count++;
            if (wordCounts[word].examples.length < 3) { // Limit examples
                wordCounts[word].examples.push(finding.sentence);
            }
        });
        
        // Create content for the new document
        let content = `<h1>${pattern.name} Analysis</h1>`;
        content += `<h2>${DocumentManager.currentDocument?.title || 'Untitled Document'}</h2>`;
        content += `<p><em>Analysis conducted on ${new Date().toLocaleDateString()}</em></p>`;
        
        content += `<h3>Summary</h3>`;
        content += `<ul>`;
        content += `<li><strong>Total instances found:</strong> ${highlightCount}</li>`;
        content += `<li><strong>Unique words:</strong> ${Object.keys(wordCounts).length}</li>`;
        content += `<li><strong>Pattern type:</strong> ${pattern.name}</li>`;
        content += `</ul>`;
        
        content += `<h3>Word Frequency</h3>`;
        content += `<table style="width:100%; border-collapse: collapse; margin: 20px 0;">`;
        content += `<tr style="background-color: #f2f2f2; border: 1px solid #ddd;">`;
        content += `<th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Word</th>`;
        content += `<th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Count</th>`;
        content += `<th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Example Context</th>`;
        content += `</tr>`;
        
        // Sort by frequency
        const sortedWords = Object.entries(wordCounts).sort((a, b) => b[1].count - a[1].count);
        
        sortedWords.forEach(([word, data]) => {
            content += `<tr>`;
            content += `<td style="padding: 8px; border: 1px solid #ddd; font-weight: bold;">${word}</td>`;
            content += `<td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${data.count}</td>`;
            content += `<td style="padding: 8px; border: 1px solid #ddd; font-style: italic;">${data.examples[0] || ''}</td>`;
            content += `</tr>`;
        });
        
        content += `</table>`;
        
        // Add suggestions for jargon words
        if (this.activePattern === 'jargon' && pattern.alternatives) {
            content += `<h3>Suggested Alternatives</h3>`;
            content += `<table style="width:100%; border-collapse: collapse; margin: 20px 0;">`;
            content += `<tr style="background-color: #f2f2f2; border: 1px solid #ddd;">`;
            content += `<th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Complex Word</th>`;
            content += `<th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Simpler Alternatives</th>`;
            content += `</tr>`;
            
            sortedWords.forEach(([word, data]) => {
                const alternatives = pattern.alternatives[word];
                if (alternatives) {
                    content += `<tr>`;
                    content += `<td style="padding: 8px; border: 1px solid #ddd; font-weight: bold;">${word}</td>`;
                    content += `<td style="padding: 8px; border: 1px solid #ddd;">${alternatives}</td>`;
                    content += `</tr>`;
                }
            });
            
            content += `</table>`;
        }
        
        // Create new document
        const docId = DocumentManager.createNewDocument(title, '');
        const newDoc = DocumentManager.documents.find(doc => doc.id === docId);
        
        if (newDoc) {
            newDoc.content = content;
            DocumentManager.saveDocument();
            showNotification('Infrared analysis exported to a new document');
        }
    },
    
    getSentenceContext: function(element) {
        // Get the sentence containing this element
        let node = element;
        while (node && node.nodeType !== Node.ELEMENT_NODE) {
            node = node.parentNode;
        }
        
        // Find the paragraph or heading containing this element
        while (node && !['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'DIV'].includes(node.tagName)) {
            node = node.parentNode;
        }
        
        if (node) {
            const text = node.textContent;
            const sentences = text.split(/[.!?]+/);
            const elementText = element.textContent;
            
            // Find which sentence contains our element
            for (let sentence of sentences) {
                if (sentence.includes(elementText)) {
                    return sentence.trim() + '.';
                }
            }
        }
        
        return 'Context not available';
    },
    
    lightenColor: function(color, percent) {
        // Simple color lightening function
        const num = parseInt(color.replace("#", ""), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
            (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
            (B < 255 ? B < 1 ? 0 : B : 255))
            .toString(16).slice(1);
    }
}, 

                keyTerms: {
                name: 'Key Terms Mode',
                terms: [], // Will hold objects like {terms: ["example", "test*"], color: "#ff0000"}
                
                // Add these properties to the object
                termsData: {}, // Will store terms for each document ID
    
                activate: function(options) {

                // Use DocumentManager to access the current document
                if (DocumentManager.currentDocument && DocumentManager.currentDocument.id) {
                    // First check if the document has keyTerms property directly
                    if (DocumentManager.currentDocument.keyTerms && DocumentManager.currentDocument.keyTerms.length > 0) {
                        this.terms = DocumentManager.currentDocument.keyTerms;
                        // Update termsData as well
                        this.termsData[DocumentManager.currentDocument.id] = DocumentManager.currentDocument.keyTerms;
                    } else {
                        // Otherwise use termsData if available
                        this.terms = this.termsData[DocumentManager.currentDocument.id] || [];
                    }
                } else {
                    this.terms = [];
                }
                
                // Reset terms if options provided to reset
                if (options && options.resetTerms) {
                    this.terms = [];
                }
                
                // Show the key terms panel
                this.showKeyTermsPanel();
                
                // Set up mode-specific options in the active indicator
                this.setupOptions();
                
                // Apply highlighting if there are already terms defined
                if (this.terms.length > 0) {
                    this.applyHighlighting();
                }
                
                showNotification('Key Terms Mode enabled - Define terms to highlight', 'info');
            },
                
                deactivate: function() {
                     // Hide the key terms panel if it's open
                    this.hideKeyTermsPanel();
                    
                    // Remove all highlighting
                    this.removeHighlighting();
                    
                    // Remove any highlight styles from the document
                    const styleElements = document.querySelectorAll('style[data-key-terms-style]');
                    styleElements.forEach(el => el.remove());
                    
                    // Clear mode options
                    clearModeOptions();
                    
                    // Make sure editor is editable
                    editor.contentEditable = 'true';
                    
                    showNotification('Key Terms Mode disabled', 'info');
                },
                
                getOptions: function() {
                    return {
                        termCount: this.terms.length
                    };
                },
                
                setupOptions: function() {
                    // Clear existing options
                    clearModeOptions();
                    
                    // Create highlight button
                    const highlightButton = document.createElement('button');
                    highlightButton.className = 'toolbar-btn';
                    highlightButton.textContent = 'Apply Highlighting';
                    highlightButton.setAttribute('aria-label', 'Apply term highlighting');
                    highlightButton.addEventListener('click', () => this.applyHighlighting());
                    
                    // Create clear button
                    const clearButton = document.createElement('button');
                    clearButton.className = 'toolbar-btn';
                    clearButton.textContent = 'Clear Highlighting';
                    clearButton.setAttribute('aria-label', 'Clear all highlighting');
                    clearButton.addEventListener('click', () => this.removeHighlighting());
                    
                    // Create edit terms button
                    const editButton = document.createElement('button');
                    editButton.className = 'toolbar-btn';
                    editButton.textContent = 'Edit Terms';
                    editButton.setAttribute('aria-label', 'Edit key terms');
                    editButton.addEventListener('click', () => this.showKeyTermsPanel());
                    
                    // Create container for the buttons
                    const btnContainer = document.createElement('div');
                    btnContainer.className = 'toolbar-group';
                    btnContainer.appendChild(editButton);
                    btnContainer.appendChild(highlightButton);
                    btnContainer.appendChild(clearButton);
                    
                    // Add term count display
                    const termCount = document.createElement('span');
                    termCount.className = 'mode-option-label';
                    termCount.textContent = `${this.terms.length} term group${this.terms.length !== 1 ? 's' : ''} defined`;
                    termCount.style.marginLeft = '10px';
                    
                    // Add all elements to options
                    activeModeOptions.appendChild(btnContainer);
                    activeModeOptions.appendChild(termCount);
                },
                
                showKeyTermsPanel: function() {
                    // Check if the panel already exists
                    let panel = document.getElementById('key-terms-panel');
                    
                    if (!panel) {
                        // Create panel
                        panel = document.createElement('div');
                        panel.id = 'key-terms-panel';
                        panel.className = 'modal';
                        panel.setAttribute('role', 'dialog');
                        panel.setAttribute('aria-labelledby', 'key-terms-title');
                        
                        // Create panel content
                        panel.innerHTML = `
                            <div class="modal-content" style="max-width: 700px;">
                                <div class="modal-header">
                                    <div id="key-terms-title" class="modal-title">Key Terms</div>
                                    <button class="modal-close" aria-label="Close panel">&times;</button>
                                </div>
                                <div class="modal-body">
                                    <p>Define terms to highlight in your document. Separate multiple terms with commas. 
                                    Use * as a wildcard (e.g., "writ*" will match "write", "writing", etc.).</p>
                                    
                                    <div id="key-terms-list">
                                        <!-- Term rows will be added here -->
                                    </div>
                                    
                                    <button id="add-term-btn" class="action-btn" style="margin-top: 15px;">
                                        <i class="fas fa-plus"></i> Add Term Group
                                    </button>
                                </div>
                                <div class="modal-footer">
                                    <button id="key-terms-cancel" class="action-btn">Cancel</button>
                                    <button id="key-terms-apply" class="action-btn primary">Apply Highlighting</button>
                                </div>
                            </div>
                        `;
                        
                        // Add to document
                        document.body.appendChild(panel);
                        
                        // Set up event listeners
                        panel.querySelector('.modal-close').addEventListener('click', () => this.hideKeyTermsPanel());
                        panel.querySelector('#key-terms-cancel').addEventListener('click', () => this.hideKeyTermsPanel());
                        panel.querySelector('#key-terms-apply').addEventListener('click', () => {
                            this.saveTerms();
                            this.applyHighlighting();
                            this.hideKeyTermsPanel();
                        });
                        panel.querySelector('#add-term-btn').addEventListener('click', () => this.addTermRow());
                    }
                    
                    // Clear existing term rows
                    const termsList = panel.querySelector('#key-terms-list');
                    termsList.innerHTML = '';
                    
                    // Add a row for each existing term group
                    if (this.terms.length > 0) {
                        this.terms.forEach((term, index) => {
                            this.addTermRow(term.terms.join(', '), term.color);
                        });
                    } else {
                        // Add an empty row if no terms exist
                        this.addTermRow();
                    }
                    
                    // Show the panel
                    panel.style.display = 'flex';
                },
                
                hideKeyTermsPanel: function() {
                    const panel = document.getElementById('key-terms-panel');
                    if (panel) {
                        panel.style.display = 'none';
                    }
                },
                
                addTermRow: function(termsValue = '', colorValue = '#ffff00') {
                    const termsList = document.getElementById('key-terms-list');
                    
                    const rowId = 'term-row-' + Date.now();
                    const row = document.createElement('div');
                    row.id = rowId;
                    row.className = 'form-group';
                    row.style.display = 'flex';
                    row.style.alignItems = 'center';
                    row.style.marginBottom = '10px';
                    row.style.gap = '10px';
                    
                    // Terms input
                    const termsInput = document.createElement('input');
                    termsInput.type = 'text';
                    termsInput.className = 'form-input term-input';
                    termsInput.placeholder = 'Enter terms separated by commas';
                    termsInput.value = termsValue;
                    termsInput.style.flexGrow = '1';
                    
                    // Color selector
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.className = 'color-input';
                    colorInput.value = colorValue;
                    colorInput.style.width = '40px';
                    colorInput.style.height = '40px';
                    colorInput.style.padding = '0';
                    colorInput.style.border = '1px solid #ddd';
                    colorInput.style.borderRadius = '4px';
                    
                    // Remove button
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'action-btn';
                    removeBtn.innerHTML = '<i class="fas fa-trash"></i>';
                    removeBtn.setAttribute('aria-label', 'Remove term group');
                    removeBtn.addEventListener('click', () => {
                        row.remove();
                    });
                    
                    // Assemble row
                    row.appendChild(termsInput);
                    row.appendChild(colorInput);
                    row.appendChild(removeBtn);
                    
                    // Add to list
                    termsList.appendChild(row);
                    
                    // Focus the new input
                    termsInput.focus();
                },
                
                // Modify the 'saveTerms' method to store terms for the current document
                saveTerms: function() {
                    const panel = document.getElementById('key-terms-panel');
                if (!panel) return;
                
                // Clear existing terms
                this.terms = [];
                
                // Get all term rows
                const rows = panel.querySelectorAll('#key-terms-list > div');
                
                rows.forEach(row => {
                    const termsInput = row.querySelector('.term-input');
                    const colorInput = row.querySelector('.color-input');
                    
                    if (termsInput && colorInput && termsInput.value.trim()) {
                        // Split by comma and trim each term
                        const termsList = termsInput.value.split(',').map(term => term.trim()).filter(term => term);
                        
                        if (termsList.length > 0) {
                            this.terms.push({
                                terms: termsList,
                                color: colorInput.value
                            });
                        }
                    }
                });
                
                // Save terms for the current document
                if (DocumentManager.currentDocument && DocumentManager.currentDocument.id) {
                    // Store in termsData object
                    this.termsData[DocumentManager.currentDocument.id] = this.terms;
                    
                    // Also update the document object directly
                    DocumentManager.currentDocument.keyTerms = this.terms;
                    
                    // Save the document to persist changes
                    DocumentManager.saveDocument();
                }
                
                // Update the term count in the options
                this.setupOptions();
            },
                
                applyHighlighting: function() {
                    // First, remove any existing highlighting
                    this.removeHighlighting();
    
                    if (this.terms.length === 0) {
                        showNotification('No terms defined for highlighting', 'warning');
                        return;
                    }
                    
                    // Make editor temporarily not editable to apply highlighting
                    const wasEditable = editor.contentEditable;
                    editor.contentEditable = 'false';
                    
                    // Create an object to store highlight styles
                    const highlightStyles = {};
                    
                    // Process each term group to prepare regex patterns
                    const termPatterns = this.terms.map(termGroup => {
                        // Create patterns for each term in the group
                        const patterns = termGroup.terms.map(term => {
                            // Check if it's a wildcard term
                            const isWildcard = term.includes('*');
                            let pattern;
                            
                            if (isWildcard) {
                                // Convert wildcard to regex pattern
                                const termBase = term.replace('*', '');
                                const escapedTerm = this.escapeRegex(termBase);
                                pattern = new RegExp(`^${escapedTerm}\\w*$`, 'i');
                            } else {
                                // Create pattern for exact match (case insensitive)
                                const escapedTerm = this.escapeRegex(term);
                                pattern = new RegExp(`^${escapedTerm}$`, 'i');
                            }
                            
                            return {
                                original: term,
                                pattern: pattern
                            };
                        });
                        
                        // Generate a unique class name for this term group
                        const highlightClass = `key-term-highlight-${this.generateId()}`;
                        
                        // Store style information
                        highlightStyles[highlightClass] = termGroup.color;
                        
                        return {
                            patterns: patterns,
                            highlightClass: highlightClass
                        };
                    });
                    
                    // Add styles for all highlight classes
                    Object.entries(highlightStyles).forEach(([className, color]) => {
                        this.addHighlightStyle(className, color);
                    });
                    
                    // Walk through the DOM tree and apply highlighting to text nodes only
                    const walkDOM = (node) => {
                        // Skip highlight spans we've already created
                        if (node.classList && node.classList.contains('key-term-highlight')) {
                            return;
                        }
                        
                        // Process text nodes
                        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
                            // Split text into words while preserving whitespace and punctuation
                            const text = node.textContent;
                            const words = [];
                            let currentWord = '';
                            let currentNonWord = '';
                            
                            // Helper to add current segments to the arrays
                            const addSegments = () => {
                                if (currentWord) words.push({ type: 'word', text: currentWord });
                                if (currentNonWord) words.push({ type: 'nonword', text: currentNonWord });
                                currentWord = '';
                                currentNonWord = '';
                            };
                            
                            // Split text into word and non-word segments
                            for (let i = 0; i < text.length; i++) {
                                const char = text[i];
                                if (/\w/.test(char)) {
                                    // If we were collecting non-word chars and now found a word char
                                    if (currentNonWord) {
                                        words.push({ type: 'nonword', text: currentNonWord });
                                        currentNonWord = '';
                                    }
                                    currentWord += char;
                                } else {
                                    // If we were collecting word chars and now found a non-word char
                                    if (currentWord) {
                                        words.push({ type: 'word', text: currentWord });
                                        currentWord = '';
                                    }
                                    currentNonWord += char;
                                }
                            }
                            
                            // Add any remaining segments
                            addSegments();
                            
                            // If we have words to process
                            if (words.length > 0) {
                                // Create a document fragment to build the new content
                                const fragment = document.createDocumentFragment();
                                
                                // Process each segment
                                words.forEach(segment => {
                                    if (segment.type === 'nonword') {
                                        // For non-word segments, just add a text node
                                        fragment.appendChild(document.createTextNode(segment.text));
                                    } else {
                                        // For word segments, check for matches
                                        let matched = false;
                                        
                                        // Check each term pattern
                                        for (let i = 0; i < termPatterns.length; i++) {
                                            const termGroup = termPatterns[i];
                                            
                                            // Check each pattern in this group
                                            for (let j = 0; j < termGroup.patterns.length; j++) {
                                                const pattern = termGroup.patterns[j];
                                                
                                                if (pattern.pattern.test(segment.text)) {
                                                    // Create a highlight span
                                                    const span = document.createElement('span');
                                                    span.className = `key-term-highlight ${termGroup.highlightClass}`;
                                                    span.setAttribute('title', pattern.original);
                                                    span.textContent = segment.text;
                                                    fragment.appendChild(span);
                                                    
                                                    matched = true;
                                                    break;
                                                }
                                            }
                                            
                                            if (matched) break;
                                        }
                                        
                                        // If no match, add as plain text
                                        if (!matched) {
                                            fragment.appendChild(document.createTextNode(segment.text));
                                        }
                                    }
                                });
                                
                                // Replace the original text node with our processed fragment
                                node.parentNode.replaceChild(fragment, node);
                            }
                        } else if (node.nodeType === Node.ELEMENT_NODE) {
                            // Skip script and style elements
                            if (node.tagName.toLowerCase() === 'script' || 
                                node.tagName.toLowerCase() === 'style') {
                                return;
                            }
                            
                            // Process child nodes (make a copy of the list as it might change during processing)
                            Array.from(node.childNodes).forEach(child => {
                                walkDOM(child);
                            });
                        }
                    };
                    
                    // Start walking the DOM from the editor
                    walkDOM(editor);
                    
                    // Restore editability
                    editor.contentEditable = wasEditable;
                    
                    showNotification('Terms highlighted successfully', 'success');
                },
                
                removeHighlighting: function() {
                    // Find all highlight spans
                    const highlightSpans = editor.querySelectorAll('.key-term-highlight');
                    
                    if (highlightSpans.length === 0) return;
                    
                    // Make editor temporarily not editable
                    const wasEditable = editor.contentEditable;
                    editor.contentEditable = 'false';
                    
                    // Remove each highlight span while preserving its content
                    highlightSpans.forEach(span => {
                        const parent = span.parentNode;
                        if (parent) {
                            // Replace the span with its text content
                            const text = document.createTextNode(span.textContent);
                            parent.replaceChild(text, span);
                        }
                    });
                    
                    // Normalize the editor to combine adjacent text nodes
                    editor.normalize();
                    
                    // Remove any highlight styles
                    const styleElements = document.querySelectorAll('style[data-key-terms-style]');
                    styleElements.forEach(el => el.remove());
                    
                    // Restore editability
                    editor.contentEditable = wasEditable;
                },
                
                // Helper function to escape special regex characters
                escapeRegex: function(string) {
                    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                },
                
                // Generate a unique ID for highlight classes
                generateId: function() {
                    return `id-${Math.random().toString(36).substr(2, 9)}`;
                },
                
                // Add a style for a highlight class
                addHighlightStyle: function(className, color) {
                    // Create style element
                    const style = document.createElement('style');
                    style.setAttribute('data-key-terms-style', 'true');
                    
                    // Create CSS rule with semi-transparent background
                    const rgba = this.hexToRgba(color, 0.3);
                    
                    style.textContent = `
                        .${className} {
                            background-color: ${rgba};
                            border-bottom: 1px solid ${color};
                            border-radius: 2px;
                            padding: 0 2px;
                            margin: 0 -2px;
                        }
                        
                        .${className}:hover {
                            background-color: ${this.hexToRgba(color, 0.5)};
                        }
                    `;
                    
                    // Add to document head
                    document.head.appendChild(style);
                },
                
                // Convert hex color to rgba
                hexToRgba: function(hex, alpha = 1) {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
            }
        }
        

        // Helper function to clear mode options
        function clearModeOptions() {
            if (activeModeOptions) {
                activeModeOptions.innerHTML = '';
            }
        }

        // This function doesn't create HTML, it just checks if it exists
        function checkModesExist() {
        console.log("Checking if mode cards exist in HTML");
        
        // Check if Fire mode exists in HTML
        const fireCard = document.querySelector('.mode-card[data-mode="fire"]');
        if (!fireCard) {
            console.error("Fire Mode card is missing from HTML structure");
        }
        
        // Check if Key Terms mode exists in HTML
        const keyTermsCard = document.querySelector('.mode-card[data-mode="keyTerms"]');
        if (!keyTermsCard) {
            console.error("Key Terms Mode card is missing from HTML structure");
        }
        
        // Add Key Terms styles if that mode exists
        if (keyTermsCard && typeof addKeyTermsStyles === 'function') {
            addKeyTermsStyles();
        }
        
        return {
            fireExists: !!fireCard,
            keyTermsExists: !!keyTermsCard
        };
        }

        

        // Add CSS for the key terms panel
        function addKeyTermsStyles() {
            const style = document.createElement('style');
            style.textContent = `
                #key-terms-panel .modal-content {
                    max-width: 700px;
                }
                
                #key-terms-list {
                    max-height: 300px;
                    overflow-y: auto;
                    margin: 15px 0;
                }
                
                .key-term-highlight {
                    transition: background-color 0.2s ease;
                }
                
                /* Add a better style for color inputs */
                input[type="color"] {
                    -webkit-appearance: none;
                    appearance: none;
                    cursor: pointer;
                }
                
                input[type="color"]::-webkit-color-swatch-wrapper {
                    padding: 0;
                }
                
                input[type="color"]::-webkit-color-swatch {
                    border: none;
                    border-radius: 3px;
                }
            `;
            
            document.head.appendChild(style);
        }

     


       // 5. Simplified initModeSystem - sets up panel controls without modifying HTML
        function initModeSystem() {
        console.log("Initializing mode system");
        
        // Panel toggle controls
        if (modesToggleBtn) {
            modesToggleBtn.addEventListener('click', toggleModesPanel);
        }
        
        if (closePanelBtn) {
            closePanelBtn.addEventListener('click', closeModesPanel);
        }
        
        if (modesPanelOverlay) {
            modesPanelOverlay.addEventListener('click', closeModesPanel);
        }
        
        if (disableModeBtn) {
            disableModeBtn.addEventListener('click', () => disableCurrentMode(false));
        }
        
        // Set up Textris level select
        if (textrisPanelSelect) {
            textrisPanelSelect.value = textrisModeLevel;
            
            textrisLevelSelect.addEventListener('change', () => {
            textrisPanelSelect.value = textrisLevelSelect.value;
            });
            
            textrisPanelSelect.addEventListener('change', () => {
            if (currentMode === 'textris') {
                textrisLevelSelect.value = textrisPanelSelect.value;
                applyTextrisMode();
            }
            });
        }

          // ADD THIS NEW EVENT DELEGATION CODE
    // Global event listener for mode activation buttons
    document.addEventListener('click', function(e) {
    const button = e.target.closest('.activate-mode-btn:not([disabled])');
    
    if (button) {
        const modeCard = button.closest('.mode-card');
        if (modeCard && modeCard.dataset.mode) {
            e.preventDefault();
            const modeName = modeCard.dataset.mode;
            console.log(`Activating ${modeName} mode via delegation`);
            
            // Create options for specific modes
            let options = {};
            
            if (modeName === 'textris') {
                const textrisPanelSelect = document.getElementById('textris-panel-select');
                if (textrisPanelSelect) {
                    options.level = textrisPanelSelect.value;
                }
            }
            
            if (modeName === 'infrared') {
                const infraredPanelSelect = document.getElementById('infrared-pattern-select');
                if (infraredPanelSelect) {
                    options.pattern = infraredPanelSelect.value;
                }
            }
            
            // Activate the mode and close the panel
            activateMode(modeName, options);
            closeModesPanel();
        }
    }
});
       

    // Define global functions for the onclick attributes
    window.exitReaderMode = function() {
        console.log("Global exitReaderMode called");
        
        // First, save any reflections
        if (modes.reader) {
            try {
            modes.reader.saveReflections();
            } catch (e) {
            console.error("Error saving reflections:", e);
            }
        }
        
        // Find and remove the modal
        const readerModal = document.querySelector('.reader-modal-backdrop');
        if (readerModal && readerModal.parentNode) {
            readerModal.parentNode.removeChild(readerModal);
        }
        
        // Disable the current mode 
        disableCurrentMode(false);
        
        // Additional cleanup
        document.body.classList.remove('reader-mode-active');
        
        // Show notification
        showNotification('Reader Mode disabled');
        };

        window.readerRevealAll = function() {
        if (modes.reader) {
            const container = document.getElementById('reader-mode-container');
            if (container) {
            modes.reader.revealAllSentences(container);
            }
        }
        };
        
        // Override toggleTextrisMode
        window.toggleTextrisMode = function() {
            if (textrisMode) {
            disableCurrentMode(false);
            } else {
            activateMode('textris', { level: textrisModeLevel });
            }
        };
        
        // Add Escape key handler
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && currentMode) {
            disableCurrentMode(false);
            e.preventDefault();
            }
        });
        
        // Update which mode is active
        updateModeCardStates();
        
        }

        // Initialize accessibility features
        function initAccessibility() {
            setupSidebarAccessibility();
            
            // Make modals accessible
            document.querySelectorAll('.modal').forEach(modal => {
                modal.setAttribute('aria-hidden', 'true');
            });
            
            // Set initial ARIA state for modes panel
            if (modesPanel) {
                modesPanel.setAttribute('aria-hidden', 'true');
                modesToggleBtn.setAttribute('aria-expanded', 'false');
            }
            
            // Add keyboard support to the document list items
            document.querySelectorAll('.document-item').forEach(item => {
                item.setAttribute('tabindex', '0');
            });
            
            // Enhance notification behavior
            notification.setAttribute('role', 'alert');
            
            // Make editor more accessible
            if (editor) {
                editor.setAttribute('aria-multiline', 'true');
                editor.setAttribute('role', 'textbox');
            }
        }

       // Enhancement for toggleModesPanel function
       function toggleModesPanel() {
        if (modesPanel.classList.contains('visible')) {
            closeModesPanel();
        } else {
            openModesPanel();
        }
        }

        // Add this helper function to expand the infrared word lists (for future enhancement)
function expandInfraredPatterns() {
    // Function to add new patterns or words to existing patterns
    // This allows for easy expansion of the infrared mode capabilities
    
    // Example of how to add a new pattern:
    /*
    modes.infrared.patterns.hedging = {
        name: 'Hedging Language',
        color: '#CD5C5C', // Indian red
        description: 'Highlights words that indicate uncertainty or qualification',
        words: [
            'seem', 'appear', 'suggest', 'indicate', 'imply', 'tend to',
            'generally', 'usually', 'often', 'sometimes', 'perhaps',
            'possibly', 'probably', 'likely', 'might', 'may', 'could'
        ]
    };
    */
    
    // Example of how to add words to existing patterns:
    /*
    modes.infrared.patterns.jargon.words.push(
        'facilitate', 'optimization', 'leverage', 'paradigm', 'synergy'
    );
    */
}

// Helper function to validate infrared pattern data
function validateInfraredPattern(patternKey, pattern) {
    const requiredFields = ['name', 'color', 'description', 'words'];
    const missingFields = requiredFields.filter(field => !pattern[field]);
    
    if (missingFields.length > 0) {
        console.error(`Infrared pattern "${patternKey}" is missing required fields:`, missingFields);
        return false;
    }
    
    if (!Array.isArray(pattern.words) || pattern.words.length === 0) {
        console.error(`Infrared pattern "${patternKey}" must have a non-empty words array`);
        return false;
    }
    
    return true;
}


       // 4. Panel open/close functions that respect existing HTML
        function openModesPanel() {
        console.log("Opening modes panel");
        
        // Show the panel
        if (modesPanel) {
            modesPanel.classList.add('visible');
        }
        
        if (modesPanelOverlay) {
            modesPanelOverlay.classList.add('visible');
        }
        
        // Update ARIA attributes
        if (modesPanel) {
            modesPanel.setAttribute('aria-hidden', 'false');
        }
        
        if (modesToggleBtn) {
            modesToggleBtn.setAttribute('aria-expanded', 'true');
        }
        
       
        }

        // We need to modify the activateMode function to handle Pomodoro's special case
        function activateMode(modeName, options = {}) {
        console.log(`Activating mode: ${modeName}`, options);
        
        try {
            // Special case for Pomodoro mode - don't disable other modes
            if (modeName === 'pomodoro') {
                modes.pomodoro.activate(options);
                updateModeCardStates();
                return;
            }
            
            // For other modes, follow the normal process
            if (currentMode && currentMode !== 'pomodoro') {
                disableCurrentMode(true);
            }
            
            // Check if the mode exists
            if (!modes[modeName]) {
                console.error(`Mode "${modeName}" not found in modes object`);
                showNotification(`Error: Mode "${modeName}" not found`, 'error');
                return;
            }
            
            // Reset editor state before activating
            resetEditorState();
            
            // Handle mode-specific options
            if (modeName === 'textris') {
                // Get level from panel select or options
                const level = options.level || 
                            (document.getElementById('textris-panel-select') ? 
                            document.getElementById('textris-panel-select').value : 'paragraph');
                options.level = level;
            }
            
            if (modeName === 'infrared') {
                // Get pattern from panel select or options
                const pattern = options.pattern || 
                            (document.getElementById('infrared-pattern-select') ? 
                                document.getElementById('infrared-pattern-select').value : 'jargon');
                options.pattern = pattern;
            }
            
            // Activate the mode
            modes[modeName].activate(options);
            currentMode = modeName;
            
            // Update the mode indicator
            activeModeName.textContent = modes[modeName].name;
            activeModeIndicator.classList.add('visible');
            
            // Update card states
            updateModeCardStates();
        } catch (error) {
            console.error(`Error activating ${modeName} mode:`, error);
            showNotification(`Error activating ${modeName} mode: ${error.message}`, 'error');
        }
    }


        // 3. Also let's add a debugging helper to trace errors in the mode activation
        function traceMode(modeName) {
            console.log(`Tracing mode: ${modeName}`);
            
            if (!modes[modeName]) {
                console.error(`Mode "${modeName}" not found`);
                return;
            }
            
            // Check that the mode has all required methods
            const requiredMethods = ['activate', 'deactivate', 'getOptions', 'setupOptions'];
            
            requiredMethods.forEach(method => {
                if (typeof modes[modeName][method] !== 'function') {
                    console.error(`Mode "${modeName}" is missing required method: ${method}`);
                } else {
                    console.log(`Mode "${modeName}" has method: ${method}`);
                }
            });
            
            // Log the structure of the mode
            console.log(`Mode "${modeName}" structure:`, Object.keys(modes[modeName]));
            
            // Try to call getOptions safely
            try {
                const options = modes[modeName].getOptions();
                console.log(`Mode "${modeName}" options:`, options);
            } catch (error) {
                console.error(`Error getting options for mode "${modeName}":`, error);
            }
        }


        // Add focus trapping to modals
        function trapFocus(element) {
            // Get all focusable elements
            const focusableElements = element.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            
            if (focusableElements.length === 0) return;
            
            const firstElement = focusableElements[0];
            const lastElement = focusableElements[focusableElements.length - 1];
            
            // Focus the first element
            firstElement.focus();
            
            // Add keydown event to trap focus
            element.addEventListener('keydown', function(e) {
                if (e.key === 'Tab') {
                    // Shift+Tab pressed on first element
                    if (e.shiftKey && document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    } 
                    // Tab pressed on last element
                    else if (!e.shiftKey && document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                }
                
                // Close on Escape key
                if (e.key === 'Escape') {
                    if (element === modesPanel) {
                        closeModesPanel();
                    } else {
                        // For modals
                        closeModals();
                    }
                }
            });
        }

        function closeModesPanel() {
        // Hide the panel
        if (modesPanel) {
            modesPanel.classList.remove('visible');
        }
        
        if (modesPanelOverlay) {
            modesPanelOverlay.classList.remove('visible');
        }
        
        // Update ARIA attributes
        if (modesPanel) {
            modesPanel.setAttribute('aria-hidden', 'true');
        }
        
        if (modesToggleBtn) {
            modesToggleBtn.setAttribute('aria-expanded', 'false');
        }
        
        // Return focus to the toggle button
        if (modesToggleBtn) {
            modesToggleBtn.focus();
        }
        }



        // Add debug for the click delegation
        function debugModeActivation() {
            // Add a debugging wrapper around the delegation handler
            const originalAddEventListener = document.addEventListener;
            document.addEventListener = function(type, listener, options) {
                if (type === 'click') {
                    const wrappedListener = function(e) {
                        console.log('Click event captured');
                        const button = e.target.closest('.activate-mode-btn:not([disabled])');
                        if (button) {
                            console.log('Activate button clicked:', button);
                            const modeCard = button.closest('.mode-card');
                            if (modeCard) {
                                console.log('Mode card found:', modeCard.dataset.mode);
                            }
                        }
                        return listener.apply(this, arguments);
                    };
                    return originalAddEventListener.call(this, type, wrappedListener, options);
                }
                return originalAddEventListener.call(this, type, listener, options);
            };
            
            // Debug code to check all active event listeners after init
            setTimeout(() => {
                console.log('Checking mode cards and activate buttons...');
                document.querySelectorAll('.mode-card').forEach(card => {
                    console.log('Mode card:', card.dataset.mode);
                    const btn = card.querySelector('.activate-mode-btn');
                    if (btn) {
                        console.log('- Has activate button');
                    }
                });
            }, 1000);
        }

        // Enhanced disableCurrentMode with more thorough cleanup
        

                // Also need to modify the disableCurrentMode function
                function disableCurrentMode(isSwitchingModes = false) {
                    if (currentMode) {
                        // Don't disable Pomodoro if it wasn't the active mode
                        if (currentMode !== 'pomodoro') {
                            // Call the mode-specific deactivation
                            modes[currentMode].deactivate();
                            
                            // Global cleanup for all modes
                            performGlobalModeCleanup();
                            
                            // Reset the current mode
                            currentMode = null;
                            
                            // Only hide the mode indicator if we're not switching modes
                            if (!isSwitchingModes) {
                                activeModeIndicator.classList.remove('visible');
                            }
                            
                            // Update card states
                            updateModeCardStates();
                            
                            // Make sure the editor is editable again
                            editor.contentEditable = 'true';
                        } else {
                            // Special case for Pomodoro - just deactivate it
                            modes.pomodoro.deactivate();
                            
                            // If it was the current mode, reset
                            currentMode = null;
                            activeModeIndicator.classList.remove('visible');
                            updateModeCardStates();
                        }
                    }
                }

        // 4. Safer version of performGlobalModeCleanup
        function performGlobalModeCleanup() {
            try {
                // Remove any common classes that might be added by modes
                editor.classList.remove('textris-mode', 'fire-mode', 'reader-mode', 'key-terms-mode');
                
                // Clean up any mutation observers
                if (window.currentModeObserver) {
                    window.currentModeObserver.disconnect();
                    window.currentModeObserver = null;
                }
                
                // Remove any special backgrounds or overlays
                const specialBackgrounds = document.querySelectorAll('.fire-background, .reader-background');
                specialBackgrounds.forEach(el => {
                    if (el.parentNode) {
                        el.parentNode.removeChild(el);
                    }
                });
                
                // Clean up any modals that might be open
                const modeModals = document.querySelectorAll('.reader-modal-backdrop, .key-terms-panel');
                modeModals.forEach(modal => {
                    if (modal.style.display === 'flex' || modal.style.display === 'block') {
                        modal.style.display = 'none';
                    }
                });
                
                // Reset any draggable elements
                const draggableElements = editor.querySelectorAll('[draggable="true"]');
                draggableElements.forEach(el => {
                    el.removeAttribute('draggable');
                    el.classList.remove('dragging', 'drag-target');
                });
                
                // Remove specific mode elements
                const modeElements = editor.querySelectorAll('.textris-sentence, .fire-sentence, .key-term-highlight');
                modeElements.forEach(el => {
                    try {
                        // Only remove if the element still exists in the DOM
                        if (el.parentNode) {
                            // Replace with its content
                            while (el.firstChild) {
                                el.parentNode.insertBefore(el.firstChild, el);
                            }
                            el.parentNode.removeChild(el);
                        }
                    } catch (err) {
                        console.error('Error cleaning up mode element:', err);
                    }
                });
                
                // Normalize the DOM to join adjacent text nodes
                editor.normalize();
            } catch (error) {
                console.error('Error during global mode cleanup:', error);
            }
        }

        function addHistoryToDropEvent(element, originalDropHandler) {
            element.addEventListener('drop', (e) => {
                originalDropHandler(e);
                textrisHistory.saveState();
            });
        }

        // Update the visual state of mode cards
        function updateModeCardStates() {
            // Remove active class from all cards
            modeCards.forEach(card => {
                card.classList.remove('active');
            });
            
            // Add active class to the current mode's card
            if (currentMode) {
                const activeCard = document.querySelector(`.mode-card[data-mode="${currentMode}"]`);
                if (activeCard) {
                    activeCard.classList.add('active');
                }
            }
        }


          // WITH this simple version:
userProfileBtn.addEventListener('click', () => {
    openModal(userProfileModal);
});
           



 function init() {
    // Remove all user/login logic and just run initialization directly
    runCompleteInitialization();
}

        // Function to remove duplicate tooltips
        function fixTooltips() {
        // Find all elements with title attributes that have custom tooltips
        const elements = document.querySelectorAll('.toolbar-btn[title], .action-btn[title], .modes-toggle-btn[title]');
        
        elements.forEach(el => {
            // Store the original title for accessibility and our custom tooltip
            const originalTitle = el.getAttribute('title');
            
            // Set data attribute for our custom tooltip to use
            el.setAttribute('data-tooltip', originalTitle);
            
            // Remove title on mouseenter to prevent browser tooltip
            el.addEventListener('mouseenter', () => {
            el.setAttribute('data-original-title', originalTitle);
            el.removeAttribute('title');
            });
            
            // Restore title on mouseleave for accessibility
            el.addEventListener('mouseleave', () => {
            el.setAttribute('title', el.getAttribute('data-original-title'));
            });
        });
        }

        // Call this function after the DOM is loaded
        document.addEventListener('DOMContentLoaded', fixTooltips);

      // Updated Toggle Sidebar Function
        function toggleSidebar() {
            const platformContainer = document.querySelector('.platform-container');
            platformContainer.classList.toggle('sidebar-collapsed');
            
            // Save state to localStorage
            const isCollapsed = platformContainer.classList.contains('sidebar-collapsed');
            localStorage.setItem('sidebar_collapsed', isCollapsed);
            
            // Give some time for transitions to complete, then trigger window resize
            setTimeout(() => {
                window.dispatchEvent(new Event('resize'));
            }, 300);
        }

       // Updated sidebar functionality for left edge trigger
        // Updated sidebar functionality without close button
function setupLeftEdgeSidebar() {
    // Get references to key elements
    const sidebarTrigger = document.querySelector('.sidebar-trigger');
    const sidebar = document.querySelector('.sidebar');
    
    // Remove any existing sidebar toggle button
    const oldToggleButton = document.getElementById('sidebar-toggle');
    if (oldToggleButton) {
        oldToggleButton.style.display = 'none';
    }
    
    // State tracking for keyboard toggle
    let sidebarOpen = false;
    
    // Function to toggle sidebar with keyboard
    function toggleSidebarKeyboard() {
        if (sidebarOpen) {
            sidebar.style.transform = 'translateX(-100%)';
            sidebarOpen = false;
        } else {
            sidebar.style.transform = 'translateX(0)';
            sidebarOpen = true;
            
            // Auto-hide after 5 seconds if opened with keyboard
            setTimeout(() => {
                if (sidebarOpen) {
                    sidebar.style.transform = 'translateX(-100%)';
                    sidebarOpen = false;
                }
            }, 5000);
        }
    }
    
    // For mobile: Add touch event support
    sidebarTrigger.addEventListener('touchstart', function(e) {
        e.preventDefault(); // Prevent default touch behavior
        sidebar.style.transform = 'translateX(0)';
        
        // Auto-hide after inactivity
        setTimeout(() => {
            sidebar.style.transform = 'translateX(-100%)';
        }, 5000);
    });
    
    // Keyboard shortcut (Ctrl+B or Cmd+B) to toggle sidebar
    document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
            e.preventDefault();
            toggleSidebarKeyboard();
        }
    });
}



        // Load documents from localStorage or use demo documents
        function loadDocuments() {
            const storedDocuments = localStorage.getItem('nyu_writing_documents');
            if (storedDocuments) {
                documents = JSON.parse(storedDocuments);
            } else {
                // Use demo documents for first-time users
                documents = demoDocuments;
                // Save to localStorage
                localStorage.setItem('nyu_writing_documents', JSON.stringify(documents));
            }
        }

        // Add this after your existing loadDocuments function
        function loadDocumentsWithKeyTerms() {
           // First, load documents normally
    this.load();
    
    // Ensure keyTerms mode is initialized before trying to access it
    if (!modes.keyTerms) {
        modes.keyTerms = {
            name: 'Key Terms Mode',
            terms: [],
            termsData: {}
        };
    }
    
    // Make sure termsData exists
    if (!modes.keyTerms.termsData) {
        modes.keyTerms.termsData = {};
    }
    
    // Then, process each document to load key terms data
    this.documents.forEach(doc => {
        // If the document has key terms, store them in the keyTerms mode
        if (doc.keyTerms && doc.keyTerms.length > 0) {
            // Store the terms for this document
            modes.keyTerms.termsData[doc.id] = doc.keyTerms;
        }
    });
}

        // 1. Fix the resetEditorState function
        function resetEditorState() {
            // Reset drag state
            draggedElement = null;
            dragTarget = null;
            
            // DO NOT replace the editor element - this breaks the reference to the global editor
            // Instead, just clean up event listeners more selectively
            
            // Clear any extra classes that modes might have added
            editor.classList.remove('textris-mode', 'fire-mode', 'reader-mode', 'key-terms-mode');
            
            // Remove any specific mode elements without replacing the editor
            const modeElements = editor.querySelectorAll('.textris-sentence, .fire-sentence, .key-term-highlight');
            modeElements.forEach(el => {
                // Replace with its content
                const parent = el.parentNode;
                if (parent) {
                    while (el.firstChild) {
                        parent.insertBefore(el.firstChild, el);
                    }
                    parent.removeChild(el);
                }
            });
            
            // Make sure editor is editable
            editor.contentEditable = 'true';
        }

        // Create a function to dynamically update document list with ARIA attributes
        function renderDocumentList() {
            documentList.innerHTML = '';
            documents.forEach(doc => {
                const listItem = document.createElement('li');
                listItem.className = 'document-item';
                listItem.setAttribute('role', 'button');
                listItem.setAttribute('tabindex', '0');
                listItem.setAttribute('aria-label', `Open document: ${doc.title}`);
                listItem.dataset.id = doc.id;
                
                if (activeDocumentId === doc.id) {
                    listItem.classList.add('active');
                    listItem.setAttribute('aria-current', 'true');
                }
                
                const date = new Date(doc.lastModified);
                const formattedDate = date.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric'
                });
                
                listItem.innerHTML = `
                    <div class="doc-title">${doc.title}</div>
                    <div class="doc-date">Last edited: ${formattedDate}</div>
                `;
                
                // Add both click and keyboard event listeners
                listItem.addEventListener('click', () => DocumentManager.openDocument(doc.id));
                listItem.addEventListener('keydown', (e) => {
                    // Open document on Enter or Space key
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        DocumentManager.openDocument(doc.id);
                    }
                });
                
                documentList.appendChild(listItem);
            });
        }

        // Modify this function to apply highlighting if Key Terms mode is active
        function openDocument(docId) {
            // Find the document in our list
            const document = documents.find(doc => doc.id === docId);
            if (!document) return;
            
            // Update active document
            activeDocumentId = docId;
            currentDocument = document;
            
            // Update UI
            documentTitle.textContent = document.title;
            editor.innerHTML = document.content || '';
            updateWordCount();
            updateLastSaved();
            
            // Reset unsaved changes flag
            hasUnsavedChanges = false;
            
            // If Key Terms mode is active, apply highlighting for this document
            if (currentMode === 'keyTerms' && modes.keyTerms) {
                // Load terms for this document
                modes.keyTerms.terms = modes.keyTerms.termsData[docId] || [];
                // Update options display
                modes.keyTerms.setupOptions();
                // Apply highlighting if there are terms
                if (modes.keyTerms.terms.length > 0) {
                    modes.keyTerms.applyHighlighting();
                }
            }
            
            // If Textris mode is active, apply it to the new document
            if (textrisMode) {
                applyTextrisMode();
            }
            
            // Update active state in document list
            renderDocumentList();
        }

        // Enhanced saveDocument function to store key terms
        // The issue is in how we're loading the key terms data
// The current loadDocumentsWithKeyTerms function isn't properly initializing the termsData

// 1. First, fix the loadDocumentsWithKeyTerms function
function loadDocumentsWithKeyTerms() {
    // First, load documents normally
    loadDocuments();
    
    // Ensure keyTerms mode is initialized before trying to access it
    if (!modes.keyTerms) {
        modes.keyTerms = {
            name: 'Key Terms Mode',
            terms: [],
            termsData: {}
        };
    }
    
    // Make sure termsData exists
    if (!modes.keyTerms.termsData) {
        modes.keyTerms.termsData = {};
    }
    
    // Then, process each document to load key terms data
    documents.forEach(doc => {
        // If the document has key terms, store them in the keyTerms mode
        if (doc.keyTerms && doc.keyTerms.length > 0) {
            // Store the terms for this document
            modes.keyTerms.termsData[doc.id] = doc.keyTerms;
            
            // Log for debugging
            console.log(`Loaded ${doc.keyTerms.length} key term groups for document: ${doc.title}`);
        }
    });
}

        // 2. Ensure keyTerms are properly captured during document save
        function saveDocument() {
            if (!currentDocument) return;
            
            // Update the document content
            currentDocument.content = editor.innerHTML;
            currentDocument.plainText = editor.innerText || '';
            currentDocument.lastModified = new Date().toISOString();
            currentDocument.wordCount = countWords(editor.innerText || '');
            
            // Save key terms data if available
            if (modes.keyTerms) {
                // Make sure we're saving the terms from the current document
                if (currentMode === 'keyTerms') {
                    // The terms array directly contains the current document's terms
                    currentDocument.keyTerms = modes.keyTerms.terms;
                } else if (modes.keyTerms.termsData && modes.keyTerms.termsData[currentDocument.id]) {
                    // If not in key terms mode, use the stored terms for this document
                    currentDocument.keyTerms = modes.keyTerms.termsData[currentDocument.id];
                }
                
                // Ensure we update the termsData object as well
                if (currentDocument.keyTerms && currentDocument.keyTerms.length > 0) {
                    if (!modes.keyTerms.termsData) {
                        modes.keyTerms.termsData = {};
                    }
                    modes.keyTerms.termsData[currentDocument.id] = currentDocument.keyTerms;
                }
            }
            
            // Find the document in our list and update it
            const index = documents.findIndex(doc => doc.id === currentDocument.id);
            if (index !== -1) {
                documents[index] = currentDocument;
            }
            
            // Save to localStorage
            try {
                localStorage.setItem('nyu_writing_documents', JSON.stringify(documents));
                
                // Clear unsaved changes flag after successful save
                hasUnsavedChanges = false;
                
                // Update UI
                updateLastSaved();
                renderDocumentList();
                
                // Show notification
                showNotification('Document saved successfully!');
            } catch (error) {
                // Handle localStorage errors
                console.error('Failed to save document:', error);
                showNotification('Error saving document! Storage may be full.', 'error');
            }
        }

        // Create a new document
        function createNewDocument() {
            const title = newDocTitle.value.trim() || 'Untitled Document';
            const description = newDocDescription.value.trim();
            
            // Create HTML content if description is provided
            let content = '';
            if (description) {
                content = `<p>${description}</p>`;
            }
            
            const newDocument = {
                id: 'doc' + Date.now(),
                title: title,
                content: content,
                plainText: description || '',
                lastModified: new Date().toISOString(),
                wordCount: countWords(description)
            };
            
            // Add to documents list
            documents.unshift(newDocument);
            
            // Save to localStorage
            localStorage.setItem('nyu_writing_documents', JSON.stringify(documents));
            
            // Reset form
            newDocTitle.value = '';
            newDocDescription.value = '';
            
            // Close modal
            closeModals();
            
            // Open the new document
            DocumentManager.openDocument(newDocument.id);
            
            // Focus the editor
            editor.focus();
            
            // Show notification
            showNotification('New document created!');
        }

        // Replace the existing downloadDocument function with this enhanced version
        function downloadDocument() {
            if (!currentDocument) return;
            
            // Create filename from document title with .doc extension
            const filename = (currentDocument.title || 'document').replace(/[^a-z0-9]/gi, '_').toLowerCase() + '.doc';
            
            // Create a complete HTML document that Word can interpret
            const wordCompatibleHTML = `
                <html xmlns:o="urn:schemas-microsoft-com:office:office"
                    xmlns:w="urn:schemas-microsoft-com:office:word"
                    xmlns="http://www.w3.org/TR/REC-html40">
                <head>
                    <meta charset="utf-8">
                    <title>${currentDocument.title || 'Document'}</title>
                    <!--[if gte mso 9]>
                    <xml>
                        <w:WordDocument>
                            <w:View>Print</w:View>
                            <w:Zoom>100</w:Zoom>
                            <w:DoNotOptimizeForBrowser/>
                        </w:WordDocument>
                    </xml>
                    <![endif]-->
                    <style>
                        /* Basic styles for Word compatibility */
                        body {
                            font-family: 'Calibri', sans-serif;
                            font-size: 11pt;
                            line-height: 1.5;
                        }
                        h1 { font-size: 16pt; color: #57068c; }
                        h2 { font-size: 14pt; color: #57068c; }
                        h3 { font-size: 12pt; color: #57068c; }
                        p { margin: 0 0 10pt 0; }
                        
                        /* Remove highlight styling for Word */
                        .key-term-highlight {
                            background-color: transparent !important;
                            border-bottom: none !important;
                        }
                    </style>
                </head>
                <body>
                    ${editor.innerHTML}
                </body>
                </html>`;
            
            // Create blob with the Word-compatible HTML content
            const blob = new Blob([wordCompatibleHTML], {type: 'application/msword'});
            
            // Create download link
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            
            // Append to body, click and remove
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Clean up the URL object
            setTimeout(() => {
                URL.revokeObjectURL(link.href);
            }, 100);
            
            showNotification('Document downloaded as Word (.doc) file');
        }

        // Add an alternative download as HTML option
function downloadAsHTML() {
    if (!currentDocument) return;
    
    // Create filename from document title
    const filename = (currentDocument.title || 'document').replace(/[^a-z0-9]/gi, '_').toLowerCase() + '.html';
    
    // Create a complete HTML document with content
    const htmlContent = `<!DOCTYPE html>
                <html>
                <head>
                <meta charset="UTF-8">
                <title>${currentDocument.title || 'Document'}</title>
                <style>
                    body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }
                    h1, h2, h3 { color: #57068c; }
                </style>
                </head>
                <body>
                <h1>${currentDocument.title || 'Document'}</h1>
                ${editor.innerHTML}
                </body>
                </html>`;
    
    // Create download link
    const element = document.createElement('a');
    element.setAttribute('href', 'data:text/html;charset=utf-8,' + encodeURIComponent(htmlContent));
    element.setAttribute('download', filename);
    
    element.style.display = 'none';
    document.body.appendChild(element);
    
    element.click();
    
    document.body.removeChild(element);
    showNotification('Document downloaded as HTML file');
}

// Modify the toolbar to include download options dropdown
function addDownloadOptions() {
    // Find the existing download button
    const downloadBtn = document.querySelector('.toolbar-btn[title="Download"]');
    
    if (downloadBtn) {
        // Replace the original download button with a dropdown
        const downloadGroupContainer = downloadBtn.parentNode;
        
        // Remove the existing download button
        downloadBtn.remove();
        
        // Create the new download dropdown button
        const dropdownContainer = document.createElement('div');
        dropdownContainer.className = 'download-dropdown';
        dropdownContainer.style.position = 'relative';
        dropdownContainer.style.display = 'inline-block';
        
        const dropdownBtn = document.createElement('button');
        dropdownBtn.className = 'toolbar-btn';
        dropdownBtn.title = 'Download Options';
        dropdownBtn.innerHTML = '<i class="fas fa-download"></i>';
        dropdownBtn.setAttribute('aria-label', 'Download options');
        dropdownBtn.setAttribute('aria-expanded', 'false');
        dropdownBtn.setAttribute('aria-haspopup', 'true');
        
        const dropdownContent = document.createElement('div');
        dropdownContent.className = 'download-dropdown-content';
        dropdownContent.style.display = 'none';
        dropdownContent.style.position = 'absolute';
        dropdownContent.style.backgroundColor = '#fff';
        dropdownContent.style.minWidth = '160px';
        dropdownContent.style.boxShadow = '0px 8px 16px 0px rgba(0,0,0,0.2)';
        dropdownContent.style.zIndex = '1001';
        dropdownContent.style.borderRadius = '4px';
        dropdownContent.style.border = '1px solid #ddd';
        
        // Add download options
        const wordOption = document.createElement('a');
        wordOption.textContent = 'Download as Word (.doc)';
        wordOption.href = '#';
        wordOption.style.color = '#333';
        wordOption.style.padding = '12px 16px';
        wordOption.style.textDecoration = 'none';
        wordOption.style.display = 'block';
        wordOption.style.fontFamily = "'Open Sans', sans-serif";
        wordOption.style.fontSize = '14px';
        
        const htmlOption = document.createElement('a');
        htmlOption.textContent = 'Download as HTML';
        htmlOption.href = '#';
        htmlOption.style.color = '#333';
        htmlOption.style.padding = '12px 16px';
        htmlOption.style.textDecoration = 'none';
        htmlOption.style.display = 'block';
        htmlOption.style.fontFamily = "'Open Sans', sans-serif";
        htmlOption.style.fontSize = '14px';
        
        // Add hover effect
        [wordOption, htmlOption].forEach(option => {
            option.addEventListener('mouseover', () => {
                option.style.backgroundColor = '#f4ebfa';
            });
            option.addEventListener('mouseout', () => {
                option.style.backgroundColor = 'transparent';
            });
        });
        
        // Add click handlers
        wordOption.addEventListener('click', (e) => {
            e.preventDefault();
            downloadDocument();
            dropdownContent.style.display = 'none';
            dropdownBtn.setAttribute('aria-expanded', 'false');
        });
        
        htmlOption.addEventListener('click', (e) => {
            e.preventDefault();
            downloadAsHTML();
            dropdownContent.style.display = 'none';
            dropdownBtn.setAttribute('aria-expanded', 'false');
        });
        
        // Append options to dropdown
        dropdownContent.appendChild(wordOption);
        dropdownContent.appendChild(htmlOption);
        
        // Toggle dropdown on button click
        dropdownBtn.addEventListener('click', () => {
            const isVisible = dropdownContent.style.display === 'block';
            dropdownContent.style.display = isVisible ? 'none' : 'block';
            dropdownBtn.setAttribute('aria-expanded', !isVisible);
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!dropdownContainer.contains(e.target)) {
                dropdownContent.style.display = 'none';
                dropdownBtn.setAttribute('aria-expanded', 'false');
            }
        });
        
        // Assemble the dropdown
        dropdownContainer.appendChild(dropdownBtn);
        dropdownContainer.appendChild(dropdownContent);
        
        // Add the dropdown to the toolbar
        downloadGroupContainer.appendChild(dropdownContainer);
    }
}

// Call this during initialization
function enhanceDownloadFunctionality() {
    // Override the existing download button with dropdown functionality
    addDownloadOptions();
}

        // Text formatting functions
        function formatText(command) {
            if (!editor) return;
            
            // Focus the editor
            editor.focus();
            
            // Use execCommand for formatting
            switch (command) {
                case 'bold':
                    document.execCommand('bold', false, null);
                    break;
                case 'italic':
                    document.execCommand('italic', false, null);
                    break;
                case 'underline':
                    document.execCommand('underline', false, null);
                    break;
                case 'h1':
                    document.execCommand('formatBlock', false, '<h1>');
                    break;
                case 'h2':
                    document.execCommand('formatBlock', false, '<h2>');
                    break;
                case 'h3':
                    document.execCommand('formatBlock', false, '<h3>');
                    break;
                default:
                    return;
            }
            
            // Update word count after formatting
            updateWordCount();
        }

        // Count words in text
        function countWords(text) {
            if (!text) return 0;
            return text.trim().split(/\s+/).filter(word => word.length > 0).length;
        }

        // Update word count display
        function updateWordCount() {
            if (!editor) return;
            const count = countWords(editor.innerText || '');
            wordCount.textContent = `Words: ${count}`;
        }

        // Update last saved information
        function updateLastSaved() {
            if (!currentDocument) {
                lastSaved.textContent = 'Last saved: Never';
                return;
            }
            
            const date = new Date(currentDocument.lastModified);
            const formattedDate = date.toLocaleTimeString('en-US', {
                hour: 'numeric',
                minute: 'numeric'
            });
            
            lastSaved.textContent = `Last saved: ${formattedDate}`;
        }

       // Enhanced showNotification function with ARIA considerations
        function showNotification(message, type = 'success') {
            notificationMessage.textContent = message;
            notification.className = 'notification'; // Reset classes
            notification.classList.add('show');
            
            // Add type-specific class
            notification.classList.add(`notification-${type}`);
            
            // Change icon based on notification type
            const iconElement = notification.querySelector('i');
            if (iconElement) {
                iconElement.className = type === 'success' 
                    ? 'fas fa-check-circle' 
                    : 'fas fa-exclamation-circle';
            }
            
            // Ensure screen readers announce the notification
            notification.setAttribute('aria-live', 'assertive');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }


        // Enhanced openModal function with ARIA and focus management
        function openModal(modal) {
            if (!modal) return;
            
            // Display the modal
            modal.style.display = 'flex';
            
            // Set ARIA attributes
            modal.setAttribute('aria-hidden', 'false');
            
            // Find the first input in the modal
            const firstInput = modal.querySelector('input, select, textarea, button');
            if (firstInput) {
                // Set a brief timeout to ensure the modal is visible before focusing
                setTimeout(() => {
                    firstInput.focus();
                }, 50);
            }
            
            // Trap focus within modal
            trapFocus(modal);
        }

        // Enhanced closeModals function with ARIA
        function closeModals() {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                modal.style.display = 'none';
                modal.setAttribute('aria-hidden', 'true');
            });
            
            // Return focus to the element that opened the modal
            // This is a simplified approach; a more complete solution
            // would track which button opened which modal
            if (document.activeElement.tagName === 'BUTTON') {
                document.activeElement.focus();
            }
        }

        // Modified startWordCountTracker function to track unsaved changes
        function startWordCountTracker() {
            if (!editor) return;
            
          // For the editor input
            editor.addEventListener('input', () => {
            DocumentManager.updateWordCount();
            
            // Mark that there are unsaved changes
            DocumentManager.hasUnsavedChanges = true;
            
            // Auto-save after 1 second of inactivity
            clearTimeout(editor.saveTimeout);
            editor.saveTimeout = setTimeout(() => {
                DocumentManager.saveDocument();
            }, 1000);
            });
            
            // Also listen for paste events to clean up formatting
            editor.addEventListener('paste', (e) => {
                // Prevent the default paste action
                e.preventDefault();
                
                // Get plain text from clipboard
                const text = (e.clipboardData || window.clipboardData).getData('text/plain');
                
                // Insert text at cursor position
                document.execCommand('insertText', false, text);
                
                // Mark that there are unsaved changes
                hasUnsavedChanges = true;
            });
        }

        window.addEventListener('beforeunload', (e) => {
            // Save any active mode data
            if (currentMode === 'reader' && modes.reader) {
                modes.reader.saveReflections();
            }
            
            if (DocumentManager.hasUnsavedChanges) {
                // Standard message (browsers will display their own message)
                const message = 'You have unsaved changes. Are you sure you want to leave?';
                e.returnValue = message; // Standard for most browsers
                return message; // For older browsers
            }
        });

        // Toggle Textris mode
        function toggleTextrisMode() {
            textrisMode = !textrisMode;
            
            if (textrisMode) {
                // Enable Textris mode
                textrisModeBtn.classList.add('active');
                textrisLevelSelect.style.display = 'inline-block';
                editor.classList.add('textris-mode');
                editor.contentEditable = 'false';
                
                // Apply the current mode (paragraph or sentence)
                applyTextrisMode();
                
                showNotification('Textris Mode enabled - Drag to rearrange!');
            } else {
                // Disable Textris mode
                textrisModeBtn.classList.remove('active');
                textrisLevelSelect.style.display = 'none';
                editor.classList.remove('textris-mode');
                editor.contentEditable = 'true';
                
                // Remove any Textris-specific elements/classes
                removeTextrisElements();
                
                showNotification('Textris Mode disabled');
            }
        }
        
        // Apply Textris Mode based on the selected level (paragraph or sentence)
        function applyTextrisMode() {
            textrisModeLevel = textrisLevelSelect.value;
            
            // First, remove any existing Textris elements
            removeTextrisElements();
            
            if (textrisModeLevel === 'paragraph') {
                // Set up paragraph dragging
                setupParagraphDragging();
            } else {
                // Set up sentence dragging
                setupSentenceDragging();
            }
        }
        
        // Remove Textris-specific elements and classes
        function removeTextrisElements() {
            // Remove any sentence spans
            const sentenceSpans = editor.querySelectorAll('.textris-sentence');
            sentenceSpans.forEach(span => {
                const parent = span.parentNode;
                if (parent) {
                    while (span.firstChild) {
                        parent.insertBefore(span.firstChild, span);
                    }
                    parent.removeChild(span);
                }
            });
            
            // Remove drag-related classes
            const dragElements = editor.querySelectorAll('.dragging, .drag-target, .sentence-drag-target');
            dragElements.forEach(el => {
                el.classList.remove('dragging', 'drag-target', 'sentence-drag-target');
            });
            
            // Remove event listeners (by re-cloning the nodes)
            const paragraphs = editor.querySelectorAll('p, div, h1, h2, h3, h4, h5, h6');
            paragraphs.forEach(p => {
                const clone = p.cloneNode(true);
                p.parentNode.replaceChild(clone, p);
            });
        }
        
        // Add enhanced keyboard support for Textris mode
        function setupParagraphDragging() {
            const paragraphs = editor.querySelectorAll('p, div, h1, h2, h3, h4, h5, h6');
            
            paragraphs.forEach(p => {
                // Set up drag events
                p.setAttribute('draggable', 'true');
                
                // Add ARIA attributes
                p.setAttribute('role', 'region');
                p.setAttribute('aria-label', 'Draggable paragraph');
                
                // Make focusable
                p.setAttribute('tabindex', '0');
                
                // Add keyboard support for dragging
                p.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        // Toggle selection on Enter or Space
                        e.preventDefault();
                        
                        if (draggedElement === p) {
                            // Unselect
                            p.classList.remove('dragging');
                            draggedElement = null;
                        } else {
                            // Select for dragging
                            if (draggedElement) {
                                draggedElement.classList.remove('dragging');
                            }
                            
                            draggedElement = p;
                            p.classList.add('dragging');
                            
                            // Announce selection to screen readers
                            showNotification('Paragraph selected. Use arrow keys to move it.', 'info');
                        }
                    } else if (draggedElement === p) {
                        // When selected, use arrow keys to move
                        const parent = p.parentNode;
                        let target = null;
                        
                        if (e.key === 'ArrowUp') {
                            // Move up
                            target = p.previousElementSibling;
                            if (target) {
                                parent.insertBefore(p, target);
                                p.focus();
                                textrisHistory.saveState();
                            }
                        } else if (e.key === 'ArrowDown') {
                            // Move down
                            target = p.nextElementSibling;
                            if (target) {
                                parent.insertBefore(p, target.nextElementSibling);
                                p.focus();
                                textrisHistory.saveState();
                            }
                        }
                    }
                });
                
                p.addEventListener('dragstart', (e) => {
                    draggedElement = p;
                    p.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', p.innerText); // Required for Firefox
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                p.addEventListener('dragend', () => {
                    p.classList.remove('dragging');
                    draggedElement = null;
                    
                    // Clear any drag targets
                    const targets = document.querySelectorAll('.drag-target');
                    targets.forEach(t => t.classList.remove('drag-target'));
                });
                
                p.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (draggedElement !== p) {
                        // Clear previous targets
                        const targets = document.querySelectorAll('.drag-target');
                        targets.forEach(t => t.classList.remove('drag-target'));
                        
                        // Add target indicator
                        p.classList.add('drag-target');
                        dragTarget = p;
                    }
                });
                
                p.addEventListener('dragleave', () => {
                    p.classList.remove('drag-target');
                    if (dragTarget === p) {
                        dragTarget = null;
                    }
                });
                
                p.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (draggedElement && draggedElement !== p) {
                        // Get the parent of both elements
                        const parent = p.parentNode;
                        
                        // Check if the mouse position is in the top or bottom half of the target
                        const rect = p.getBoundingClientRect();
                        const isAbove = e.clientY < rect.top + rect.height / 2;
                        
                        if (isAbove) {
                            parent.insertBefore(draggedElement, p);
                        } else {
                            parent.insertBefore(draggedElement, p.nextSibling);
                        }
                        
                        // Clear drag state
                        p.classList.remove('drag-target');
                        dragTarget = null;
                        
                        // Save state for undo/redo
                        textrisHistory.saveState();
                        
                        // Save the document since we've made changes
                        DocumentManager.saveDocument();
                    }
                });
            });
        }

        // Add keyboard support to sidebar trigger
        function setupSidebarAccessibility() {
            const sidebarTrigger = document.querySelector('.sidebar-trigger');
            
            // Add keyboard support to the sidebar trigger
            sidebarTrigger.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    toggleSidebarKeyboard();
                }
            });
        }
        
        // Set up sentence dragging
        function setupSentenceDragging() {
            // Define a regex to split text into sentences
            const sentenceRegex = /([^.!?]+[.!?]+)/g;
            
            // Get all paragraph-like elements
            const paragraphs = editor.querySelectorAll('p, div, h1, h2, h3, h4, h5, h6');
            
            paragraphs.forEach(p => {
                // Get the text content
                let html = p.innerHTML;
                
                // Skip if already processed or empty
                if (p.querySelector('.textris-sentence') || !html.trim()) {
                    return;
                }
                
                // Replace sentences with spans
                let processedHtml = '';
                let lastIndex = 0;
                let match;
                
                // Create a temporary element to parse HTML
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;
                
                // Process text nodes only
                const processNode = (node) => {
                    if (node.nodeType === Node.TEXT_NODE) {
                        const text = node.textContent;
                        let processedText = '';
                        let lastTextIndex = 0;
                        
                        // Reset regex for each text node
                        sentenceRegex.lastIndex = 0;
                        
                        while ((match = sentenceRegex.exec(text)) !== null) {
                            // Add text before the sentence
                            processedText += text.substring(lastTextIndex, match.index);
                            
                            // Add the sentence in a span
                            processedText += `<span class="textris-sentence" draggable="true">${match[0]}</span>`;
                            
                            lastTextIndex = match.index + match[0].length;
                        }
                        
                        // Add any remaining text
                        processedText += text.substring(lastTextIndex);
                        
                        // Create a new text node with the processed text
                        const newTextNode = document.createElement('span');
                        newTextNode.innerHTML = processedText;
                        node.parentNode.replaceChild(newTextNode, node);
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        // Process child nodes
                        Array.from(node.childNodes).forEach(processNode);
                    }
                };
                
                // Process all child nodes
                Array.from(tempDiv.childNodes).forEach(processNode);
                
                // Replace the paragraph's content
                p.innerHTML = tempDiv.innerHTML;
                
                // Add drag and drop functionality to sentence spans
                setupSentenceDragEvents(p);
            });
        }
        
        function setupSentenceDragEvents(paragraph) {
    const sentences = paragraph.querySelectorAll('.textris-sentence');
    
    sentences.forEach(sentence => {
        sentence.addEventListener('dragstart', (e) => {
            draggedElement = sentence;
            sentence.classList.add('dragging');
            e.dataTransfer.setData('text/plain', sentence.innerText); // Required for Firefox
            e.dataTransfer.effectAllowed = 'move';
        });
        
        sentence.addEventListener('dragend', () => {
            sentence.classList.remove('dragging');
            draggedElement = null;
            
            // Clear any drag targets
            const targets = document.querySelectorAll('.sentence-drag-target');
            targets.forEach(t => t.classList.remove('sentence-drag-target'));
        });
        
        sentence.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (draggedElement !== sentence) {
                // Clear previous targets
                const targets = document.querySelectorAll('.sentence-drag-target');
                targets.forEach(t => t.classList.remove('sentence-drag-target'));
                
                // Add target indicator
                sentence.classList.add('sentence-drag-target');
                dragTarget = sentence;
            }
        });
        
        sentence.addEventListener('dragleave', () => {
            sentence.classList.remove('sentence-drag-target');
            if (dragTarget === sentence) {
                dragTarget = null;
            }
        });
        
        sentence.addEventListener('drop', (e) => {
            e.preventDefault();
            if (draggedElement && draggedElement !== sentence) {
                // Get the parent of both elements
                const parent = sentence.parentNode;
                
                // Check if the mouse position is in the left or right half of the target
                const rect = sentence.getBoundingClientRect();
                const isLeft = e.clientX < rect.left + rect.width / 2;
                
                if (isLeft) {
                    parent.insertBefore(draggedElement, sentence);
                } else {
                    parent.insertBefore(draggedElement, sentence.nextSibling);
                }
                
                // Clear drag state
                sentence.classList.remove('sentence-drag-target');
                dragTarget = null;
                
                // Save state for undo/redo
                textrisHistory.saveState();
                
                // Save the document since we've made changes
                DocumentManager.saveDocument();
            }
        });
    });
}

        function handleDocumentListClicks(e) {
        const listItem = e.target.closest('.document-item');
        if (listItem && listItem.dataset.id) {
            DocumentManager.openDocument(listItem.dataset.id);
        }
        }

        function handleDocumentListKeydown(e) {
        const listItem = e.target.closest('.document-item');
        if (listItem && listItem.dataset.id && (e.key === 'Enter' || e.key === ' ')) {
            e.preventDefault();
            DocumentManager.openDocument(listItem.dataset.id);
        }
        }

       
   function runCompleteInitialization() {
    console.log("Running complete initialization sequence");
    
    // Remove user parameter handling - just load documents normally
    DocumentManager.loadDocumentsWithKeyTerms();
    
    setupLeftEdgeSidebar();
    setupEventListeners();
    enhanceDownloadFunctionality();

    // Set up document list click handling with delegation
    documentList.addEventListener('click', handleDocumentListClicks);
    documentList.addEventListener('keydown', handleDocumentListKeydown);
    
    // Render documents - use DocumentManager methods
    DocumentManager.renderDocumentList();
    if (DocumentManager.documents.length > 0) {
        DocumentManager.openDocument(DocumentManager.documents[0].id);
    }
    
    // Initialize modes
    setTimeout(() => {
        checkModesExist();
        initModeSystem();
        initAccessibility();
        initInfraredMode();
        textrisHistory.reset();
        startWordCountTracker();
        // Remove addLogoutButton() call
    }, 100);
}
 
// Add this to your initialization sequence to validate infrared patterns
function initInfraredMode() {
    if (modes.infrared && modes.infrared.patterns) {
        Object.entries(modes.infrared.patterns).forEach(([key, pattern]) => {
            if (!validateInfraredPattern(key, pattern)) {
                console.warn(`Infrared pattern "${key}" failed validation`);
            }
        });
        
        console.log('Infrared mode initialized with patterns:', Object.keys(modes.infrared.patterns));
    }
}

        // 7. Add this helper function to the end of your runCompleteInitialization function 
        function verifyModes() {
            console.log("Verifying modes object:", Object.keys(modes));
            
            // Check each mode
            Object.keys(modes).forEach(modeName => {
                console.log(`Checking mode: ${modeName}`);
                traceMode(modeName);
            });
            
            // Check each mode card
            document.querySelectorAll('.mode-card').forEach(card => {
                const modeName = card.dataset.mode;
                console.log(`Mode card: ${modeName}, exists in modes object: ${!!modes[modeName]}`);
            });
        }

        function debugModeButtons() {
            // Get all mode buttons
            const buttons = document.querySelectorAll('.activate-mode-btn');
            
            buttons.forEach(button => {
                // Get the mode name
                const modeCard = button.closest('.mode-card');
                if (!modeCard || !modeCard.dataset.mode) return;
                
                const modeName = modeCard.dataset.mode;
                
                // Add a special debug handler that will run before the normal handler
                button.addEventListener('click', function(e) {
                    // Don't prevent default or stop propagation - we still want the normal handler to run
                    console.log(`Debug: ${modeName} button clicked`);
                    console.log(`Mode exists: ${!!modes[modeName]}`);
                    
                    if (modes[modeName]) {
                        console.log(`Mode activate function exists: ${typeof modes[modeName].activate === 'function'}`);
                    }
                    
                    traceMode(modeName);
                }, true); // Use capturing phase to run before normal handler
            });
            
            console.log(`Added debug handlers to ${buttons.length} mode buttons`);
        }
  





  // Modify the saveDocument function to save to user-specific storage
  const originalSaveDocument = saveDocument;
  
  // Override the saveDocument function
  window.saveDocument = function() {
  // Call DocumentManager's save method
  DocumentManager.saveDocument();
    
  };
  

  // Function to reset the application to factory settings
function resetApplication() {
    // Show confirmation dialog
    if (confirm('WARNING: This will delete ALL your documents and settings, resetting the application to factory defaults. This action cannot be undone. Are you sure you want to proceed?')) {
        
        // Second confirmation for extra safety
        if (confirm('FINAL WARNING: All your data will be permanently lost. Continue?')) {
            
            // Clear all localStorage data
            localStorage.clear();
            
            // Reset global variables
            documents = demoDocuments.slice(); // Create a fresh copy of demo documents
            activeDocumentId = null;
            currentDocument = null;
            hasUnsavedChanges = false;
            
            // Reset DocumentManager
            DocumentManager.documents = demoDocuments.slice();
            DocumentManager.currentDocument = null;
            DocumentManager.activeDocumentId = null;
            DocumentManager.hasUnsavedChanges = false;
            
            // Reset mode state
            if (currentMode) {
                disableCurrentMode(false);
            }
            
            // Save demo documents to localStorage
            localStorage.setItem('nyu_writing_documents', JSON.stringify(demoDocuments));
            
            // Check if a user is logged in
            const userData = localStorage.getItem('user');
            
            
            // Show notification
            showNotification('Application has been reset to factory defaults', 'success');
            
            // Reload the page after a brief delay
            setTimeout(() => {
                window.location.reload();
            }, 1500);
        }
    }
}

// Add event listener for the reset button
document.addEventListener('DOMContentLoaded', function() {
    const resetButton = document.getElementById('reset-app-btn');
    
    if (resetButton) {
        resetButton.addEventListener('click', resetApplication);
    }
});

  
 // Trapdoor functionality - Sends selected text to the Scrapheap document
function setupTrapdoorButton() {
    const trapdoorBtn = document.getElementById('trapdoor-btn');
    
    if (!trapdoorBtn) return;
    
    // Add event listener to the button
    trapdoorBtn.addEventListener('click', function() {
        // Check if we have a text selection
        const selection = window.getSelection();
        const selectedText = selection.toString().trim();
        
        if (!selectedText) {
            showNotification('Nothing selected. Select text before using the trapdoor.', 'warning');
            return;
        }
        
        // Find or create the Scrapheap document
        let scrapheapDoc = DocumentManager.documents.find(doc => doc.title === 'Scrap Heap');
        
        if (!scrapheapDoc) {
            // Create the Scrapheap document if it doesn't exist
            const docId = DocumentManager.createNewDocument('Scrap Heap', '');
            scrapheapDoc = DocumentManager.documents.find(doc => doc.id === docId);
            
            // Add initial content
            if (scrapheapDoc) {
                scrapheapDoc.content = `<h1>Scrap Heap</h1>
<p>This document serves as a repository for content removed via the Trapdoor button. Content here can be reused later if needed.</p>
<hr>`;
                DocumentManager.saveDocument();
            }
        }
        
        // Get the range of the selection
        const range = selection.getRangeAt(0);
        
        // Get the HTML content of the selection if it contains formatting
        let selectedContent;
        
        // Create a temporary div to get the HTML of the selection
        const tempDiv = document.createElement('div');
        tempDiv.appendChild(range.cloneContents());
        
        // Use innerHTML to preserve formatting if any
        selectedContent = tempDiv.innerHTML;
        
        // Prepare content to add to Scrapheap with timestamp
        const now = new Date();
        const formattedDate = now.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
        
        const docTitle = DocumentManager.currentDocument?.title || 'Untitled Document';
        
        // Format the content to add to Scrapheap
        const contentToAdd = `
<div style="padding: 10px; margin: 15px 0; border-left: 3px solid #57068c; background-color: #f9f9f9;">
    <p><strong>Date:</strong> ${formattedDate}</p>
    <p><strong>Source:</strong> ${docTitle}</p>
    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #eee;">
        ${selectedContent}
    </div>
</div>`;
        
        // Add the content to the Scrapheap document
        scrapheapDoc.content = scrapheapDoc.content.replace('</hr>', ''); // Remove closing hr if it exists
        scrapheapDoc.content += contentToAdd;
        
        // Update scrapheap plainText
        const tempDiv2 = document.createElement('div');
        tempDiv2.innerHTML = scrapheapDoc.content;
        scrapheapDoc.plainText = tempDiv2.innerText;
        
        // Update word count
        scrapheapDoc.wordCount = countWords(scrapheapDoc.plainText);
        
        // Update last modified date
        scrapheapDoc.lastModified = new Date().toISOString();
        
        // Save the Scrapheap document
        DocumentManager.saveDocument();
        
        // Now delete the selected content from the current document
        document.execCommand('delete');
        
        // Mark document as having unsaved changes
        DocumentManager.hasUnsavedChanges = true;
        
        // Auto-save the current document after deletion
        clearTimeout(editor.saveTimeout);
        editor.saveTimeout = setTimeout(() => {
            DocumentManager.saveDocument();
        }, 1000);
        
        // Show notification
        showNotification('Content sent to Scrap Heap document', 'success');
    });
}

// Initialize the trapdoor button when the DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    setupTrapdoorButton();
});
  
    

        // Set up event listeners
        function setupEventListeners() {
            // New document button
            newDocumentBtn.addEventListener('click', () => {
                openModal(newDocumentModal);
            });
            
            // User profile button
            userProfileBtn.addEventListener('click', () => {
                openModal(userProfileModal);
            });
            
            // Textris mode selector
            if (textrisLevelSelect) {
                textrisLevelSelect.addEventListener('change', applyTextrisMode);
            }
            
            // Modal close buttons
            modalCloseButtons.forEach(button => {
                button.addEventListener('click', closeModals);
            });
            
            // Click outside modal to close
            window.addEventListener('click', (e) => {
                if (e.target.classList.contains('modal')) {
                    closeModals();
                }
            });

             // Report Bug button
            const reportBugBtn = document.getElementById('report-bug-btn');
            if (reportBugBtn) {
                reportBugBtn.addEventListener('click', function() {
                    window.open('https://docs.google.com/forms/d/e/1FAIpQLSd6qo0XFo3jvyHgKH85X8JQVu3Tz-rsO0TCxlfyEtM9MxvxFQ/viewform?usp=dialog', '_blank');
                });
            }
            
            // Cancel buttons
            cancelNewDocBtn.addEventListener('click', closeModals);
            cancelProfileBtn.addEventListener('click', closeModals);
            
            // Create new document button
            // For the create new document modal
            createNewDocBtn.addEventListener('click', () => {
            // Get values from form
            const title = newDocTitle.value.trim() || 'Untitled Document';
            const description = newDocDescription.value.trim();
            
            // Create new document
            DocumentManager.createNewDocument(title, description);
            
            // Reset form
            newDocTitle.value = '';
            newDocDescription.value = '';
            
            // Close modal
            closeModals();
            
            // Focus the editor
            editor.focus();
            });

            
            // Save profile button
            saveProfileBtn.addEventListener('click', () => {
                // In a real app, this would save user profile information
                showNotification('Profile updated successfully!');
                closeModals();
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Ctrl+S or Cmd+S to save
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    DocumentManager.saveDocument();
                }
                
                // Escape to close modals
                if (e.key === 'Escape') {
                    closeModals();
                }
                
                // Escape to exit Textris mode
                if (e.key === 'Escape' && textrisMode) {
                    toggleTextrisMode();
                }
            });
        }

        // Need to add a window cleanup function to handle when the main window is closed
        window.addEventListener('beforeunload', function() {
            // Close the Pomodoro popup if it exists
            if (modes.pomodoro && modes.pomodoro.popupWindow && !modes.pomodoro.popupWindow.closed) {
                modes.pomodoro.popupWindow.close();
            }})

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>
